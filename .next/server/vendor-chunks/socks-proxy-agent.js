"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socks-proxy-agent";
exports.ids = ["vendor-chunks/socks-proxy-agent"];
exports.modules = {

/***/ "(rsc)/./node_modules/socks-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/socks-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SocksProxyAgent = void 0;\nconst socks_1 = __webpack_require__(/*! socks */ \"(rsc)/./node_modules/socks/build/index.js\");\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/agent-base/dist/src/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst dns_1 = __importDefault(__webpack_require__(/*! dns */ \"dns\"));\nconst tls_1 = __importDefault(__webpack_require__(/*! tls */ \"tls\"));\nconst debug = (0, debug_1.default)('socks-proxy-agent');\nfunction parseSocksProxy(opts) {\n    var _a;\n    let port = 0;\n    let lookup = false;\n    let type = 5;\n    const host = opts.hostname;\n    if (host == null) {\n        throw new TypeError('No \"host\"');\n    }\n    if (typeof opts.port === 'number') {\n        port = opts.port;\n    }\n    else if (typeof opts.port === 'string') {\n        port = parseInt(opts.port, 10);\n    }\n    // From RFC 1928, Section 3: https://tools.ietf.org/html/rfc1928#section-3\n    // \"The SOCKS service is conventionally located on TCP port 1080\"\n    if (port == null) {\n        port = 1080;\n    }\n    // figure out if we want socks v4 or v5, based on the \"protocol\" used.\n    // Defaults to 5.\n    if (opts.protocol != null) {\n        switch (opts.protocol.replace(':', '')) {\n            case 'socks4':\n                lookup = true;\n            // pass through\n            case 'socks4a':\n                type = 4;\n                break;\n            case 'socks5':\n                lookup = true;\n            // pass through\n            case 'socks': // no version specified, default to 5h\n            case 'socks5h':\n                type = 5;\n                break;\n            default:\n                throw new TypeError(`A \"socks\" protocol must be specified! Got: ${String(opts.protocol)}`);\n        }\n    }\n    if (typeof opts.type !== 'undefined') {\n        if (opts.type === 4 || opts.type === 5) {\n            type = opts.type;\n        }\n        else {\n            throw new TypeError(`\"type\" must be 4 or 5, got: ${String(opts.type)}`);\n        }\n    }\n    const proxy = {\n        host,\n        port,\n        type\n    };\n    let userId = (_a = opts.userId) !== null && _a !== void 0 ? _a : opts.username;\n    let password = opts.password;\n    if (opts.auth != null) {\n        const auth = opts.auth.split(':');\n        userId = auth[0];\n        password = auth[1];\n    }\n    if (userId != null) {\n        Object.defineProperty(proxy, 'userId', {\n            value: userId,\n            enumerable: false\n        });\n    }\n    if (password != null) {\n        Object.defineProperty(proxy, 'password', {\n            value: password,\n            enumerable: false\n        });\n    }\n    return { lookup, proxy };\n}\nconst normalizeProxyOptions = (input) => {\n    let proxyOptions;\n    if (typeof input === 'string') {\n        proxyOptions = new URL(input);\n    }\n    else {\n        proxyOptions = input;\n    }\n    if (proxyOptions == null) {\n        throw new TypeError('a SOCKS proxy server `host` and `port` must be specified!');\n    }\n    return proxyOptions;\n};\nclass SocksProxyAgent extends agent_base_1.Agent {\n    constructor(input, options) {\n        var _a;\n        const proxyOptions = normalizeProxyOptions(input);\n        super(proxyOptions);\n        const parsedProxy = parseSocksProxy(proxyOptions);\n        this.shouldLookup = parsedProxy.lookup;\n        this.proxy = parsedProxy.proxy;\n        this.tlsConnectionOptions = proxyOptions.tls != null ? proxyOptions.tls : {};\n        this.timeout = (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Initiates a SOCKS connection to the specified SOCKS proxy server,\n     * which in turn connects to the specified remote host and port.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { shouldLookup, proxy, timeout } = this;\n            let { host, port, lookup: lookupCallback } = opts;\n            if (host == null) {\n                throw new Error('No `host` defined!');\n            }\n            if (shouldLookup) {\n                // Client-side DNS resolution for \"4\" and \"5\" socks proxy versions.\n                host = yield new Promise((resolve, reject) => {\n                    // Use the request's custom lookup, if one was configured:\n                    const lookupFn = lookupCallback !== null && lookupCallback !== void 0 ? lookupCallback : dns_1.default.lookup;\n                    lookupFn(host, {}, (err, res) => {\n                        if (err) {\n                            reject(err);\n                        }\n                        else {\n                            resolve(res);\n                        }\n                    });\n                });\n            }\n            const socksOpts = {\n                proxy,\n                destination: { host, port },\n                command: 'connect',\n                timeout: timeout !== null && timeout !== void 0 ? timeout : undefined\n            };\n            const cleanup = (tlsSocket) => {\n                req.destroy();\n                socket.destroy();\n                if (tlsSocket)\n                    tlsSocket.destroy();\n            };\n            debug('Creating socks proxy connection: %o', socksOpts);\n            const { socket } = yield socks_1.SocksClient.createConnection(socksOpts);\n            debug('Successfully created socks proxy connection');\n            if (timeout !== null) {\n                socket.setTimeout(timeout);\n                socket.on('timeout', () => cleanup());\n            }\n            if (opts.secureEndpoint) {\n                // The proxy is connecting to a TLS server, so upgrade\n                // this socket connection to a TLS connection.\n                debug('Upgrading socket connection to TLS');\n                const servername = (_a = opts.servername) !== null && _a !== void 0 ? _a : opts.host;\n                const tlsSocket = tls_1.default.connect(Object.assign(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,\n                    servername }), this.tlsConnectionOptions));\n                tlsSocket.once('error', (error) => {\n                    debug('socket TLS error', error.message);\n                    cleanup(tlsSocket);\n                });\n                return tlsSocket;\n            }\n            return socket;\n        });\n    }\n}\nexports.SocksProxyAgent = SocksProxyAgent;\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for (key in obj) {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQU87QUFDL0IscUJBQXFCLG1CQUFPLENBQUMscUVBQVk7QUFDekMsZ0NBQWdDLG1CQUFPLENBQUMsc0RBQU87QUFDL0MsOEJBQThCLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHNCQUFzQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxrQkFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25ELGtCQUFrQixxQ0FBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0cscURBQXFEO0FBQ3pKLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzMi1za2luLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvc29ja3MtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcz9kZTEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tzUHJveHlBZ2VudCA9IHZvaWQgMDtcbmNvbnN0IHNvY2tzXzEgPSByZXF1aXJlKFwic29ja3NcIik7XG5jb25zdCBhZ2VudF9iYXNlXzEgPSByZXF1aXJlKFwiYWdlbnQtYmFzZVwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGRuc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkbnNcIikpO1xuY29uc3QgdGxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRsc1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdzb2Nrcy1wcm94eS1hZ2VudCcpO1xuZnVuY3Rpb24gcGFyc2VTb2Nrc1Byb3h5KG9wdHMpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBvcnQgPSAwO1xuICAgIGxldCBsb29rdXAgPSBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IDU7XG4gICAgY29uc3QgaG9zdCA9IG9wdHMuaG9zdG5hbWU7XG4gICAgaWYgKGhvc3QgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBcImhvc3RcIicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMucG9ydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcG9ydCA9IG9wdHMucG9ydDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcG9ydCA9IHBhcnNlSW50KG9wdHMucG9ydCwgMTApO1xuICAgIH1cbiAgICAvLyBGcm9tIFJGQyAxOTI4LCBTZWN0aW9uIDM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxOTI4I3NlY3Rpb24tM1xuICAgIC8vIFwiVGhlIFNPQ0tTIHNlcnZpY2UgaXMgY29udmVudGlvbmFsbHkgbG9jYXRlZCBvbiBUQ1AgcG9ydCAxMDgwXCJcbiAgICBpZiAocG9ydCA9PSBudWxsKSB7XG4gICAgICAgIHBvcnQgPSAxMDgwO1xuICAgIH1cbiAgICAvLyBmaWd1cmUgb3V0IGlmIHdlIHdhbnQgc29ja3MgdjQgb3IgdjUsIGJhc2VkIG9uIHRoZSBcInByb3RvY29sXCIgdXNlZC5cbiAgICAvLyBEZWZhdWx0cyB0byA1LlxuICAgIGlmIChvcHRzLnByb3RvY29sICE9IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChvcHRzLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJykpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NvY2tzNCc6XG4gICAgICAgICAgICAgICAgbG9va3VwID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnc29ja3M0YSc6XG4gICAgICAgICAgICAgICAgdHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzb2NrczUnOlxuICAgICAgICAgICAgICAgIGxvb2t1cCA9IHRydWU7XG4gICAgICAgICAgICAvLyBwYXNzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3NvY2tzJzogLy8gbm8gdmVyc2lvbiBzcGVjaWZpZWQsIGRlZmF1bHQgdG8gNWhcbiAgICAgICAgICAgIGNhc2UgJ3NvY2tzNWgnOlxuICAgICAgICAgICAgICAgIHR5cGUgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBIFwic29ja3NcIiBwcm90b2NvbCBtdXN0IGJlIHNwZWNpZmllZCEgR290OiAke1N0cmluZyhvcHRzLnByb3RvY29sKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMudHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKG9wdHMudHlwZSA9PT0gNCB8fCBvcHRzLnR5cGUgPT09IDUpIHtcbiAgICAgICAgICAgIHR5cGUgPSBvcHRzLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcInR5cGVcIiBtdXN0IGJlIDQgb3IgNSwgZ290OiAke1N0cmluZyhvcHRzLnR5cGUpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHByb3h5ID0ge1xuICAgICAgICBob3N0LFxuICAgICAgICBwb3J0LFxuICAgICAgICB0eXBlXG4gICAgfTtcbiAgICBsZXQgdXNlcklkID0gKF9hID0gb3B0cy51c2VySWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdHMudXNlcm5hbWU7XG4gICAgbGV0IHBhc3N3b3JkID0gb3B0cy5wYXNzd29yZDtcbiAgICBpZiAob3B0cy5hdXRoICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgYXV0aCA9IG9wdHMuYXV0aC5zcGxpdCgnOicpO1xuICAgICAgICB1c2VySWQgPSBhdXRoWzBdO1xuICAgICAgICBwYXNzd29yZCA9IGF1dGhbMV07XG4gICAgfVxuICAgIGlmICh1c2VySWQgIT0gbnVsbCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksICd1c2VySWQnLCB7XG4gICAgICAgICAgICB2YWx1ZTogdXNlcklkLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXNzd29yZCAhPSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgJ3Bhc3N3b3JkJywge1xuICAgICAgICAgICAgdmFsdWU6IHBhc3N3b3JkLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGxvb2t1cCwgcHJveHkgfTtcbn1cbmNvbnN0IG5vcm1hbGl6ZVByb3h5T3B0aW9ucyA9IChpbnB1dCkgPT4ge1xuICAgIGxldCBwcm94eU9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcHJveHlPcHRpb25zID0gbmV3IFVSTChpbnB1dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm94eU9wdGlvbnMgPSBpbnB1dDtcbiAgICB9XG4gICAgaWYgKHByb3h5T3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgU09DS1MgcHJveHkgc2VydmVyIGBob3N0YCBhbmQgYHBvcnRgIG11c3QgYmUgc3BlY2lmaWVkIScpO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHlPcHRpb25zO1xufTtcbmNsYXNzIFNvY2tzUHJveHlBZ2VudCBleHRlbmRzIGFnZW50X2Jhc2VfMS5BZ2VudCB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBwcm94eU9wdGlvbnMgPSBub3JtYWxpemVQcm94eU9wdGlvbnMoaW5wdXQpO1xuICAgICAgICBzdXBlcihwcm94eU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXJzZWRQcm94eSA9IHBhcnNlU29ja3NQcm94eShwcm94eU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNob3VsZExvb2t1cCA9IHBhcnNlZFByb3h5Lmxvb2t1cDtcbiAgICAgICAgdGhpcy5wcm94eSA9IHBhcnNlZFByb3h5LnByb3h5O1xuICAgICAgICB0aGlzLnRsc0Nvbm5lY3Rpb25PcHRpb25zID0gcHJveHlPcHRpb25zLnRscyAhPSBudWxsID8gcHJveHlPcHRpb25zLnRscyA6IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGVzIGEgU09DS1MgY29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIFNPQ0tTIHByb3h5IHNlcnZlcixcbiAgICAgKiB3aGljaCBpbiB0dXJuIGNvbm5lY3RzIHRvIHRoZSBzcGVjaWZpZWQgcmVtb3RlIGhvc3QgYW5kIHBvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNhbGxiYWNrKHJlcSwgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNob3VsZExvb2t1cCwgcHJveHksIHRpbWVvdXQgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBob3N0LCBwb3J0LCBsb29rdXA6IGxvb2t1cENhbGxiYWNrIH0gPSBvcHRzO1xuICAgICAgICAgICAgaWYgKGhvc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYGhvc3RgIGRlZmluZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkTG9va3VwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xpZW50LXNpZGUgRE5TIHJlc29sdXRpb24gZm9yIFwiNFwiIGFuZCBcIjVcIiBzb2NrcyBwcm94eSB2ZXJzaW9ucy5cbiAgICAgICAgICAgICAgICBob3N0ID0geWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHJlcXVlc3QncyBjdXN0b20gbG9va3VwLCBpZiBvbmUgd2FzIGNvbmZpZ3VyZWQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvb2t1cEZuID0gbG9va3VwQ2FsbGJhY2sgIT09IG51bGwgJiYgbG9va3VwQ2FsbGJhY2sgIT09IHZvaWQgMCA/IGxvb2t1cENhbGxiYWNrIDogZG5zXzEuZGVmYXVsdC5sb29rdXA7XG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cEZuKGhvc3QsIHt9LCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb2Nrc09wdHMgPSB7XG4gICAgICAgICAgICAgICAgcHJveHksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb246IHsgaG9zdCwgcG9ydCB9LFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb25uZWN0JyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0ICE9PSBudWxsICYmIHRpbWVvdXQgIT09IHZvaWQgMCA/IHRpbWVvdXQgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gKHRsc1NvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBpZiAodGxzU29ja2V0KVxuICAgICAgICAgICAgICAgICAgICB0bHNTb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBzb2NrcyBwcm94eSBjb25uZWN0aW9uOiAlbycsIHNvY2tzT3B0cyk7XG4gICAgICAgICAgICBjb25zdCB7IHNvY2tldCB9ID0geWllbGQgc29ja3NfMS5Tb2Nrc0NsaWVudC5jcmVhdGVDb25uZWN0aW9uKHNvY2tzT3B0cyk7XG4gICAgICAgICAgICBkZWJ1ZygnU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgc29ja3MgcHJveHkgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2V0VGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzb2NrZXQub24oJ3RpbWVvdXQnLCAoKSA9PiBjbGVhbnVwKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuc2VjdXJlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJveHkgaXMgY29ubmVjdGluZyB0byBhIFRMUyBzZXJ2ZXIsIHNvIHVwZ3JhZGVcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNvY2tldCBjb25uZWN0aW9uIHRvIGEgVExTIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgZGVidWcoJ1VwZ3JhZGluZyBzb2NrZXQgY29ubmVjdGlvbiB0byBUTFMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJuYW1lID0gKF9hID0gb3B0cy5zZXJ2ZXJuYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcHRzLmhvc3Q7XG4gICAgICAgICAgICAgICAgY29uc3QgdGxzU29ja2V0ID0gdGxzXzEuZGVmYXVsdC5jb25uZWN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbWl0KG9wdHMsICdob3N0JywgJ2hvc3RuYW1lJywgJ3BhdGgnLCAncG9ydCcpKSwgeyBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlcm5hbWUgfSksIHRoaXMudGxzQ29ubmVjdGlvbk9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB0bHNTb2NrZXQub25jZSgnZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ3NvY2tldCBUTFMgZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCh0bHNTb2NrZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bHNTb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tzUHJveHlBZ2VudCA9IFNvY2tzUHJveHlBZ2VudDtcbmZ1bmN0aW9uIG9taXQob2JqLCAuLi5rZXlzKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks-proxy-agent/dist/index.js\n");

/***/ })

};
;