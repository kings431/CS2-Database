"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/steam-totp";
exports.ids = ["vendor-chunks/steam-totp"];
exports.modules = {

/***/ "(rsc)/./node_modules/steam-totp/index.js":
/*!******************************************!*\
  !*** ./node_modules/steam-totp/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n\r\nconst Crypto = __webpack_require__(/*! crypto */ \"crypto\");\r\n\r\n/**\r\n * Returns the current local Unix time\r\n * @param {number} [timeOffset=0] - This many seconds will be added to the returned time\r\n * @returns {number}\r\n */\r\nexports.time = function(timeOffset) {\r\n\treturn Math.floor(Date.now() / 1000) + (timeOffset || 0);\r\n};\r\n\r\n/**\r\n * Generate a Steam-style TOTP authentication code.\r\n * @param {Buffer|string} secret - Your TOTP shared_secret as a Buffer, hex, or base64\r\n * @param {number} [timeOffset=0] - If you know how far off your clock is from the Steam servers, put the offset here in seconds\r\n * @returns {string}\r\n */\r\nexports.generateAuthCode = exports.getAuthCode = function(secret, timeOffset) {\r\n\tif (typeof timeOffset === 'function') {\r\n\t\texports.getTimeOffset((err, offset, latency) => {\r\n\t\t\tif (err) {\r\n\t\t\t\ttimeOffset(err);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet code = exports.generateAuthCode(secret, offset);\r\n\t\t\ttimeOffset(null, code, offset, latency);\r\n\t\t});\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\tsecret = bufferizeSecret(secret);\r\n\r\n\tlet time = exports.time(timeOffset);\r\n\r\n\tlet buffer = Buffer.allocUnsafe(8);\r\n\t// The first 4 bytes are the high 4 bytes of a 64-bit integer. To make things easier on ourselves, let's just pretend\r\n\t// that it's a 32-bit int and write 0 for the high bytes. Since we're dividing by 30, this won't cause a problem\r\n\t// until the year 6053.\r\n\tbuffer.writeUInt32BE(0, 0);\r\n\tbuffer.writeUInt32BE(Math.floor(time / 30), 4);\r\n\r\n\tlet hmac = Crypto.createHmac('sha1', secret);\r\n\thmac = hmac.update(buffer).digest();\r\n\r\n\tlet start = hmac[19] & 0x0F;\r\n\thmac = hmac.slice(start, start + 4);\r\n\r\n\tlet fullcode = hmac.readUInt32BE(0) & 0x7FFFFFFF;\r\n\r\n\tconst chars = '23456789BCDFGHJKMNPQRTVWXY';\r\n\r\n\tlet code = '';\r\n\tfor (let i = 0; i < 5; i++) {\r\n\t\tcode += chars.charAt(fullcode % chars.length);\r\n\t\tfullcode /= chars.length;\r\n\t}\r\n\r\n\treturn code;\r\n};\r\n\r\n/**\r\n * Generate a base64 confirmation key for use with mobile trade confirmations. The key can only be used once.\r\n * @param {Buffer|string} identitySecret - The identity_secret that you received when enabling two-factor authentication\r\n * @param {number} time - The Unix time for which you are generating this secret. Generally should be the current time.\r\n * @param {string} tag - The tag which identifies what this request (and therefore key) will be for. \"conf\" to load the confirmations page, \"details\" to load details about a trade, \"allow\" to confirm a trade, \"cancel\" to cancel it.\r\n * @returns {string}\r\n */\r\nexports.generateConfirmationKey = exports.getConfirmationKey = function(identitySecret, time, tag) {\r\n\tidentitySecret = bufferizeSecret(identitySecret);\r\n\r\n\tlet dataLen = 8;\r\n\r\n\tif (tag) {\r\n\t\tif (tag.length > 32) {\r\n\t\t\tdataLen += 32;\r\n\t\t} else {\r\n\t\t\tdataLen += tag.length;\r\n\t\t}\r\n\t}\r\n\r\n\tlet buffer = Buffer.allocUnsafe(dataLen);\r\n\r\n\t// Auto-detect whether we have support for Buffer#writeUInt64BE and use it if we can. If we have writeUInt64BE\r\n\t// then we also definitely have BigInt.\r\n\tif (buffer.writeBigUInt64BE) {\r\n\t\tbuffer.writeBigUInt64BE(BigInt(time), 0);\r\n\t} else {\r\n\t\t// Fall back to old Y2K38-unsafe behavior.\r\n\t\t// If you're still using Node.js <10.20.0 in 2038, you only have yourself to blame.\r\n\t\tbuffer.writeUInt32BE(0, 0);\r\n\t\tbuffer.writeUInt32BE(time, 4);\r\n\t}\r\n\r\n\tif (tag) {\r\n\t\tbuffer.write(tag, 8);\r\n\t}\r\n\r\n\tlet hmac = Crypto.createHmac('sha1', identitySecret);\r\n\treturn hmac.update(buffer).digest('base64');\r\n};\r\n\r\nexports.getTimeOffset = function(callback) {\r\n\tlet start = Date.now();\r\n\tlet req = (__webpack_require__(/*! https */ \"https\").request)({\r\n\t\t\"hostname\": \"api.steampowered.com\",\r\n\t\t\"path\": \"/ITwoFactorService/QueryTime/v1/\",\r\n\t\t\"method\": \"POST\",\r\n\t\t\"headers\": {\r\n\t\t\t\"Content-Length\": 0\r\n\t\t}\r\n\t}, (res) => {\r\n\t\tif (res.statusCode != 200) {\r\n\t\t\tcallback(new Error(\"HTTP error \" + res.statusCode));\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet response = '';\r\n\t\tres.on('data', (chunk) => {\r\n\t\t\tresponse += chunk;\r\n\t\t});\r\n\r\n\t\tres.on('end', () => {\r\n\t\t\ttry {\r\n\t\t\t\tresponse = JSON.parse(response).response;\r\n\t\t\t} catch(e) {\r\n\t\t\t\tcallback(new Error(\"Malformed response\"));\r\n\t\t\t}\r\n\r\n\t\t\tif (!response || !response.server_time) {\r\n\t\t\t\tcallback(new Error(\"Malformed response\"));\r\n\t\t\t}\r\n\r\n\t\t\tlet end = Date.now();\r\n\t\t\tlet offset = response.server_time - exports.time();\r\n\r\n\t\t\tcallback(null, offset, end - start);\r\n\t\t});\r\n\t});\r\n\r\n\treq.on('error', callback);\r\n\r\n\treq.end();\r\n};\r\n\r\n/**\r\n * Get a standardized device ID based on your SteamID.\r\n * @param {string|object} steamID - Your SteamID, either as a string or as an object which has a toString() method that returns the SteamID\r\n * @returns {string}\r\n */\r\nexports.getDeviceID = function(steamID) {\r\n\tlet salt = process.env.STEAM_TOTP_SALT || '';\r\n\treturn \"android:\" + Crypto.createHash('sha1').update(steamID.toString() + salt).digest('hex')\r\n\t\t\t.replace(/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12}).*$/, '$1-$2-$3-$4-$5');\r\n};\r\n\r\nfunction bufferizeSecret(secret) {\r\n\tif (typeof secret === 'string') {\r\n\t\t// Check if it's hex\r\n\t\tif (secret.match(/[0-9a-f]{40}/i)) {\r\n\t\t\treturn Buffer.from(secret, 'hex');\r\n\t\t} else {\r\n\t\t\t// Looks like it's base64\r\n\t\t\treturn Buffer.from(secret, 'base64');\r\n\t\t}\r\n\t}\r\n\r\n\treturn secret;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3RlYW0tdG90cC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsK0JBQStCLEdBQUcsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxXQUFXLG1EQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxHQUFHO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsR0FBRztBQUNoQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzMi1za2luLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvc3RlYW0tdG90cC9pbmRleC5qcz9lNTA1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IENyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYWwgVW5peCB0aW1lXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZU9mZnNldD0wXSAtIFRoaXMgbWFueSBzZWNvbmRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJldHVybmVkIHRpbWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmV4cG9ydHMudGltZSA9IGZ1bmN0aW9uKHRpbWVPZmZzZXQpIHtcclxuXHRyZXR1cm4gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyAodGltZU9mZnNldCB8fCAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIFN0ZWFtLXN0eWxlIFRPVFAgYXV0aGVudGljYXRpb24gY29kZS5cclxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBzZWNyZXQgLSBZb3VyIFRPVFAgc2hhcmVkX3NlY3JldCBhcyBhIEJ1ZmZlciwgaGV4LCBvciBiYXNlNjRcclxuICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lT2Zmc2V0PTBdIC0gSWYgeW91IGtub3cgaG93IGZhciBvZmYgeW91ciBjbG9jayBpcyBmcm9tIHRoZSBTdGVhbSBzZXJ2ZXJzLCBwdXQgdGhlIG9mZnNldCBoZXJlIGluIHNlY29uZHNcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmV4cG9ydHMuZ2VuZXJhdGVBdXRoQ29kZSA9IGV4cG9ydHMuZ2V0QXV0aENvZGUgPSBmdW5jdGlvbihzZWNyZXQsIHRpbWVPZmZzZXQpIHtcclxuXHRpZiAodHlwZW9mIHRpbWVPZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdGV4cG9ydHMuZ2V0VGltZU9mZnNldCgoZXJyLCBvZmZzZXQsIGxhdGVuY3kpID0+IHtcclxuXHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdHRpbWVPZmZzZXQoZXJyKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBjb2RlID0gZXhwb3J0cy5nZW5lcmF0ZUF1dGhDb2RlKHNlY3JldCwgb2Zmc2V0KTtcclxuXHRcdFx0dGltZU9mZnNldChudWxsLCBjb2RlLCBvZmZzZXQsIGxhdGVuY3kpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0c2VjcmV0ID0gYnVmZmVyaXplU2VjcmV0KHNlY3JldCk7XHJcblxyXG5cdGxldCB0aW1lID0gZXhwb3J0cy50aW1lKHRpbWVPZmZzZXQpO1xyXG5cclxuXHRsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDgpO1xyXG5cdC8vIFRoZSBmaXJzdCA0IGJ5dGVzIGFyZSB0aGUgaGlnaCA0IGJ5dGVzIG9mIGEgNjQtYml0IGludGVnZXIuIFRvIG1ha2UgdGhpbmdzIGVhc2llciBvbiBvdXJzZWx2ZXMsIGxldCdzIGp1c3QgcHJldGVuZFxyXG5cdC8vIHRoYXQgaXQncyBhIDMyLWJpdCBpbnQgYW5kIHdyaXRlIDAgZm9yIHRoZSBoaWdoIGJ5dGVzLiBTaW5jZSB3ZSdyZSBkaXZpZGluZyBieSAzMCwgdGhpcyB3b24ndCBjYXVzZSBhIHByb2JsZW1cclxuXHQvLyB1bnRpbCB0aGUgeWVhciA2MDUzLlxyXG5cdGJ1ZmZlci53cml0ZVVJbnQzMkJFKDAsIDApO1xyXG5cdGJ1ZmZlci53cml0ZVVJbnQzMkJFKE1hdGguZmxvb3IodGltZSAvIDMwKSwgNCk7XHJcblxyXG5cdGxldCBobWFjID0gQ3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTEnLCBzZWNyZXQpO1xyXG5cdGhtYWMgPSBobWFjLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpO1xyXG5cclxuXHRsZXQgc3RhcnQgPSBobWFjWzE5XSAmIDB4MEY7XHJcblx0aG1hYyA9IGhtYWMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgNCk7XHJcblxyXG5cdGxldCBmdWxsY29kZSA9IGhtYWMucmVhZFVJbnQzMkJFKDApICYgMHg3RkZGRkZGRjtcclxuXHJcblx0Y29uc3QgY2hhcnMgPSAnMjM0NTY3ODlCQ0RGR0hKS01OUFFSVFZXWFknO1xyXG5cclxuXHRsZXQgY29kZSA9ICcnO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcblx0XHRjb2RlICs9IGNoYXJzLmNoYXJBdChmdWxsY29kZSAlIGNoYXJzLmxlbmd0aCk7XHJcblx0XHRmdWxsY29kZSAvPSBjaGFycy5sZW5ndGg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29kZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIGJhc2U2NCBjb25maXJtYXRpb24ga2V5IGZvciB1c2Ugd2l0aCBtb2JpbGUgdHJhZGUgY29uZmlybWF0aW9ucy4gVGhlIGtleSBjYW4gb25seSBiZSB1c2VkIG9uY2UuXHJcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gaWRlbnRpdHlTZWNyZXQgLSBUaGUgaWRlbnRpdHlfc2VjcmV0IHRoYXQgeW91IHJlY2VpdmVkIHdoZW4gZW5hYmxpbmcgdHdvLWZhY3RvciBhdXRoZW50aWNhdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSAtIFRoZSBVbml4IHRpbWUgZm9yIHdoaWNoIHlvdSBhcmUgZ2VuZXJhdGluZyB0aGlzIHNlY3JldC4gR2VuZXJhbGx5IHNob3VsZCBiZSB0aGUgY3VycmVudCB0aW1lLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0gVGhlIHRhZyB3aGljaCBpZGVudGlmaWVzIHdoYXQgdGhpcyByZXF1ZXN0IChhbmQgdGhlcmVmb3JlIGtleSkgd2lsbCBiZSBmb3IuIFwiY29uZlwiIHRvIGxvYWQgdGhlIGNvbmZpcm1hdGlvbnMgcGFnZSwgXCJkZXRhaWxzXCIgdG8gbG9hZCBkZXRhaWxzIGFib3V0IGEgdHJhZGUsIFwiYWxsb3dcIiB0byBjb25maXJtIGEgdHJhZGUsIFwiY2FuY2VsXCIgdG8gY2FuY2VsIGl0LlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0cy5nZW5lcmF0ZUNvbmZpcm1hdGlvbktleSA9IGV4cG9ydHMuZ2V0Q29uZmlybWF0aW9uS2V5ID0gZnVuY3Rpb24oaWRlbnRpdHlTZWNyZXQsIHRpbWUsIHRhZykge1xyXG5cdGlkZW50aXR5U2VjcmV0ID0gYnVmZmVyaXplU2VjcmV0KGlkZW50aXR5U2VjcmV0KTtcclxuXHJcblx0bGV0IGRhdGFMZW4gPSA4O1xyXG5cclxuXHRpZiAodGFnKSB7XHJcblx0XHRpZiAodGFnLmxlbmd0aCA+IDMyKSB7XHJcblx0XHRcdGRhdGFMZW4gKz0gMzI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkYXRhTGVuICs9IHRhZy5sZW5ndGg7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGRhdGFMZW4pO1xyXG5cclxuXHQvLyBBdXRvLWRldGVjdCB3aGV0aGVyIHdlIGhhdmUgc3VwcG9ydCBmb3IgQnVmZmVyI3dyaXRlVUludDY0QkUgYW5kIHVzZSBpdCBpZiB3ZSBjYW4uIElmIHdlIGhhdmUgd3JpdGVVSW50NjRCRVxyXG5cdC8vIHRoZW4gd2UgYWxzbyBkZWZpbml0ZWx5IGhhdmUgQmlnSW50LlxyXG5cdGlmIChidWZmZXIud3JpdGVCaWdVSW50NjRCRSkge1xyXG5cdFx0YnVmZmVyLndyaXRlQmlnVUludDY0QkUoQmlnSW50KHRpbWUpLCAwKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIG9sZCBZMkszOC11bnNhZmUgYmVoYXZpb3IuXHJcblx0XHQvLyBJZiB5b3UncmUgc3RpbGwgdXNpbmcgTm9kZS5qcyA8MTAuMjAuMCBpbiAyMDM4LCB5b3Ugb25seSBoYXZlIHlvdXJzZWxmIHRvIGJsYW1lLlxyXG5cdFx0YnVmZmVyLndyaXRlVUludDMyQkUoMCwgMCk7XHJcblx0XHRidWZmZXIud3JpdGVVSW50MzJCRSh0aW1lLCA0KTtcclxuXHR9XHJcblxyXG5cdGlmICh0YWcpIHtcclxuXHRcdGJ1ZmZlci53cml0ZSh0YWcsIDgpO1xyXG5cdH1cclxuXHJcblx0bGV0IGhtYWMgPSBDcnlwdG8uY3JlYXRlSG1hYygnc2hhMScsIGlkZW50aXR5U2VjcmV0KTtcclxuXHRyZXR1cm4gaG1hYy51cGRhdGUoYnVmZmVyKS5kaWdlc3QoJ2Jhc2U2NCcpO1xyXG59O1xyXG5cclxuZXhwb3J0cy5nZXRUaW1lT2Zmc2V0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG5cdGxldCByZXEgPSByZXF1aXJlKCdodHRwcycpLnJlcXVlc3Qoe1xyXG5cdFx0XCJob3N0bmFtZVwiOiBcImFwaS5zdGVhbXBvd2VyZWQuY29tXCIsXHJcblx0XHRcInBhdGhcIjogXCIvSVR3b0ZhY3RvclNlcnZpY2UvUXVlcnlUaW1lL3YxL1wiLFxyXG5cdFx0XCJtZXRob2RcIjogXCJQT1NUXCIsXHJcblx0XHRcImhlYWRlcnNcIjoge1xyXG5cdFx0XHRcIkNvbnRlbnQtTGVuZ3RoXCI6IDBcclxuXHRcdH1cclxuXHR9LCAocmVzKSA9PiB7XHJcblx0XHRpZiAocmVzLnN0YXR1c0NvZGUgIT0gMjAwKSB7XHJcblx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvcihcIkhUVFAgZXJyb3IgXCIgKyByZXMuc3RhdHVzQ29kZSkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHJlc3BvbnNlID0gJyc7XHJcblx0XHRyZXMub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcclxuXHRcdFx0cmVzcG9uc2UgKz0gY2h1bms7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXMub24oJ2VuZCcsICgpID0+IHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRyZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2UpLnJlc3BvbnNlO1xyXG5cdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhuZXcgRXJyb3IoXCJNYWxmb3JtZWQgcmVzcG9uc2VcIikpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5zZXJ2ZXJfdGltZSkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvcihcIk1hbGZvcm1lZCByZXNwb25zZVwiKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBlbmQgPSBEYXRlLm5vdygpO1xyXG5cdFx0XHRsZXQgb2Zmc2V0ID0gcmVzcG9uc2Uuc2VydmVyX3RpbWUgLSBleHBvcnRzLnRpbWUoKTtcclxuXHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIG9mZnNldCwgZW5kIC0gc3RhcnQpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdHJlcS5vbignZXJyb3InLCBjYWxsYmFjayk7XHJcblxyXG5cdHJlcS5lbmQoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBzdGFuZGFyZGl6ZWQgZGV2aWNlIElEIGJhc2VkIG9uIHlvdXIgU3RlYW1JRC5cclxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzdGVhbUlEIC0gWW91ciBTdGVhbUlELCBlaXRoZXIgYXMgYSBzdHJpbmcgb3IgYXMgYW4gb2JqZWN0IHdoaWNoIGhhcyBhIHRvU3RyaW5nKCkgbWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgU3RlYW1JRFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0cy5nZXREZXZpY2VJRCA9IGZ1bmN0aW9uKHN0ZWFtSUQpIHtcclxuXHRsZXQgc2FsdCA9IHByb2Nlc3MuZW52LlNURUFNX1RPVFBfU0FMVCB8fCAnJztcclxuXHRyZXR1cm4gXCJhbmRyb2lkOlwiICsgQ3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoc3RlYW1JRC50b1N0cmluZygpICsgc2FsdCkuZGlnZXN0KCdoZXgnKVxyXG5cdFx0XHQucmVwbGFjZSgvXihbMC05YS1mXXs4fSkoWzAtOWEtZl17NH0pKFswLTlhLWZdezR9KShbMC05YS1mXXs0fSkoWzAtOWEtZl17MTJ9KS4qJC8sICckMS0kMi0kMy0kNC0kNScpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYnVmZmVyaXplU2VjcmV0KHNlY3JldCkge1xyXG5cdGlmICh0eXBlb2Ygc2VjcmV0ID09PSAnc3RyaW5nJykge1xyXG5cdFx0Ly8gQ2hlY2sgaWYgaXQncyBoZXhcclxuXHRcdGlmIChzZWNyZXQubWF0Y2goL1swLTlhLWZdezQwfS9pKSkge1xyXG5cdFx0XHRyZXR1cm4gQnVmZmVyLmZyb20oc2VjcmV0LCAnaGV4Jyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBMb29rcyBsaWtlIGl0J3MgYmFzZTY0XHJcblx0XHRcdHJldHVybiBCdWZmZXIuZnJvbShzZWNyZXQsICdiYXNlNjQnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBzZWNyZXQ7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/steam-totp/index.js\n");

/***/ })

};
;