"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/kvparser";
exports.ids = ["vendor-chunks/kvparser"];
exports.modules = {

/***/ "(rsc)/./node_modules/kvparser/index.js":
/*!****************************************!*\
  !*** ./node_modules/kvparser/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst KvParser = __webpack_require__(/*! ./lib/KvParser.js */ \"(rsc)/./node_modules/kvparser/lib/KvParser.js\");\n\n/**\n * @param {string|Buffer} input\n * @return {object}\n */\nexports.parse = function(input) {\n\t// Support for environments where Buffer isn't defined\n\tif (typeof Buffer == 'function' && Buffer.isBuffer(input)) {\n\t\tinput = input.toString('utf8');\n\t}\n\n\tif (typeof input != 'string') {\n\t\tthrow new Error(`Unexpected type \"${typeof input}\" for parameter 'input'`);\n\t}\n\n\tlet parser = new KvParser(input);\n\treturn parser.parse();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMva3ZwYXJzZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsd0VBQW1COztBQUU1QztBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jczItc2tpbi10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2t2cGFyc2VyL2luZGV4LmpzP2I0ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IEt2UGFyc2VyID0gcmVxdWlyZSgnLi9saWIvS3ZQYXJzZXIuanMnKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGlucHV0XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihpbnB1dCkge1xuXHQvLyBTdXBwb3J0IGZvciBlbnZpcm9ubWVudHMgd2hlcmUgQnVmZmVyIGlzbid0IGRlZmluZWRcblx0aWYgKHR5cGVvZiBCdWZmZXIgPT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG5cdFx0aW5wdXQgPSBpbnB1dC50b1N0cmluZygndXRmOCcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBpbnB1dCAhPSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlIFwiJHt0eXBlb2YgaW5wdXR9XCIgZm9yIHBhcmFtZXRlciAnaW5wdXQnYCk7XG5cdH1cblxuXHRsZXQgcGFyc2VyID0gbmV3IEt2UGFyc2VyKGlucHV0KTtcblx0cmV0dXJuIHBhcnNlci5wYXJzZSgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/kvparser/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/kvparser/lib/KvParser.js":
/*!***********************************************!*\
  !*** ./node_modules/kvparser/lib/KvParser.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\n\nconst OPEN_BLOCK = Symbol('OpenBlock');\nconst CLOSE_BLOCK = Symbol('CloseBlock');\n\nconst ParseState = {\n\tExpectRootKey: 1,       // The next thing we read is expected to be a string containing the name of the root key.\n\tExpectRootValue: 2,     // The next thing we read is expected to be OpenBlock for the root.\n\tExpectKey: 3,           // The next thing we read is expected to be a string containing a key name, or CloseBlock\n\tExpectValue: 4          // The next thing we read is expected to be a string containing a value, or OpenBlock\n};\n\nclass KvParser {\n\t/**\n\t * @param {string} inputString\n\t */\n\tconstructor(inputString) {\n\t\tthis._input = inputString;\n\t\tthis._offset = 0;\n\t}\n\n\tparse() {\n\t\tlet state = ParseState.ExpectRootKey;\n\t\tlet parsedObject = {};\n\t\tlet parsePath = [];\n\n\t\t// The name of the key for which we're reading the value\n\t\tlet pendingKey = null;\n\n\t\tparseLoop:\n\t\twhile (true) {\n\t\t\tlet token = this.readToken();\n\n\t\t\tswitch (state) {\n\t\t\t\tcase ParseState.ExpectRootKey:\n\t\t\t\t\tif (typeof token != 'string') {\n\t\t\t\t\t\tthis.unexpectedToken(token, 'string');\n\t\t\t\t\t}\n\n\t\t\t\t\tpendingKey = token;\n\t\t\t\t\tstate = ParseState.ExpectRootValue;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ParseState.ExpectRootValue:\n\t\t\t\t\tif (token != OPEN_BLOCK) {\n\t\t\t\t\t\tthis.unexpectedToken(token, OPEN_BLOCK);\n\t\t\t\t\t}\n\n\t\t\t\t\tparsedObject[pendingKey] = {};\n\t\t\t\t\tparsePath.push(pendingKey);\n\t\t\t\t\tpendingKey = null;\n\t\t\t\t\tstate = ParseState.ExpectKey;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ParseState.ExpectKey:\n\t\t\t\t\tif (typeof token != 'string' && token != CLOSE_BLOCK) {\n\t\t\t\t\t\tthis.unexpectedToken(token, ['string', CLOSE_BLOCK]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof token == 'string') {\n\t\t\t\t\t\tpendingKey = token;\n\t\t\t\t\t\tstate = ParseState.ExpectValue;\n\t\t\t\t\t} else if (token == CLOSE_BLOCK) {\n\t\t\t\t\t\tparsePath.splice(parsePath.length - 1, 1);\n\t\t\t\t\t\tif (parsePath.length == 0) {\n\t\t\t\t\t\t\t// End of file\n\t\t\t\t\t\t\tbreak parseLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate = ParseState.ExpectKey;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ParseState.ExpectValue:\n\t\t\t\t\tif (typeof token != 'string' && token != OPEN_BLOCK) {\n\t\t\t\t\t\tthis.unexpectedToken(token, ['string', OPEN_BLOCK]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof token == 'string') {\n\t\t\t\t\t\tsetObjectPath(parsedObject, parsePath.concat([pendingKey]), token);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparsePath.push(pendingKey);\n\t\t\t\t\t\tsetObjectPath(parsedObject, parsePath, {});\n\t\t\t\t\t}\n\n\t\t\t\t\tpendingKey = null;\n\t\t\t\t\tstate = ParseState.ExpectKey;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Parser is in unexpected state: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\treturn parsedObject;\n\t}\n\n\treadToken() {\n\t\t// A token is one of the following:\n\t\t//   - An unquoted string with no whitespace\n\t\t//   - A quoted string\n\t\t//   - {\n\t\t//   - }\n\n\t\t// Skip any starting whitespace\n\t\tlet char;\n\t\twhile (isWhitespace(char = this.readChar())) {}\n\t\t\n\t\tthis.markTokenStart(-1);\n\t\t\n\t\t// Check if this is a { or }\n\t\tswitch (char) {\n\t\t\tcase '{':\n\t\t\t\treturn OPEN_BLOCK;\n\n\t\t\tcase '}':\n\t\t\t\treturn CLOSE_BLOCK;\n\t\t}\n\n\t\t// This token must be either a string or a comment. Is it a comment?\n\t\tif (char == '/' && this.previewNextChar() == '/') {\n\t\t\t// The rest of the line is a comment\n\t\t\twhile ((char = this.readChar()) != '\\n') {}\n\t\t\t// Got a newline. We can start token processing again.\n\t\t\treturn this.readToken();\n\t\t}\n\t\t\n\t\tthis.markTokenStart(-1);\n\n\t\t// This token is a string. Is it quoted?\n\t\tlet stringIsQuoted = char == '\"';\n\t\tlet nextCharIsEscaped = false;\n\t\tlet token = stringIsQuoted ? '' : char;\n\n\t\twhile (true) {\n\t\t\tchar = this.readChar();\n\n\t\t\t// Inside of a string token, we only care about 4 special cases:\n\t\t\t//   1. The character we read is part of the token as-is if the next char is escaped\n\t\t\t//   2. If the current char is a backslash, flag the next char as escaped\n\t\t\t//   3. If the string is quoted, a quote ends the token\n\t\t\t//   4. If the string is not quoted, whitespace ends the token\n\n\t\t\tif (nextCharIsEscaped) {\n\t\t\t\ttoken += char;\n\t\t\t\tnextCharIsEscaped = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (stringIsQuoted && char == '\\\\') {\n\t\t\t\tnextCharIsEscaped = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (stringIsQuoted && char == '\"') {\n\t\t\t\t// We done\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!stringIsQuoted && isWhitespace(char)) {\n\t\t\t\t// We done also\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Nothing special about this character.\n\t\t\ttoken += char;\n\t\t}\n\n\t\treturn token;\n\t}\n\n\t/**\n\t * Throws an Error because we received a token we didn't expect.\n\t *\n\t * @param {string|Symbol} token\n\t * @param {string|Symbol|array<string|Symbol>} [expected]\n\t */\n\tunexpectedToken(token, expected) {\n\t\tlet msg = `Unexpected token \"${tokenToString(token)}\"`;\n\t\tif (expected) {\n\t\t\texpected = Array.isArray(expected) ? expected : [expected];\n\t\t\tlet expectedStr = expected.map(tokenToString).join(' or ');\n\t\t\tmsg += `; expected ${expectedStr}`;\n\t\t}\n\n\t\tthis.throwTokenError(msg);\n\t}\n\t\n\tthrowTokenError(errorMessage) {\n\t\tlet lineNum = 1;\n\t\tlet colNum = 1;\n\t\t\n\t\tfor (let i = 0; i < this._lastTokenStart; i++) {\n\t\t\tcolNum++;\n\t\t\t\n\t\t\tlet char = this._input[i];\n\t\t\t\n\t\t\tif (char == '\\n') {\n\t\t\t\tlineNum++;\n\t\t\t\tcolNum = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlet err = new Error(`VDF Syntax Error: ${errorMessage} at line ${lineNum}, column ${colNum}`);\n\t\terr.line = lineNum;\n\t\terr.column = colNum;\n\t\t\n\t\tthrow err;\n\t}\n\t\n\tmarkTokenStart(offset) {\n\t\toffset = offset || 0;\n\t\tthis._lastTokenStart = this._offset + offset;\n\t}\n\n\t/**\n\t * Reads the next character from the input and advances the offset pointer.\n\t *\n\t * @return {string}\n\t */\n\treadChar() {\n\t\tif (this._offset >= this._input.length) {\n\t\t\tthrow new Error('Unexpected end of input');\n\t\t}\n\n\t\treturn this._input[this._offset++];\n\t}\n\n\t/**\n\t * Returns the next character from the input buffer without advancing the offset pointer.\n\t *\n\t * @return {string}\n\t */\n\tpreviewNextChar() {\n\t\tif (this._offset >= this._input.length) {\n\t\t\tthrow new Error('Unexpected end of input');\n\t\t}\n\n\t\treturn this._input[this._offset];\n\t}\n}\n\nfunction isWhitespace(char) {\n\treturn [' ', '\\t', '\\r', '\\n'].indexOf(char) != -1;\n}\n\nfunction setObjectPath(obj, path, value) {\n\tfor (let i = 0; i < path.length - 1; i++) {\n\t\tobj = obj[path[i]];\n\n\t\t// this should never happen\n\t\tif (typeof obj != 'object') {\n\t\t\tthrow new Error('Assertion failed: typeof obj == \\'object\\'');\n\t\t}\n\t}\n\n\tlet prop = path[path.length - 1];\n\tobj[prop] = value;\n}\n\nfunction tokenToString(token) {\n\tif (token == OPEN_BLOCK) {\n\t\treturn '{';\n\t}\n\n\tif (token == CLOSE_BLOCK) {\n\t\treturn '}';\n\t}\n\n\treturn token.toString();\n}\n\nmodule.exports = KvParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMva3ZwYXJzZXIvbGliL0t2UGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsTUFBTTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFVBQVU7QUFDVjs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVyxZQUFZO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjLFVBQVUsUUFBUSxXQUFXLE9BQU87QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jczItc2tpbi10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2t2cGFyc2VyL2xpYi9LdlBhcnNlci5qcz8yMzY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBPUEVOX0JMT0NLID0gU3ltYm9sKCdPcGVuQmxvY2snKTtcbmNvbnN0IENMT1NFX0JMT0NLID0gU3ltYm9sKCdDbG9zZUJsb2NrJyk7XG5cbmNvbnN0IFBhcnNlU3RhdGUgPSB7XG5cdEV4cGVjdFJvb3RLZXk6IDEsICAgICAgIC8vIFRoZSBuZXh0IHRoaW5nIHdlIHJlYWQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbmFtZSBvZiB0aGUgcm9vdCBrZXkuXG5cdEV4cGVjdFJvb3RWYWx1ZTogMiwgICAgIC8vIFRoZSBuZXh0IHRoaW5nIHdlIHJlYWQgaXMgZXhwZWN0ZWQgdG8gYmUgT3BlbkJsb2NrIGZvciB0aGUgcm9vdC5cblx0RXhwZWN0S2V5OiAzLCAgICAgICAgICAgLy8gVGhlIG5leHQgdGhpbmcgd2UgcmVhZCBpcyBleHBlY3RlZCB0byBiZSBhIHN0cmluZyBjb250YWluaW5nIGEga2V5IG5hbWUsIG9yIENsb3NlQmxvY2tcblx0RXhwZWN0VmFsdWU6IDQgICAgICAgICAgLy8gVGhlIG5leHQgdGhpbmcgd2UgcmVhZCBpcyBleHBlY3RlZCB0byBiZSBhIHN0cmluZyBjb250YWluaW5nIGEgdmFsdWUsIG9yIE9wZW5CbG9ja1xufTtcblxuY2xhc3MgS3ZQYXJzZXIge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlucHV0U3RyaW5nXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihpbnB1dFN0cmluZykge1xuXHRcdHRoaXMuX2lucHV0ID0gaW5wdXRTdHJpbmc7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gMDtcblx0fVxuXG5cdHBhcnNlKCkge1xuXHRcdGxldCBzdGF0ZSA9IFBhcnNlU3RhdGUuRXhwZWN0Um9vdEtleTtcblx0XHRsZXQgcGFyc2VkT2JqZWN0ID0ge307XG5cdFx0bGV0IHBhcnNlUGF0aCA9IFtdO1xuXG5cdFx0Ly8gVGhlIG5hbWUgb2YgdGhlIGtleSBmb3Igd2hpY2ggd2UncmUgcmVhZGluZyB0aGUgdmFsdWVcblx0XHRsZXQgcGVuZGluZ0tleSA9IG51bGw7XG5cblx0XHRwYXJzZUxvb3A6XG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGxldCB0b2tlbiA9IHRoaXMucmVhZFRva2VuKCk7XG5cblx0XHRcdHN3aXRjaCAoc3RhdGUpIHtcblx0XHRcdFx0Y2FzZSBQYXJzZVN0YXRlLkV4cGVjdFJvb3RLZXk6XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0b2tlbiAhPSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0dGhpcy51bmV4cGVjdGVkVG9rZW4odG9rZW4sICdzdHJpbmcnKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwZW5kaW5nS2V5ID0gdG9rZW47XG5cdFx0XHRcdFx0c3RhdGUgPSBQYXJzZVN0YXRlLkV4cGVjdFJvb3RWYWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFBhcnNlU3RhdGUuRXhwZWN0Um9vdFZhbHVlOlxuXHRcdFx0XHRcdGlmICh0b2tlbiAhPSBPUEVOX0JMT0NLKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgT1BFTl9CTE9DSyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cGFyc2VkT2JqZWN0W3BlbmRpbmdLZXldID0ge307XG5cdFx0XHRcdFx0cGFyc2VQYXRoLnB1c2gocGVuZGluZ0tleSk7XG5cdFx0XHRcdFx0cGVuZGluZ0tleSA9IG51bGw7XG5cdFx0XHRcdFx0c3RhdGUgPSBQYXJzZVN0YXRlLkV4cGVjdEtleTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFBhcnNlU3RhdGUuRXhwZWN0S2V5OlxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdG9rZW4gIT0gJ3N0cmluZycgJiYgdG9rZW4gIT0gQ0xPU0VfQkxPQ0spIHtcblx0XHRcdFx0XHRcdHRoaXMudW5leHBlY3RlZFRva2VuKHRva2VuLCBbJ3N0cmluZycsIENMT1NFX0JMT0NLXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0b2tlbiA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0cGVuZGluZ0tleSA9IHRva2VuO1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBQYXJzZVN0YXRlLkV4cGVjdFZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodG9rZW4gPT0gQ0xPU0VfQkxPQ0spIHtcblx0XHRcdFx0XHRcdHBhcnNlUGF0aC5zcGxpY2UocGFyc2VQYXRoLmxlbmd0aCAtIDEsIDEpO1xuXHRcdFx0XHRcdFx0aWYgKHBhcnNlUGF0aC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0XHQvLyBFbmQgb2YgZmlsZVxuXHRcdFx0XHRcdFx0XHRicmVhayBwYXJzZUxvb3A7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gUGFyc2VTdGF0ZS5FeHBlY3RLZXk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBQYXJzZVN0YXRlLkV4cGVjdFZhbHVlOlxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdG9rZW4gIT0gJ3N0cmluZycgJiYgdG9rZW4gIT0gT1BFTl9CTE9DSykge1xuXHRcdFx0XHRcdFx0dGhpcy51bmV4cGVjdGVkVG9rZW4odG9rZW4sIFsnc3RyaW5nJywgT1BFTl9CTE9DS10pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdG9rZW4gPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdHNldE9iamVjdFBhdGgocGFyc2VkT2JqZWN0LCBwYXJzZVBhdGguY29uY2F0KFtwZW5kaW5nS2V5XSksIHRva2VuKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cGFyc2VQYXRoLnB1c2gocGVuZGluZ0tleSk7XG5cdFx0XHRcdFx0XHRzZXRPYmplY3RQYXRoKHBhcnNlZE9iamVjdCwgcGFyc2VQYXRoLCB7fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cGVuZGluZ0tleSA9IG51bGw7XG5cdFx0XHRcdFx0c3RhdGUgPSBQYXJzZVN0YXRlLkV4cGVjdEtleTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgUGFyc2VyIGlzIGluIHVuZXhwZWN0ZWQgc3RhdGU6ICR7c3RhdGV9YCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnNlZE9iamVjdDtcblx0fVxuXG5cdHJlYWRUb2tlbigpIHtcblx0XHQvLyBBIHRva2VuIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuXHRcdC8vICAgLSBBbiB1bnF1b3RlZCBzdHJpbmcgd2l0aCBubyB3aGl0ZXNwYWNlXG5cdFx0Ly8gICAtIEEgcXVvdGVkIHN0cmluZ1xuXHRcdC8vICAgLSB7XG5cdFx0Ly8gICAtIH1cblxuXHRcdC8vIFNraXAgYW55IHN0YXJ0aW5nIHdoaXRlc3BhY2Vcblx0XHRsZXQgY2hhcjtcblx0XHR3aGlsZSAoaXNXaGl0ZXNwYWNlKGNoYXIgPSB0aGlzLnJlYWRDaGFyKCkpKSB7fVxuXHRcdFxuXHRcdHRoaXMubWFya1Rva2VuU3RhcnQoLTEpO1xuXHRcdFxuXHRcdC8vIENoZWNrIGlmIHRoaXMgaXMgYSB7IG9yIH1cblx0XHRzd2l0Y2ggKGNoYXIpIHtcblx0XHRcdGNhc2UgJ3snOlxuXHRcdFx0XHRyZXR1cm4gT1BFTl9CTE9DSztcblxuXHRcdFx0Y2FzZSAnfSc6XG5cdFx0XHRcdHJldHVybiBDTE9TRV9CTE9DSztcblx0XHR9XG5cblx0XHQvLyBUaGlzIHRva2VuIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgY29tbWVudC4gSXMgaXQgYSBjb21tZW50P1xuXHRcdGlmIChjaGFyID09ICcvJyAmJiB0aGlzLnByZXZpZXdOZXh0Q2hhcigpID09ICcvJykge1xuXHRcdFx0Ly8gVGhlIHJlc3Qgb2YgdGhlIGxpbmUgaXMgYSBjb21tZW50XG5cdFx0XHR3aGlsZSAoKGNoYXIgPSB0aGlzLnJlYWRDaGFyKCkpICE9ICdcXG4nKSB7fVxuXHRcdFx0Ly8gR290IGEgbmV3bGluZS4gV2UgY2FuIHN0YXJ0IHRva2VuIHByb2Nlc3NpbmcgYWdhaW4uXG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkVG9rZW4oKTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5tYXJrVG9rZW5TdGFydCgtMSk7XG5cblx0XHQvLyBUaGlzIHRva2VuIGlzIGEgc3RyaW5nLiBJcyBpdCBxdW90ZWQ/XG5cdFx0bGV0IHN0cmluZ0lzUXVvdGVkID0gY2hhciA9PSAnXCInO1xuXHRcdGxldCBuZXh0Q2hhcklzRXNjYXBlZCA9IGZhbHNlO1xuXHRcdGxldCB0b2tlbiA9IHN0cmluZ0lzUXVvdGVkID8gJycgOiBjaGFyO1xuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGNoYXIgPSB0aGlzLnJlYWRDaGFyKCk7XG5cblx0XHRcdC8vIEluc2lkZSBvZiBhIHN0cmluZyB0b2tlbiwgd2Ugb25seSBjYXJlIGFib3V0IDQgc3BlY2lhbCBjYXNlczpcblx0XHRcdC8vICAgMS4gVGhlIGNoYXJhY3RlciB3ZSByZWFkIGlzIHBhcnQgb2YgdGhlIHRva2VuIGFzLWlzIGlmIHRoZSBuZXh0IGNoYXIgaXMgZXNjYXBlZFxuXHRcdFx0Ly8gICAyLiBJZiB0aGUgY3VycmVudCBjaGFyIGlzIGEgYmFja3NsYXNoLCBmbGFnIHRoZSBuZXh0IGNoYXIgYXMgZXNjYXBlZFxuXHRcdFx0Ly8gICAzLiBJZiB0aGUgc3RyaW5nIGlzIHF1b3RlZCwgYSBxdW90ZSBlbmRzIHRoZSB0b2tlblxuXHRcdFx0Ly8gICA0LiBJZiB0aGUgc3RyaW5nIGlzIG5vdCBxdW90ZWQsIHdoaXRlc3BhY2UgZW5kcyB0aGUgdG9rZW5cblxuXHRcdFx0aWYgKG5leHRDaGFySXNFc2NhcGVkKSB7XG5cdFx0XHRcdHRva2VuICs9IGNoYXI7XG5cdFx0XHRcdG5leHRDaGFySXNFc2NhcGVkID0gZmFsc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3RyaW5nSXNRdW90ZWQgJiYgY2hhciA9PSAnXFxcXCcpIHtcblx0XHRcdFx0bmV4dENoYXJJc0VzY2FwZWQgPSB0cnVlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0cmluZ0lzUXVvdGVkICYmIGNoYXIgPT0gJ1wiJykge1xuXHRcdFx0XHQvLyBXZSBkb25lXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXN0cmluZ0lzUXVvdGVkICYmIGlzV2hpdGVzcGFjZShjaGFyKSkge1xuXHRcdFx0XHQvLyBXZSBkb25lIGFsc29cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vdGhpbmcgc3BlY2lhbCBhYm91dCB0aGlzIGNoYXJhY3Rlci5cblx0XHRcdHRva2VuICs9IGNoYXI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRva2VuO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRocm93cyBhbiBFcnJvciBiZWNhdXNlIHdlIHJlY2VpdmVkIGEgdG9rZW4gd2UgZGlkbid0IGV4cGVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd8U3ltYm9sfSB0b2tlblxuXHQgKiBAcGFyYW0ge3N0cmluZ3xTeW1ib2x8YXJyYXk8c3RyaW5nfFN5bWJvbD59IFtleHBlY3RlZF1cblx0ICovXG5cdHVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgZXhwZWN0ZWQpIHtcblx0XHRsZXQgbXNnID0gYFVuZXhwZWN0ZWQgdG9rZW4gXCIke3Rva2VuVG9TdHJpbmcodG9rZW4pfVwiYDtcblx0XHRpZiAoZXhwZWN0ZWQpIHtcblx0XHRcdGV4cGVjdGVkID0gQXJyYXkuaXNBcnJheShleHBlY3RlZCkgPyBleHBlY3RlZCA6IFtleHBlY3RlZF07XG5cdFx0XHRsZXQgZXhwZWN0ZWRTdHIgPSBleHBlY3RlZC5tYXAodG9rZW5Ub1N0cmluZykuam9pbignIG9yICcpO1xuXHRcdFx0bXNnICs9IGA7IGV4cGVjdGVkICR7ZXhwZWN0ZWRTdHJ9YDtcblx0XHR9XG5cblx0XHR0aGlzLnRocm93VG9rZW5FcnJvcihtc2cpO1xuXHR9XG5cdFxuXHR0aHJvd1Rva2VuRXJyb3IoZXJyb3JNZXNzYWdlKSB7XG5cdFx0bGV0IGxpbmVOdW0gPSAxO1xuXHRcdGxldCBjb2xOdW0gPSAxO1xuXHRcdFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGFzdFRva2VuU3RhcnQ7IGkrKykge1xuXHRcdFx0Y29sTnVtKys7XG5cdFx0XHRcblx0XHRcdGxldCBjaGFyID0gdGhpcy5faW5wdXRbaV07XG5cdFx0XHRcblx0XHRcdGlmIChjaGFyID09ICdcXG4nKSB7XG5cdFx0XHRcdGxpbmVOdW0rKztcblx0XHRcdFx0Y29sTnVtID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0bGV0IGVyciA9IG5ldyBFcnJvcihgVkRGIFN5bnRheCBFcnJvcjogJHtlcnJvck1lc3NhZ2V9IGF0IGxpbmUgJHtsaW5lTnVtfSwgY29sdW1uICR7Y29sTnVtfWApO1xuXHRcdGVyci5saW5lID0gbGluZU51bTtcblx0XHRlcnIuY29sdW1uID0gY29sTnVtO1xuXHRcdFxuXHRcdHRocm93IGVycjtcblx0fVxuXHRcblx0bWFya1Rva2VuU3RhcnQob2Zmc2V0KSB7XG5cdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0dGhpcy5fbGFzdFRva2VuU3RhcnQgPSB0aGlzLl9vZmZzZXQgKyBvZmZzZXQ7XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgdGhlIG5leHQgY2hhcmFjdGVyIGZyb20gdGhlIGlucHV0IGFuZCBhZHZhbmNlcyB0aGUgb2Zmc2V0IHBvaW50ZXIuXG5cdCAqXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHJlYWRDaGFyKCkge1xuXHRcdGlmICh0aGlzLl9vZmZzZXQgPj0gdGhpcy5faW5wdXQubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0W3RoaXMuX29mZnNldCsrXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBpbnB1dCBidWZmZXIgd2l0aG91dCBhZHZhbmNpbmcgdGhlIG9mZnNldCBwb2ludGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRwcmV2aWV3TmV4dENoYXIoKSB7XG5cdFx0aWYgKHRoaXMuX29mZnNldCA+PSB0aGlzLl9pbnB1dC5sZW5ndGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5faW5wdXRbdGhpcy5fb2Zmc2V0XTtcblx0fVxufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY2hhcikge1xuXHRyZXR1cm4gWycgJywgJ1xcdCcsICdcXHInLCAnXFxuJ10uaW5kZXhPZihjaGFyKSAhPSAtMTtcbn1cblxuZnVuY3Rpb24gc2V0T2JqZWN0UGF0aChvYmosIHBhdGgsIHZhbHVlKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcblx0XHRvYmogPSBvYmpbcGF0aFtpXV07XG5cblx0XHQvLyB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW5cblx0XHRpZiAodHlwZW9mIG9iaiAhPSAnb2JqZWN0Jykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkOiB0eXBlb2Ygb2JqID09IFxcJ29iamVjdFxcJycpO1xuXHRcdH1cblx0fVxuXG5cdGxldCBwcm9wID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXHRvYmpbcHJvcF0gPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdG9rZW5Ub1N0cmluZyh0b2tlbikge1xuXHRpZiAodG9rZW4gPT0gT1BFTl9CTE9DSykge1xuXHRcdHJldHVybiAneyc7XG5cdH1cblxuXHRpZiAodG9rZW4gPT0gQ0xPU0VfQkxPQ0spIHtcblx0XHRyZXR1cm4gJ30nO1xuXHR9XG5cblx0cmV0dXJuIHRva2VuLnRvU3RyaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS3ZQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/kvparser/lib/KvParser.js\n");

/***/ })

};
;