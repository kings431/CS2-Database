"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/smart-buffer";
exports.ids = ["vendor-chunks/smart-buffer"];
exports.modules = {

/***/ "(rsc)/./node_modules/smart-buffer/build/smartbuffer.js":
/*!********************************************************!*\
  !*** ./node_modules/smart-buffer/build/smartbuffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/smart-buffer/build/utils.js\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */\n    constructor(options) {\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n                // Check for initial Buffer\n            }\n            else if (options.buff) {\n                if (Buffer.isBuffer(options.buff)) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            }\n            else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        }\n        else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== 'undefined') {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */\n    static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */\n    static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return (castOptions &&\n            (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined));\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Inserts an Int8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigInt64BE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a Int64LE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt8(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Inserts an UInt8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n     *             the string (Defaults to instance level encoding).\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === 'number') {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        }\n        else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Inserts a String\n     *\n     * @param value { String } The String value to insert.\n     * @param offset { Number } The offset to insert the string at.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n     * Writes a String\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readStringNT(encoding) {\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n     * Inserts a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n        return this;\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */\n    readBuffer(length) {\n        if (typeof length !== 'undefined') {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === 'number' ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */\n    readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Inserts a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== 'undefined') {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */\n    clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n     * Gets the current read offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get readOffset() {\n        return this._readOffset;\n    }\n    /**\n     * Sets the read offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n     * Gets the current write offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n     * Sets the write offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n     * Gets the currently set string encoding of the SmartBuffer instance.\n     *\n     * @return { BufferEncoding } The string Buffer encoding currently set.\n     */\n    get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Sets the string encoding of the SmartBuffer instance.\n     *\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\n     */\n    set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n     *\n     * @return { Buffer } The Buffer value.\n     */\n    get internalBuffer() {\n        return this._buff;\n    }\n    /**\n     * Gets the value of the internal managed Buffer (Includes managed data only)\n     *\n     * @param { Buffer }\n     */\n    toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */\n    toString(encoding) {\n        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */\n    destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n     * Handles inserting and writing strings.\n     *\n     * @param value { String } The String value to insert.\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */\n    _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === 'number') {\n            offsetVal = arg3;\n            // Check for encoding\n        }\n        else if (typeof arg3 === 'string') {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === 'string') {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        }\n        else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n     * Handles writing or insert of a Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */\n    _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        }\n        else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to read data.\n     *\n     * @param length { Number } The length of the data that needs to be read.\n     * @param offset { Number } The offset of the data that needs to be read.\n     */\n    ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== 'undefined') {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to insert data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */\n    ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        }\n        else {\n            this.length += dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n     */\n    _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */\n    _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = (oldLength * 3) / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @typeparam T { number | bigint } The type of the value to be read\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n     *\n     * @returns { T } the number value\n     */\n    _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === 'undefined') {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n     * Inserts a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n        return this;\n    }\n    /**\n     * Writes a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === 'number') {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === 'number') {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        }\n        else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n        return this;\n    }\n}\nexports.SmartBuffer = SmartBuffer;\n//# sourceMappingURL=smartbuffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3NtYXJ0YnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5Qix5QkFBeUIsU0FBUztBQUNsQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQyx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHFCQUFxQixrQkFBa0I7QUFDdkMseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHFCQUFxQixrQkFBa0I7QUFDdkMseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQixxQkFBcUIsa0JBQWtCO0FBQ3ZDLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0IseUJBQXlCLFVBQVU7QUFDbkMscUJBQXFCLGtCQUFrQjtBQUN2Qyx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQSxxQkFBcUIscUNBQXFDO0FBQzFELHlCQUF5QixTQUFTO0FBQ2xDLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQSxxQkFBcUIsd0NBQXdDO0FBQzdELHlCQUF5QixTQUFTO0FBQ2xDLHNCQUFzQixJQUFJO0FBQzFCLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0EscUJBQXFCLHdDQUF3QztBQUM3RCx5QkFBeUIsU0FBUztBQUNsQyxzQkFBc0IsSUFBSTtBQUMxQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NzMi1za2luLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3NtYXJ0YnVmZmVyLmpzPzhmYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vLyBUaGUgZGVmYXVsdCBCdWZmZXIgc2l6ZSBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuY29uc3QgREVGQVVMVF9TTUFSVEJVRkZFUl9TSVpFID0gNDA5Njtcbi8vIFRoZSBkZWZhdWx0IHN0cmluZyBlbmNvZGluZyB0byB1c2UgZm9yIHJlYWRpbmcvd3JpdGluZyBzdHJpbmdzLlxuY29uc3QgREVGQVVMVF9TTUFSVEJVRkZFUl9FTkNPRElORyA9ICd1dGY4JztcbmNsYXNzIFNtYXJ0QnVmZmVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgeyBTbWFydEJ1ZmZlck9wdGlvbnMgfSBUaGUgU21hcnRCdWZmZXJPcHRpb25zIHRvIGFwcGx5IHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gREVGQVVMVF9TTUFSVEJVRkZFUl9FTkNPRElORztcbiAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKFNtYXJ0QnVmZmVyLmlzU21hcnRCdWZmZXJPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgZm9yIGVuY29kaW5nXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhvcHRpb25zLmVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVja3MgZm9yIGluaXRpYWwgc2l6ZSBsZW5ndGhcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfMS5pc0Zpbml0ZUludGVnZXIob3B0aW9ucy5zaXplKSAmJiBvcHRpb25zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUob3B0aW9ucy5zaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkVSUk9SUy5JTlZBTElEX1NNQVJUQlVGRkVSX1NJWkUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgaW5pdGlhbCBCdWZmZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYnVmZikge1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5idWZmKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmID0gb3B0aW9ucy5idWZmO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG9wdGlvbnMuYnVmZi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9TTUFSVEJVRkZFUl9CVUZGRVIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoREVGQVVMVF9TTUFSVEJVRkZFUl9TSVpFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgcGFzc2VkIGJ1dCBpdCdzIG5vdCBhIFNtYXJ0QnVmZmVyT3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9TTUFSVEJVRkZFUl9PQkpFQ1QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGRlZmF1bHQgdG8gc2FuZSBvcHRpb25zXG4gICAgICAgICAgICB0aGlzLl9idWZmID0gQnVmZmVyLmFsbG9jVW5zYWZlKERFRkFVTFRfU01BUlRCVUZGRVJfU0laRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTbWFydEJ1ZmZlciBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBpbnRlcm5hbCBCdWZmZXIgc2l6ZSBhbmQgb3B0aW9uYWwgZW5jb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2l6ZSB7IE51bWJlciB9IFRoZSBzaXplIG9mIHRoZSBpbnRlcm5hbCBCdWZmZXIuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBTbWFydEJ1ZmZlciB9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21TaXplKHNpemUsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIEJ1ZmZlciBhbmQgb3B0aW9uYWwgZW5jb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmZmVyIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB1c2UgYXMgdGhlIGludGVybmFsIEJ1ZmZlciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IFNtYXJ0QnVmZmVyIH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmLCBlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoe1xuICAgICAgICAgICAgYnVmZjogYnVmZixcbiAgICAgICAgICAgIGVuY29kaW5nOiBlbmNvZGluZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTbWFydEJ1ZmZlciBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBTbWFydEJ1ZmZlck9wdGlvbnMgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHsgU21hcnRCdWZmZXJPcHRpb25zIH0gVGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY3JlYXRpbmcgdGhlIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHlwZSBjaGVja2luZyBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgaWYgYW4gb2JqZWN0IGlzIGEgU21hcnRCdWZmZXJPcHRpb25zIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTbWFydEJ1ZmZlck9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYXN0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiAoY2FzdE9wdGlvbnMgJiZcbiAgICAgICAgICAgIChjYXN0T3B0aW9ucy5lbmNvZGluZyAhPT0gdW5kZWZpbmVkIHx8IGNhc3RPcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCB8fCBjYXN0T3B0aW9ucy5idWZmICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG4gICAgLy8gU2lnbmVkIGludGVnZXJzXG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50OCB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCwgMSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50MTZCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDE2QkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSwgMiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50MTZMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDE2TEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSwgMiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50MzJCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDMyQkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50MzJMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDMyTEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBCaWdJbnQ2NEJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgQmlnSW50IH1cbiAgICAgKi9cbiAgICByZWFkQmlnSW50NjRCRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQmlnSW50NjRMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IEJpZ0ludCB9XG4gICAgICovXG4gICAgcmVhZEJpZ0ludDY0TEUob2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygncmVhZEJpZ0ludDY0TEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFLCA4LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gSW50OCB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUludDgodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4LCAxLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gSW50OCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0SW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCwgMSwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQxNkJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50MTZCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQxNkJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIEludDE2TEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVJbnQxNkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIEludDE2TEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gSW50MzJCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUludDMyQkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gSW50MzJCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0SW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQzMkxFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50MzJMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQzMkxFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQmlnSW50NjRCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJpZ0ludDY0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBCaWdJbnQ2NEJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCaWdJbnQgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCaWdJbnQ2NEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ0ludDY0QkUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQmlnSW50NjRMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJpZ0ludDY0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBJbnQ2NExFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCaWdJbnQgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCaWdJbnQ2NExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ0ludDY0TEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gVW5zaWduZWQgSW50ZWdlcnNcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50OCB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQ4KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4LCAxLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50MTZCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQxNkJFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50MTZMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQxNkxFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50MzJCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQzMkJFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50MzJMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQzMkxFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIEJpZ1VJbnQ2NEJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgQmlnSW50IH1cbiAgICAgKi9cbiAgICByZWFkQmlnVUludDY0QkUob2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygncmVhZEJpZ1VJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQmlnVUludDY0TEUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBCaWdJbnQgfVxuICAgICAqL1xuICAgIHJlYWRCaWdVSW50NjRMRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnVUludDY0TEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIFVJbnQ4IHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlVUludDgodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDgsIDEsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIFVJbnQ4IHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRVSW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDgsIDEsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDE2QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50MTZCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDE2QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBVSW50MTZMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVVJbnQxNkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBVSW50MTZMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0VUludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIFVJbnQzMkJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlVUludDMyQkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIFVJbnQzMkJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDMyTEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50MzJMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDMyTEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIEJpZ1VJbnQ2NEJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQmlnVUludDY0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnVUludDY0QkUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIEJpZ1VJbnQ2NEJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCaWdVSW50NjRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdVSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQmlnVUludDY0TEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCaWdVSW50NjRMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdVSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgQmlnVUludDY0TEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ1VJbnQ2NExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ1VJbnQ2NExFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvLyBGbG9hdGluZyBQb2ludFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIEZsb2F0QkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWRGbG9hdEJFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIEZsb2F0TEUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWRGbG9hdExFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIEZsb2F0QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgRmxvYXRCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RmxvYXRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIEZsb2F0TEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgRmxvYXRMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RmxvYXRMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8vIERvdWJsZSBGbG9hdGluZyBQb2ludFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIERvdWJsRUJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkRG91YmxlQkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIERvdWJsZUxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkRG91YmxlTEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIERvdWJsZUJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgRG91YmxlQkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydERvdWJsZUJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIERvdWJsZUxFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgRG91YmxlTEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydERvdWJsZUxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8vIFN0cmluZ3NcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIFN0cmluZyBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnMSB7IE51bWJlciB8IFN0cmluZyB9IFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZCBhcyBhIFN0cmluZywgb3IgdGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3JcbiAgICAgKiAgICAgICAgICAgICB0aGUgc3RyaW5nIChEZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3IgdGhlIHN0cmluZyAoRGVmYXVsdHMgdG8gaW5zdGFuY2UgbGV2ZWwgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IFN0cmluZyB9XG4gICAgICovXG4gICAgcmVhZFN0cmluZyhhcmcxLCBlbmNvZGluZykge1xuICAgICAgICBsZXQgbGVuZ3RoVmFsO1xuICAgICAgICAvLyBMZW5ndGggcHJvdmlkZWRcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja0xlbmd0aFZhbHVlKGFyZzEpO1xuICAgICAgICAgICAgbGVuZ3RoVmFsID0gTWF0aC5taW4oYXJnMSwgdGhpcy5sZW5ndGggLSB0aGlzLl9yZWFkT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gYXJnMTtcbiAgICAgICAgICAgIGxlbmd0aFZhbCA9IHRoaXMubGVuZ3RoIC0gdGhpcy5fcmVhZE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBlbmNvZGluZ1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgdGhpcy5fcmVhZE9mZnNldCArIGxlbmd0aFZhbCkudG9TdHJpbmcoZW5jb2RpbmcgfHwgdGhpcy5fZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ICs9IGxlbmd0aFZhbDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBTdHJpbmcgfSBUaGUgU3RyaW5nIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHN0cmluZyBhdC5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB3cml0aW5nIHN0cmluZ3MgKGRlZmF1bHRzIHRvIGluc3RhbmNlIGVuY29kaW5nKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFN0cmluZyh2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVN0cmluZyh2YWx1ZSwgdHJ1ZSwgb2Zmc2V0LCBlbmNvZGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIFN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgU3RyaW5nIH0gVGhlIFN0cmluZyB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gYXJnMiB7IE51bWJlciB8IFN0cmluZyB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHN0cmluZyBhdCwgb3IgdGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB3cml0aW5nIHN0cmluZ3MgKGRlZmF1bHRzIHRvIGluc3RhbmNlIGVuY29kaW5nKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlU3RyaW5nKHZhbHVlLCBhcmcyLCBlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU3RyaW5nKHZhbHVlLCBmYWxzZSwgYXJnMiwgZW5jb2RpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIG51bGwtdGVybWluYXRlZCBTdHJpbmcgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3IgdGhlIHN0cmluZyAoRGVmYXVsdHMgdG8gaW5zdGFuY2UgbGV2ZWwgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IFN0cmluZyB9XG4gICAgICovXG4gICAgcmVhZFN0cmluZ05UKGVuY29kaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBudWxsIGNoYXJhY3RlciBwb3NpdGlvbiB0byB0aGUgZW5kIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAgICBsZXQgbnVsbFBvcyA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBGaW5kIG5leHQgbnVsbCBjaGFyYWN0ZXIgKGlmIG9uZSBpcyBub3QgZm91bmQsIGRlZmF1bHQgZnJvbSBhYm92ZSBpcyB1c2VkKVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcmVhZE9mZnNldDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9idWZmW2ldID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgbnVsbFBvcyA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVhZCBzdHJpbmcgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9idWZmLnNsaWNlKHRoaXMuX3JlYWRPZmZzZXQsIG51bGxQb3MpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHJlYWQgb2Zmc2V0XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSBudWxsUG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKGVuY29kaW5nIHx8IHRoaXMuX2VuY29kaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIG51bGwtdGVybWluYXRlZCBTdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBTdHJpbmcgfSBUaGUgU3RyaW5nIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgc3RyaW5nIHRvLCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0U3RyaW5nTlQodmFsdWUsIG9mZnNldCwgZW5jb2RpbmcpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIC8vIFdyaXRlIFZhbHVlc1xuICAgICAgICB0aGlzLmluc2VydFN0cmluZyh2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0VUludDgoMHgwMCwgb2Zmc2V0ICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIG51bGwtdGVybWluYXRlZCBTdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBTdHJpbmcgfSBUaGUgU3RyaW5nIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgc3RyaW5nIHRvLCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVTdHJpbmdOVCh2YWx1ZSwgYXJnMiwgZW5jb2RpbmcpIHtcbiAgICAgICAgLy8gV3JpdGUgVmFsdWVzXG4gICAgICAgIHRoaXMud3JpdGVTdHJpbmcodmFsdWUsIGFyZzIsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy53cml0ZVVJbnQ4KDB4MDAsIHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJyA/IGFyZzIgKyB2YWx1ZS5sZW5ndGggOiB0aGlzLndyaXRlT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEJ1ZmZlcnNcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIEJ1ZmZlciBmcm9tIHRoZSBpbnRlcm5hbCByZWFkIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlbmd0aCB7IE51bWJlciB9IFRoZSBsZW5ndGggb2YgZGF0YSB0byByZWFkIGFzIGEgQnVmZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IEJ1ZmZlciB9XG4gICAgICovXG4gICAgcmVhZEJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrTGVuZ3RoVmFsdWUobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGhWYWwgPSB0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyA/IGxlbmd0aCA6IHRoaXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBlbmRQb2ludCA9IE1hdGgubWluKHRoaXMubGVuZ3RoLCB0aGlzLl9yZWFkT2Zmc2V0ICsgbGVuZ3RoVmFsKTtcbiAgICAgICAgLy8gUmVhZCBidWZmZXIgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9idWZmLnNsaWNlKHRoaXMuX3JlYWRPZmZzZXQsIGVuZFBvaW50KTtcbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIEJ1ZmZlciByZWFkIG9mZnNldFxuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gZW5kUG9pbnQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQnVmZmVyIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0QnVmZmVyKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVCdWZmZXIodmFsdWUsIHRydWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIEJ1ZmZlciB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJ1ZmZlciB9IFRoZSBCdWZmZXIgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIEJ1ZmZlciB0by5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQnVmZmVyKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJ1ZmZlcih2YWx1ZSwgZmFsc2UsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbnVsbC10ZXJtaW5hdGVkIEJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9pc2l0b24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyIH1cbiAgICAgKi9cbiAgICByZWFkQnVmZmVyTlQoKSB7XG4gICAgICAgIC8vIFNldCBudWxsIGNoYXJhY3RlciBwb3NpdGlvbiB0byB0aGUgZW5kIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAgICBsZXQgbnVsbFBvcyA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBGaW5kIG5leHQgbnVsbCBjaGFyYWN0ZXIgKGlmIG9uZSBpcyBub3QgZm91bmQsIGRlZmF1bHQgZnJvbSBhYm92ZSBpcyB1c2VkKVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcmVhZE9mZnNldDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9idWZmW2ldID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgbnVsbFBvcyA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVhZCB2YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgbnVsbFBvcyk7XG4gICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBCdWZmZXIgcmVhZCBvZmZzZXRcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IG51bGxQb3MgKyAxO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBudWxsLXRlcm1pbmF0ZWQgQnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0QnVmZmVyTlQodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gV3JpdGUgVmFsdWVzXG4gICAgICAgIHRoaXMuaW5zZXJ0QnVmZmVyKHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLmluc2VydFVJbnQ4KDB4MDAsIG9mZnNldCArIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBudWxsLXRlcm1pbmF0ZWQgQnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCdWZmZXJOVCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIENoZWNrcyBmb3IgdmFsaWQgbnVtYmVyaWMgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgVmFsdWVzXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIodmFsdWUsIG9mZnNldCk7XG4gICAgICAgIHRoaXMud3JpdGVVSW50OCgweDAwLCB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldCArIHZhbHVlLmxlbmd0aCA6IHRoaXMuX3dyaXRlT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UgdG8gaXRzIG9yaWdpbmFsIGVtcHR5IHN0YXRlLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl93cml0ZU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZW1haW5pbmcgZGF0YSBsZWZ0IHRvIGJlIHJlYWQgZnJvbSB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZW1haW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIHRoaXMuX3JlYWRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgcmVhZCBvZmZzZXQgdmFsdWUgb2YgdGhlIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgZ2V0IHJlYWRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkT2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZWFkIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gLSBUaGUgb2Zmc2V0IHZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXQgcmVhZE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIC8vIENoZWNrIGZvciBib3VuZHMuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tUYXJnZXRPZmZzZXQob2Zmc2V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB3cml0ZSBvZmZzZXQgdmFsdWUgb2YgdGhlIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgZ2V0IHdyaXRlT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHdyaXRlIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gLSBUaGUgb2Zmc2V0IHZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXQgd3JpdGVPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICAvLyBDaGVjayBmb3IgYm91bmRzLlxuICAgICAgICB1dGlsc18xLmNoZWNrVGFyZ2V0T2Zmc2V0KG9mZnNldCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgc2V0IHN0cmluZyBlbmNvZGluZyBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyRW5jb2RpbmcgfSBUaGUgc3RyaW5nIEJ1ZmZlciBlbmNvZGluZyBjdXJyZW50bHkgc2V0LlxuICAgICAqL1xuICAgIGdldCBlbmNvZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJpbmcgZW5jb2Rpbmcgb2YgdGhlIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgQnVmZmVyRW5jb2RpbmcgfSBUaGUgc3RyaW5nIEJ1ZmZlciBlbmNvZGluZyB0byBzZXQuXG4gICAgICovXG4gICAgc2V0IGVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHVuZGVybHlpbmcgaW50ZXJuYWwgQnVmZmVyLiAoVGhpcyBpbmNsdWRlcyB1bm1hbmFnZWQgZGF0YSBpbiB0aGUgQnVmZmVyKVxuICAgICAqXG4gICAgICogQHJldHVybiB7IEJ1ZmZlciB9IFRoZSBCdWZmZXIgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IGludGVybmFsQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIGludGVybmFsIG1hbmFnZWQgQnVmZmVyIChJbmNsdWRlcyBtYW5hZ2VkIGRhdGEgb25seSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IEJ1ZmZlciB9XG4gICAgICovXG4gICAgdG9CdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgU3RyaW5nIHZhbHVlIG9mIHRoZSBpbnRlcm5hbCBtYW5hZ2VkIEJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIGRpc3BsYXkgdGhlIEJ1ZmZlciBhcyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgbGV2ZWwgZW5jb2RpbmcpLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nVmFsID0gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyA/IGVuY29kaW5nIDogdGhpcy5fZW5jb2Rpbmc7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIGVuY29kaW5nLlxuICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoZW5jb2RpbmdWYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZi50b1N0cmluZyhlbmNvZGluZ1ZhbCwgMCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBpbnNlcnRpbmcgYW5kIHdyaXRpbmcgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBpc0luc2VydCB7IEJvb2xlYW4gfSBUcnVlIGlmIGluc2VydGluZyBhIHN0cmluZywgZmFsc2UgaWYgd3JpdGluZy5cbiAgICAgKiBAcGFyYW0gYXJnMiB7IE51bWJlciB8IFN0cmluZyB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSBzdHJpbmcgYXQsIG9yIHRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igd3JpdGluZyBzdHJpbmdzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBlbmNvZGluZykuXG4gICAgICovXG4gICAgX2hhbmRsZVN0cmluZyh2YWx1ZSwgaXNJbnNlcnQsIGFyZzMsIGVuY29kaW5nKSB7XG4gICAgICAgIGxldCBvZmZzZXRWYWwgPSB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgbGV0IGVuY29kaW5nVmFsID0gdGhpcy5fZW5jb2Rpbmc7XG4gICAgICAgIC8vIENoZWNrIGZvciBvZmZzZXRcbiAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb2Zmc2V0VmFsID0gYXJnMztcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBlbmNvZGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmczID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKGFyZzMpO1xuICAgICAgICAgICAgZW5jb2RpbmdWYWwgPSBhcmczO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBlbmNvZGluZyAodGhpcmQgcGFyYW0pXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICAgICAgZW5jb2RpbmdWYWwgPSBlbmNvZGluZztcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgYnl0ZWxlbmd0aCBvZiBzdHJpbmcuXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmdWYWwpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgZW5vdWdoIGludGVybmFsIEJ1ZmZlciBjYXBhY2l0eS5cbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUluc2VydGFibGUoYnl0ZUxlbmd0aCwgb2Zmc2V0VmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZVdyaXRlYWJsZShieXRlTGVuZ3RoLCBvZmZzZXRWYWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIHZhbHVlXG4gICAgICAgIHRoaXMuX2J1ZmYud3JpdGUodmFsdWUsIG9mZnNldFZhbCwgYnl0ZUxlbmd0aCwgZW5jb2RpbmdWYWwpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHdyaXRlIG9mZnNldDtcbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBnaXZlbiwgY2hlY2sgdG8gc2VlIGlmIHdlIHdyb3RlIGJleW9uZCB0aGUgY3VycmVudCB3cml0ZU9mZnNldC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMuX3dyaXRlT2Zmc2V0LCBvZmZzZXRWYWwgKyBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIG9mZnNldCB3YXMgZ2l2ZW4sIHdlIHdyb3RlIHRvIHRoZSBlbmQgb2YgdGhlIFNtYXJ0QnVmZmVyIHNvIGluY3JlbWVudCB3cml0ZU9mZnNldC5cbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdyaXRpbmcgb3IgaW5zZXJ0IG9mIGEgQnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqL1xuICAgIF9oYW5kbGVCdWZmZXIodmFsdWUsIGlzSW5zZXJ0LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VmFsID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuXG4gICAgICAgIGlmIChpc0luc2VydCkge1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVJbnNlcnRhYmxlKHZhbHVlLmxlbmd0aCwgb2Zmc2V0VmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZVdyaXRlYWJsZSh2YWx1ZS5sZW5ndGgsIG9mZnNldFZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgYnVmZmVyIHZhbHVlXG4gICAgICAgIHZhbHVlLmNvcHkodGhpcy5fYnVmZiwgb2Zmc2V0VmFsKTtcbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIEJ1ZmZlciB3cml0ZSBvZmZzZXQ7XG4gICAgICAgIGlmIChpc0luc2VydCkge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBnaXZlbiwgY2hlY2sgdG8gc2VlIGlmIHdlIHdyb3RlIGJleW9uZCB0aGUgY3VycmVudCB3cml0ZU9mZnNldC5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5fd3JpdGVPZmZzZXQsIG9mZnNldFZhbCArIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBvZmZzZXQgd2FzIGdpdmVuLCB3ZSB3cm90ZSB0byB0aGUgZW5kIG9mIHRoZSBTbWFydEJ1ZmZlciBzbyBpbmNyZW1lbnQgd3JpdGVPZmZzZXQuXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGludGVybmFsIEJ1ZmZlciBpcyBsYXJnZSBlbm91Z2ggdG8gcmVhZCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlbmd0aCB7IE51bWJlciB9IFRoZSBsZW5ndGggb2YgdGhlIGRhdGEgdGhhdCBuZWVkcyB0byBiZSByZWFkLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IG9mIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgcmVhZC5cbiAgICAgKi9cbiAgICBlbnN1cmVSZWFkYWJsZShsZW5ndGgsIG9mZnNldCkge1xuICAgICAgICAvLyBPZmZzZXQgdmFsdWUgZGVmYXVsdHMgdG8gbWFuYWdlZCByZWFkIG9mZnNldC5cbiAgICAgICAgbGV0IG9mZnNldFZhbCA9IHRoaXMuX3JlYWRPZmZzZXQ7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgcHJvdmlkZWQsIHVzZSBpdC5cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgZm9yIHZhbGlkIG51bWJlcmljIHZhbHVlO1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgICAgICAvLyBPdmVyaWRlIHdpdGggY3VzdG9tIG9mZnNldC5cbiAgICAgICAgICAgIG9mZnNldFZhbCA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVja3MgaWYgb2Zmc2V0IGlzIGJlbG93IHplcm8sIG9yIHRoZSBvZmZzZXQrbGVuZ3RoIG9mZnNldCBpcyBiZXlvbmQgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgbWFuYWdlZCBkYXRhLlxuICAgICAgICBpZiAob2Zmc2V0VmFsIDwgMCB8fCBvZmZzZXRWYWwgKyBsZW5ndGggPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuRVJST1JTLklOVkFMSURfUkVBRF9CRVlPTkRfQk9VTkRTKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGludGVybmFsIEJ1ZmZlciBpcyBsYXJnZSBlbm91Z2ggdG8gaW5zZXJ0IGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YUxlbmd0aCB7IE51bWJlciB9IFRoZSBsZW5ndGggb2YgdGhlIGRhdGEgdGhhdCBuZWVkcyB0byBiZSB3cml0dGVuLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IG9mIHRoZSBkYXRhIHRvIGJlIHdyaXR0ZW4uXG4gICAgICovXG4gICAgZW5zdXJlSW5zZXJ0YWJsZShkYXRhTGVuZ3RoLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gQ2hlY2tzIGZvciB2YWxpZCBudW1iZXJpYyB2YWx1ZTtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBlbm91Z2ggaW50ZXJuYWwgQnVmZmVyIGNhcGFjaXR5LlxuICAgICAgICB0aGlzLl9lbnN1cmVDYXBhY2l0eSh0aGlzLmxlbmd0aCArIGRhdGFMZW5ndGgpO1xuICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIHByb3ZpZGVkIGFuZCBpdHMgbm90IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgYnVmZmVyLCBjb3B5IGRhdGEgaW50byBhcHByb3ByaWF0ZSBsb2NhdGlvbiBpbiByZWdhcmRzIHRvIHRoZSBvZmZzZXQuXG4gICAgICAgIGlmIChvZmZzZXQgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZi5jb3B5KHRoaXMuX2J1ZmYsIG9mZnNldCArIGRhdGFMZW5ndGgsIG9mZnNldCwgdGhpcy5fYnVmZi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkanVzdCB0cmFja2VkIHNtYXJ0IGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgaWYgKG9mZnNldCArIGRhdGFMZW5ndGggPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvZmZzZXQgKyBkYXRhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YUxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGludGVybmFsIEJ1ZmZlciBpcyBsYXJnZSBlbm91Z2ggdG8gd3JpdGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhTGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiB0aGUgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHdyaXR0ZW4uXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgb2YgdGhlIGRhdGEgdG8gYmUgd3JpdHRlbiAoZGVmYXVsdHMgdG8gd3JpdGVPZmZzZXQpLlxuICAgICAqL1xuICAgIF9lbnN1cmVXcml0ZWFibGUoZGF0YUxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFZhbCA9IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdGhpcy5fd3JpdGVPZmZzZXQ7XG4gICAgICAgIC8vIEVuc3VyZSBlbm91Z2ggY2FwYWNpdHkgdG8gd3JpdGUgZGF0YS5cbiAgICAgICAgdGhpcy5fZW5zdXJlQ2FwYWNpdHkob2Zmc2V0VmFsICsgZGF0YUxlbmd0aCk7XG4gICAgICAgIC8vIEFkanVzdCBTbWFydEJ1ZmZlciBsZW5ndGggKGlmIG9mZnNldCArIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiBtYW5hZ2VkIGxlbmd0aCwgYWRqdXN0IGxlbmd0aClcbiAgICAgICAgaWYgKG9mZnNldFZhbCArIGRhdGFMZW5ndGggPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvZmZzZXRWYWwgKyBkYXRhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byB3cml0ZSBhdCBsZWFzdCB0aGUgZ2l2ZW4gYW1vdW50IG9mIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWluTGVuZ3RoIHsgTnVtYmVyIH0gVGhlIG1pbmltdW0gbGVuZ3RoIG9mIHRoZSBkYXRhIG5lZWRzIHRvIGJlIHdyaXR0ZW4uXG4gICAgICovXG4gICAgX2Vuc3VyZUNhcGFjaXR5KG1pbkxlbmd0aCkge1xuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSB0aGlzLl9idWZmLmxlbmd0aDtcbiAgICAgICAgaWYgKG1pbkxlbmd0aCA+IG9sZExlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9idWZmO1xuICAgICAgICAgICAgbGV0IG5ld0xlbmd0aCA9IChvbGRMZW5ndGggKiAzKSAvIDIgKyAxO1xuICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5ld0xlbmd0aCA9IG1pbkxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmV3TGVuZ3RoKTtcbiAgICAgICAgICAgIGRhdGEuY29weSh0aGlzLl9idWZmLCAwLCAwLCBvbGRMZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbnVtZXJpYyBudW1iZXIgdmFsdWUgdXNpbmcgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGVwYXJhbSBUIHsgbnVtYmVyIHwgYmlnaW50IH0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGJlIHJlYWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmdW5jIHsgRnVuY3Rpb24ob2Zmc2V0OiBudW1iZXIpID0+IG51bWJlciB9IFRoZSBmdW5jdGlvbiB0byByZWFkIGRhdGEgb24gdGhlIGludGVybmFsIEJ1ZmZlciB3aXRoLlxuICAgICAqIEBwYXJhbSBieXRlU2l6ZSB7IE51bWJlciB9IFRoZSBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGZyb20gKG9wdGlvbmFsKS4gV2hlbiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgdGhlIG1hbmFnZWQgcmVhZE9mZnNldCBpcyB1c2VkIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7IFQgfSB0aGUgbnVtYmVyIHZhbHVlXG4gICAgICovXG4gICAgX3JlYWROdW1iZXJWYWx1ZShmdW5jLCBieXRlU2l6ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGFibGUoYnl0ZVNpemUsIG9mZnNldCk7XG4gICAgICAgIC8vIENhbGwgQnVmZmVyLnJlYWRYWFhYKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZnVuYy5jYWxsKHRoaXMuX2J1ZmYsIHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdGhpcy5fcmVhZE9mZnNldCk7XG4gICAgICAgIC8vIEFkanVzdCBpbnRlcm5hbCByZWFkIG9mZnNldCBpZiBhbiBvcHRpb25hbCByZWFkIG9mZnNldCB3YXMgbm90IHByb3ZpZGVkLlxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgKz0gYnl0ZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbnVtZXJpYyBudW1iZXIgdmFsdWUgYmFzZWQgb24gdGhlIGdpdmVuIG9mZnNldCBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAdHlwZXBhcmFtIFQgeyBudW1iZXIgfCBiaWdpbnQgfSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYmUgd3JpdHRlblxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmMgeyBGdW5jdGlvbihvZmZzZXQ6IFQsIG9mZnNldD8pID0+IG51bWJlcn0gVGhlIGZ1bmN0aW9uIHRvIHdyaXRlIGRhdGEgb24gdGhlIGludGVybmFsIEJ1ZmZlciB3aXRoLlxuICAgICAqIEBwYXJhbSBieXRlU2l6ZSB7IE51bWJlciB9IFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBUIH0gVGhlIG51bWJlciB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gdGhlIG9mZnNldCB0byB3cml0ZSB0aGUgbnVtYmVyIGF0IChSRVFVSVJFRCkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTbWFydEJ1ZmZlciB0aGlzIGJ1ZmZlclxuICAgICAqL1xuICAgIF9pbnNlcnROdW1iZXJWYWx1ZShmdW5jLCBieXRlU2l6ZSwgdmFsdWUsIG9mZnNldCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgaW52YWxpZCBvZmZzZXQgdmFsdWVzLlxuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuIChyYXcgb2Zmc2V0IGlzIHBhc3NlZClcbiAgICAgICAgdGhpcy5lbnN1cmVJbnNlcnRhYmxlKGJ5dGVTaXplLCBvZmZzZXQpO1xuICAgICAgICAvLyBDYWxsIGJ1ZmZlci53cml0ZVhYWFgoKTtcbiAgICAgICAgZnVuYy5jYWxsKHRoaXMuX2J1ZmYsIHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICAvLyBBZGp1c3RzIGludGVybmFsbHkgbWFuYWdlZCB3cml0ZSBvZmZzZXQuXG4gICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ICs9IGJ5dGVTaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgbnVtZXJpYyBudW1iZXIgdmFsdWUgYmFzZWQgb24gdGhlIGdpdmVuIG9mZnNldCBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAdHlwZXBhcmFtIFQgeyBudW1iZXIgfCBiaWdpbnQgfSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYmUgd3JpdHRlblxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmMgeyBGdW5jdGlvbihvZmZzZXQ6IFQsIG9mZnNldD8pID0+IG51bWJlcn0gVGhlIGZ1bmN0aW9uIHRvIHdyaXRlIGRhdGEgb24gdGhlIGludGVybmFsIEJ1ZmZlciB3aXRoLlxuICAgICAqIEBwYXJhbSBieXRlU2l6ZSB7IE51bWJlciB9IFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBUIH0gVGhlIG51bWJlciB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gdGhlIG9mZnNldCB0byB3cml0ZSB0aGUgbnVtYmVyIGF0IChSRVFVSVJFRCkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTbWFydEJ1ZmZlciB0aGlzIGJ1ZmZlclxuICAgICAqL1xuICAgIF93cml0ZU51bWJlclZhbHVlKGZ1bmMsIGJ5dGVTaXplLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgcHJvdmlkZWQsIHZhbGlkYXRlIGl0LlxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIHdyaXRpbmcgYmV5b25kIHRoZSBib3VuZHMgb2YgdGhlIG1hbmFnZWQgZGF0YS5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuRVJST1JTLklOVkFMSURfV1JJVEVfQkVZT05EX0JPVU5EUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IHRvIHdyaXRlT2Zmc2V0IGlmIG5vIG9mZnNldCB2YWx1ZSB3YXMgZ2l2ZW4uXG4gICAgICAgIGNvbnN0IG9mZnNldFZhbCA9IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdGhpcy5fd3JpdGVPZmZzZXQ7XG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBlbm91Z2ggaW50ZXJuYWwgQnVmZmVyIGNhcGFjaXR5LiAocmF3IG9mZnNldCBpcyBwYXNzZWQpXG4gICAgICAgIHRoaXMuX2Vuc3VyZVdyaXRlYWJsZShieXRlU2l6ZSwgb2Zmc2V0VmFsKTtcbiAgICAgICAgZnVuYy5jYWxsKHRoaXMuX2J1ZmYsIHZhbHVlLCBvZmZzZXRWYWwpO1xuICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIGdpdmVuLCBjaGVjayB0byBzZWUgaWYgd2Ugd3JvdGUgYmV5b25kIHRoZSBjdXJyZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5fd3JpdGVPZmZzZXQsIG9mZnNldFZhbCArIGJ5dGVTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vIG51bWVyaWMgb2Zmc2V0IHdhcyBnaXZlbiwgd2Ugd3JvdGUgdG8gdGhlIGVuZCBvZiB0aGUgU21hcnRCdWZmZXIgc28gaW5jcmVtZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgKz0gYnl0ZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5TbWFydEJ1ZmZlciA9IFNtYXJ0QnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c21hcnRidWZmZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/smart-buffer/build/smartbuffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/smart-buffer/build/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/smart-buffer/build/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/**\n * Error strings\n */\nconst ERRORS = {\n    INVALID_ENCODING: 'Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.',\n    INVALID_SMARTBUFFER_SIZE: 'Invalid size provided. Size must be a valid integer greater than zero.',\n    INVALID_SMARTBUFFER_BUFFER: 'Invalid Buffer provided in SmartBufferOptions.',\n    INVALID_SMARTBUFFER_OBJECT: 'Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.',\n    INVALID_OFFSET: 'An invalid offset value was provided.',\n    INVALID_OFFSET_NON_NUMBER: 'An invalid offset value was provided. A numeric value is required.',\n    INVALID_LENGTH: 'An invalid length value was provided.',\n    INVALID_LENGTH_NON_NUMBER: 'An invalid length value was provived. A numeric value is required.',\n    INVALID_TARGET_OFFSET: 'Target offset is beyond the bounds of the internal SmartBuffer data.',\n    INVALID_TARGET_LENGTH: 'Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.',\n    INVALID_READ_BEYOND_BOUNDS: 'Attempted to read beyond the bounds of the managed data.',\n    INVALID_WRITE_BEYOND_BOUNDS: 'Attempted to write beyond the bounds of the managed data.'\n};\nexports.ERRORS = ERRORS;\n/**\n * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)\n *\n * @param { String } encoding The encoding string to check.\n */\nfunction checkEncoding(encoding) {\n    if (!buffer_1.Buffer.isEncoding(encoding)) {\n        throw new Error(ERRORS.INVALID_ENCODING);\n    }\n}\nexports.checkEncoding = checkEncoding;\n/**\n * Checks if a given number is a finite integer. (Throws an exception if check fails)\n *\n * @param { Number } value The number value to check.\n */\nfunction isFiniteInteger(value) {\n    return typeof value === 'number' && isFinite(value) && isInteger(value);\n}\nexports.isFiniteInteger = isFiniteInteger;\n/**\n * Checks if an offset/length value is valid. (Throws an exception if check fails)\n *\n * @param value The value to check.\n * @param offset True if checking an offset, false if checking a length.\n */\nfunction checkOffsetOrLengthValue(value, offset) {\n    if (typeof value === 'number') {\n        // Check for non finite/non integers\n        if (!isFiniteInteger(value) || value < 0) {\n            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);\n        }\n    }\n    else {\n        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);\n    }\n}\n/**\n * Checks if a length value is valid. (Throws an exception if check fails)\n *\n * @param { Number } length The value to check.\n */\nfunction checkLengthValue(length) {\n    checkOffsetOrLengthValue(length, false);\n}\nexports.checkLengthValue = checkLengthValue;\n/**\n * Checks if a offset value is valid. (Throws an exception if check fails)\n *\n * @param { Number } offset The value to check.\n */\nfunction checkOffsetValue(offset) {\n    checkOffsetOrLengthValue(offset, true);\n}\nexports.checkOffsetValue = checkOffsetValue;\n/**\n * Checks if a target offset value is out of bounds. (Throws an exception if check fails)\n *\n * @param { Number } offset The offset value to check.\n * @param { SmartBuffer } buff The SmartBuffer instance to check against.\n */\nfunction checkTargetOffset(offset, buff) {\n    if (offset < 0 || offset > buff.length) {\n        throw new Error(ERRORS.INVALID_TARGET_OFFSET);\n    }\n}\nexports.checkTargetOffset = checkTargetOffset;\n/**\n * Determines whether a given number is a integer.\n * @param value The number to check.\n */\nfunction isInteger(value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n/**\n * Throws if Node.js version is too low to support bigint\n */\nfunction bigIntAndBufferInt64Check(bufferMethod) {\n    if (typeof BigInt === 'undefined') {\n        throw new Error('Platform does not support JS BigInt type.');\n    }\n    if (typeof buffer_1.Buffer.prototype[bufferMethod] === 'undefined') {\n        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);\n    }\n}\nexports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NzMi1za2luLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3V0aWxzLmpzPzRiNjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4vKipcbiAqIEVycm9yIHN0cmluZ3NcbiAqL1xuY29uc3QgRVJST1JTID0ge1xuICAgIElOVkFMSURfRU5DT0RJTkc6ICdJbnZhbGlkIGVuY29kaW5nIHByb3ZpZGVkLiBQbGVhc2Ugc3BlY2lmeSBhIHZhbGlkIGVuY29kaW5nIHRoZSBpbnRlcm5hbCBOb2RlLmpzIEJ1ZmZlciBzdXBwb3J0cy4nLFxuICAgIElOVkFMSURfU01BUlRCVUZGRVJfU0laRTogJ0ludmFsaWQgc2l6ZSBwcm92aWRlZC4gU2l6ZSBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBncmVhdGVyIHRoYW4gemVyby4nLFxuICAgIElOVkFMSURfU01BUlRCVUZGRVJfQlVGRkVSOiAnSW52YWxpZCBCdWZmZXIgcHJvdmlkZWQgaW4gU21hcnRCdWZmZXJPcHRpb25zLicsXG4gICAgSU5WQUxJRF9TTUFSVEJVRkZFUl9PQkpFQ1Q6ICdJbnZhbGlkIFNtYXJ0QnVmZmVyT3B0aW9ucyBvYmplY3Qgc3VwcGxpZWQgdG8gU21hcnRCdWZmZXIgY29uc3RydWN0b3Igb3IgZmFjdG9yeSBtZXRob2RzLicsXG4gICAgSU5WQUxJRF9PRkZTRVQ6ICdBbiBpbnZhbGlkIG9mZnNldCB2YWx1ZSB3YXMgcHJvdmlkZWQuJyxcbiAgICBJTlZBTElEX09GRlNFVF9OT05fTlVNQkVSOiAnQW4gaW52YWxpZCBvZmZzZXQgdmFsdWUgd2FzIHByb3ZpZGVkLiBBIG51bWVyaWMgdmFsdWUgaXMgcmVxdWlyZWQuJyxcbiAgICBJTlZBTElEX0xFTkdUSDogJ0FuIGludmFsaWQgbGVuZ3RoIHZhbHVlIHdhcyBwcm92aWRlZC4nLFxuICAgIElOVkFMSURfTEVOR1RIX05PTl9OVU1CRVI6ICdBbiBpbnZhbGlkIGxlbmd0aCB2YWx1ZSB3YXMgcHJvdml2ZWQuIEEgbnVtZXJpYyB2YWx1ZSBpcyByZXF1aXJlZC4nLFxuICAgIElOVkFMSURfVEFSR0VUX09GRlNFVDogJ1RhcmdldCBvZmZzZXQgaXMgYmV5b25kIHRoZSBib3VuZHMgb2YgdGhlIGludGVybmFsIFNtYXJ0QnVmZmVyIGRhdGEuJyxcbiAgICBJTlZBTElEX1RBUkdFVF9MRU5HVEg6ICdTcGVjaWZpZWQgbGVuZ3RoIHZhbHVlIG1vdmVzIGN1cnNvciBiZXlvbmcgdGhlIGJvdW5kcyBvZiB0aGUgaW50ZXJuYWwgU21hcnRCdWZmZXIgZGF0YS4nLFxuICAgIElOVkFMSURfUkVBRF9CRVlPTkRfQk9VTkRTOiAnQXR0ZW1wdGVkIHRvIHJlYWQgYmV5b25kIHRoZSBib3VuZHMgb2YgdGhlIG1hbmFnZWQgZGF0YS4nLFxuICAgIElOVkFMSURfV1JJVEVfQkVZT05EX0JPVU5EUzogJ0F0dGVtcHRlZCB0byB3cml0ZSBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgbWFuYWdlZCBkYXRhLidcbn07XG5leHBvcnRzLkVSUk9SUyA9IEVSUk9SUztcbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZW5jb2RpbmcgaXMgYSB2YWxpZCBCdWZmZXIgZW5jb2RpbmcuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB7IFN0cmluZyB9IGVuY29kaW5nIFRoZSBlbmNvZGluZyBzdHJpbmcgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBpZiAoIWJ1ZmZlcl8xLkJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLklOVkFMSURfRU5DT0RJTkcpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tFbmNvZGluZyA9IGNoZWNrRW5jb2Rpbmc7XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIG51bWJlciBpcyBhIGZpbml0ZSBpbnRlZ2VyLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0geyBOdW1iZXIgfSB2YWx1ZSBUaGUgbnVtYmVyIHZhbHVlIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc0Zpbml0ZUludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgaXNJbnRlZ2VyKHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNGaW5pdGVJbnRlZ2VyID0gaXNGaW5pdGVJbnRlZ2VyO1xuLyoqXG4gKiBDaGVja3MgaWYgYW4gb2Zmc2V0L2xlbmd0aCB2YWx1ZSBpcyB2YWxpZC4gKFRocm93cyBhbiBleGNlcHRpb24gaWYgY2hlY2sgZmFpbHMpXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBvZmZzZXQgVHJ1ZSBpZiBjaGVja2luZyBhbiBvZmZzZXQsIGZhbHNlIGlmIGNoZWNraW5nIGEgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldE9yTGVuZ3RoVmFsdWUodmFsdWUsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBub24gZmluaXRlL25vbiBpbnRlZ2Vyc1xuICAgICAgICBpZiAoIWlzRmluaXRlSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob2Zmc2V0ID8gRVJST1JTLklOVkFMSURfT0ZGU0VUIDogRVJST1JTLklOVkFMSURfTEVOR1RIKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9mZnNldCA/IEVSUk9SUy5JTlZBTElEX09GRlNFVF9OT05fTlVNQkVSIDogRVJST1JTLklOVkFMSURfTEVOR1RIX05PTl9OVU1CRVIpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGVuZ3RoIHZhbHVlIGlzIHZhbGlkLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0geyBOdW1iZXIgfSBsZW5ndGggVGhlIHZhbHVlIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBjaGVja0xlbmd0aFZhbHVlKGxlbmd0aCkge1xuICAgIGNoZWNrT2Zmc2V0T3JMZW5ndGhWYWx1ZShsZW5ndGgsIGZhbHNlKTtcbn1cbmV4cG9ydHMuY2hlY2tMZW5ndGhWYWx1ZSA9IGNoZWNrTGVuZ3RoVmFsdWU7XG4vKipcbiAqIENoZWNrcyBpZiBhIG9mZnNldCB2YWx1ZSBpcyB2YWxpZC4gKFRocm93cyBhbiBleGNlcHRpb24gaWYgY2hlY2sgZmFpbHMpXG4gKlxuICogQHBhcmFtIHsgTnVtYmVyIH0gb2Zmc2V0IFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpIHtcbiAgICBjaGVja09mZnNldE9yTGVuZ3RoVmFsdWUob2Zmc2V0LCB0cnVlKTtcbn1cbmV4cG9ydHMuY2hlY2tPZmZzZXRWYWx1ZSA9IGNoZWNrT2Zmc2V0VmFsdWU7XG4vKipcbiAqIENoZWNrcyBpZiBhIHRhcmdldCBvZmZzZXQgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcy4gKFRocm93cyBhbiBleGNlcHRpb24gaWYgY2hlY2sgZmFpbHMpXG4gKlxuICogQHBhcmFtIHsgTnVtYmVyIH0gb2Zmc2V0IFRoZSBvZmZzZXQgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0geyBTbWFydEJ1ZmZlciB9IGJ1ZmYgVGhlIFNtYXJ0QnVmZmVyIGluc3RhbmNlIHRvIGNoZWNrIGFnYWluc3QuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrVGFyZ2V0T2Zmc2V0KG9mZnNldCwgYnVmZikge1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmYubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuSU5WQUxJRF9UQVJHRVRfT0ZGU0VUKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVGFyZ2V0T2Zmc2V0ID0gY2hlY2tUYXJnZXRPZmZzZXQ7XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGdpdmVuIG51bWJlciBpcyBhIGludGVnZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIG51bWJlciB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn1cbi8qKlxuICogVGhyb3dzIGlmIE5vZGUuanMgdmVyc2lvbiBpcyB0b28gbG93IHRvIHN1cHBvcnQgYmlnaW50XG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soYnVmZmVyTWV0aG9kKSB7XG4gICAgaWYgKHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCBKUyBCaWdJbnQgdHlwZS4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBidWZmZXJfMS5CdWZmZXIucHJvdG90eXBlW2J1ZmZlck1ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCBCdWZmZXIucHJvdG90eXBlLiR7YnVmZmVyTWV0aG9kfS5gKTtcbiAgICB9XG59XG5leHBvcnRzLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2sgPSBiaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/smart-buffer/build/utils.js\n");

/***/ })

};
;