"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ip-address";
exports.ids = ["vendor-chunks/ip-address"];
exports.modules = {

/***/ "(rsc)/./node_modules/ip-address/dist/address-error.js":
/*!*******************************************************!*\
  !*** ./node_modules/ip-address/dist/address-error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AddressError = void 0;\nclass AddressError extends Error {\n    constructor(message, parseMessage) {\n        super(message);\n        this.name = 'AddressError';\n        if (parseMessage !== null) {\n            this.parseMessage = parseMessage;\n        }\n    }\n}\nexports.AddressError = AddressError;\n//# sourceMappingURL=address-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2FkZHJlc3MtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NzMi1za2luLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2FkZHJlc3MtZXJyb3IuanM/MGYyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzc0Vycm9yID0gdm9pZCAwO1xuY2xhc3MgQWRkcmVzc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHBhcnNlTWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FkZHJlc3NFcnJvcic7XG4gICAgICAgIGlmIChwYXJzZU1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VNZXNzYWdlID0gcGFyc2VNZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzRXJyb3IgPSBBZGRyZXNzRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/address-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/common.js":
/*!************************************************!*\
  !*** ./node_modules/ip-address/dist/common.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isCorrect = exports.isInSubnet = void 0;\nfunction isInSubnet(address) {\n    if (this.subnetMask < address.subnetMask) {\n        return false;\n    }\n    if (this.mask(address.subnetMask) === address.mask()) {\n        return true;\n    }\n    return false;\n}\nexports.isInSubnet = isInSubnet;\nfunction isCorrect(defaultBits) {\n    return function () {\n        if (this.addressMinusSuffix !== this.correctForm()) {\n            return false;\n        }\n        if (this.subnetMask === defaultBits && !this.parsedSubnet) {\n            return true;\n        }\n        return this.parsedSubnet === String(this.subnetMask);\n    };\n}\nexports.isCorrect = isCorrect;\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jczItc2tpbi10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2lwLWFkZHJlc3MvZGlzdC9jb21tb24uanM/YTg3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNDb3JyZWN0ID0gZXhwb3J0cy5pc0luU3VibmV0ID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNJblN1Ym5ldChhZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMuc3VibmV0TWFzayA8IGFkZHJlc3Muc3VibmV0TWFzaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hc2soYWRkcmVzcy5zdWJuZXRNYXNrKSA9PT0gYWRkcmVzcy5tYXNrKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNJblN1Ym5ldCA9IGlzSW5TdWJuZXQ7XG5mdW5jdGlvbiBpc0NvcnJlY3QoZGVmYXVsdEJpdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hZGRyZXNzTWludXNTdWZmaXggIT09IHRoaXMuY29ycmVjdEZvcm0oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1Ym5ldE1hc2sgPT09IGRlZmF1bHRCaXRzICYmICF0aGlzLnBhcnNlZFN1Ym5ldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkU3VibmV0ID09PSBTdHJpbmcodGhpcy5zdWJuZXRNYXNrKTtcbiAgICB9O1xufVxuZXhwb3J0cy5pc0NvcnJlY3QgPSBpc0NvcnJlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/ip-address.js":
/*!****************************************************!*\
  !*** ./node_modules/ip-address/dist/ip-address.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = void 0;\nconst ipv4_1 = __webpack_require__(/*! ./ipv4 */ \"(rsc)/./node_modules/ip-address/dist/ipv4.js\");\nObject.defineProperty(exports, \"Address4\", ({ enumerable: true, get: function () { return ipv4_1.Address4; } }));\nconst ipv6_1 = __webpack_require__(/*! ./ipv6 */ \"(rsc)/./node_modules/ip-address/dist/ipv6.js\");\nObject.defineProperty(exports, \"Address6\", ({ enumerable: true, get: function () { return ipv6_1.Address6; } }));\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"(rsc)/./node_modules/ip-address/dist/address-error.js\");\nObject.defineProperty(exports, \"AddressError\", ({ enumerable: true, get: function () { return address_error_1.AddressError; } }));\nconst helpers = __importStar(__webpack_require__(/*! ./v6/helpers */ \"(rsc)/./node_modules/ip-address/dist/v6/helpers.js\"));\nexports.v6 = { helpers };\n//# sourceMappingURL=ip-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2lwLWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFVBQVUsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDdkUsZUFBZSxtQkFBTyxDQUFDLDREQUFRO0FBQy9CLDRDQUEyQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM5RyxlQUFlLG1CQUFPLENBQUMsNERBQVE7QUFDL0IsNENBQTJDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzlHLHdCQUF3QixtQkFBTyxDQUFDLDhFQUFpQjtBQUNqRCxnREFBK0MsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDL0gsNkJBQTZCLG1CQUFPLENBQUMsd0VBQWM7QUFDbkQsVUFBVSxLQUFLO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jczItc2tpbi10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2lwLWFkZHJlc3MvZGlzdC9pcC1hZGRyZXNzLmpzPzg3ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudjYgPSBleHBvcnRzLkFkZHJlc3NFcnJvciA9IGV4cG9ydHMuQWRkcmVzczYgPSBleHBvcnRzLkFkZHJlc3M0ID0gdm9pZCAwO1xuY29uc3QgaXB2NF8xID0gcmVxdWlyZShcIi4vaXB2NFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFkZHJlc3M0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpcHY0XzEuQWRkcmVzczQ7IH0gfSk7XG5jb25zdCBpcHY2XzEgPSByZXF1aXJlKFwiLi9pcHY2XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWRkcmVzczZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlwdjZfMS5BZGRyZXNzNjsgfSB9KTtcbmNvbnN0IGFkZHJlc3NfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MtZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBZGRyZXNzRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3I7IH0gfSk7XG5jb25zdCBoZWxwZXJzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3Y2L2hlbHBlcnNcIikpO1xuZXhwb3J0cy52NiA9IHsgaGVscGVycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXAtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/ip-address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/ipv4.js":
/*!**********************************************!*\
  !*** ./node_modules/ip-address/dist/ipv4.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* eslint-disable no-param-reassign */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address4 = void 0;\nconst common = __importStar(__webpack_require__(/*! ./common */ \"(rsc)/./node_modules/ip-address/dist/common.js\"));\nconst constants = __importStar(__webpack_require__(/*! ./v4/constants */ \"(rsc)/./node_modules/ip-address/dist/v4/constants.js\"));\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"(rsc)/./node_modules/ip-address/dist/address-error.js\");\nconst jsbn_1 = __webpack_require__(/*! jsbn */ \"(rsc)/./node_modules/jsbn/index.js\");\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"(rsc)/./node_modules/sprintf-js/src/sprintf.js\");\n/**\n * Represents an IPv4 address\n * @class Address4\n * @param {string} address - An IPv4 address string\n */\nclass Address4 {\n    constructor(address) {\n        this.groups = constants.GROUPS;\n        this.parsedAddress = [];\n        this.parsedSubnet = '';\n        this.subnet = '/32';\n        this.subnetMask = 32;\n        this.v4 = true;\n        /**\n         * Returns true if the address is correct, false otherwise\n         * @memberof Address4\n         * @instance\n         * @returns {Boolean}\n         */\n        this.isCorrect = common.isCorrect(constants.BITS);\n        /**\n         * Returns true if the given address is in the subnet of the current address\n         * @memberof Address4\n         * @instance\n         * @returns {boolean}\n         */\n        this.isInSubnet = common.isInSubnet;\n        this.address = address;\n        const subnet = constants.RE_SUBNET_STRING.exec(address);\n        if (subnet) {\n            this.parsedSubnet = subnet[0].replace('/', '');\n            this.subnetMask = parseInt(this.parsedSubnet, 10);\n            this.subnet = `/${this.subnetMask}`;\n            if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {\n                throw new address_error_1.AddressError('Invalid subnet mask.');\n            }\n            address = address.replace(constants.RE_SUBNET_STRING, '');\n        }\n        this.addressMinusSuffix = address;\n        this.parsedAddress = this.parse(address);\n    }\n    static isValid(address) {\n        try {\n            // eslint-disable-next-line no-new\n            new Address4(address);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /*\n     * Parses a v4 address\n     */\n    parse(address) {\n        const groups = address.split('.');\n        if (!address.match(constants.RE_ADDRESS)) {\n            throw new address_error_1.AddressError('Invalid IPv4 address.');\n        }\n        return groups;\n    }\n    /**\n     * Returns the correct form of an address\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    correctForm() {\n        return this.parsedAddress.map((part) => parseInt(part, 10)).join('.');\n    }\n    /**\n     * Converts a hex string to an IPv4 address object\n     * @memberof Address4\n     * @static\n     * @param {string} hex - a hex string to convert\n     * @returns {Address4}\n     */\n    static fromHex(hex) {\n        const padded = hex.replace(/:/g, '').padStart(8, '0');\n        const groups = [];\n        let i;\n        for (i = 0; i < 8; i += 2) {\n            const h = padded.slice(i, i + 2);\n            groups.push(parseInt(h, 16));\n        }\n        return new Address4(groups.join('.'));\n    }\n    /**\n     * Converts an integer into a IPv4 address object\n     * @memberof Address4\n     * @static\n     * @param {integer} integer - a number to convert\n     * @returns {Address4}\n     */\n    static fromInteger(integer) {\n        return Address4.fromHex(integer.toString(16));\n    }\n    /**\n     * Return an address from in-addr.arpa form\n     * @memberof Address4\n     * @static\n     * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address\n     * @returns {Adress4}\n     * @example\n     * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)\n     * address.correctForm(); // '192.0.2.42'\n     */\n    static fromArpa(arpaFormAddress) {\n        // remove ending \".in-addr.arpa.\" or just \".\"\n        const leader = arpaFormAddress.replace(/(\\.in-addr\\.arpa)?\\.$/, '');\n        const address = leader.split('.').reverse().join('.');\n        return new Address4(address);\n    }\n    /**\n     * Converts an IPv4 address object to a hex string\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    toHex() {\n        return this.parsedAddress.map((part) => (0, sprintf_js_1.sprintf)('%02x', parseInt(part, 10))).join(':');\n    }\n    /**\n     * Converts an IPv4 address object to an array of bytes\n     * @memberof Address4\n     * @instance\n     * @returns {Array}\n     */\n    toArray() {\n        return this.parsedAddress.map((part) => parseInt(part, 10));\n    }\n    /**\n     * Converts an IPv4 address object to an IPv6 address group\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    toGroup6() {\n        const output = [];\n        let i;\n        for (i = 0; i < constants.GROUPS; i += 2) {\n            const hex = (0, sprintf_js_1.sprintf)('%02x%02x', parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));\n            output.push((0, sprintf_js_1.sprintf)('%x', parseInt(hex, 16)));\n        }\n        return output.join(':');\n    }\n    /**\n     * Returns the address as a BigInteger\n     * @memberof Address4\n     * @instance\n     * @returns {BigInteger}\n     */\n    bigInteger() {\n        return new jsbn_1.BigInteger(this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)('%02x', parseInt(n, 10))).join(''), 16);\n    }\n    /**\n     * Helper function getting start address.\n     * @memberof Address4\n     * @instance\n     * @returns {BigInteger}\n     */\n    _startAddress() {\n        return new jsbn_1.BigInteger(this.mask() + '0'.repeat(constants.BITS - this.subnetMask), 2);\n    }\n    /**\n     * The first address in the range given by this address' subnet.\n     * Often referred to as the Network Address.\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    startAddress() {\n        return Address4.fromBigInteger(this._startAddress());\n    }\n    /**\n     * The first host address in the range given by this address's subnet ie\n     * the first address after the Network Address\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    startAddressExclusive() {\n        const adjust = new jsbn_1.BigInteger('1');\n        return Address4.fromBigInteger(this._startAddress().add(adjust));\n    }\n    /**\n     * Helper function getting end address.\n     * @memberof Address4\n     * @instance\n     * @returns {BigInteger}\n     */\n    _endAddress() {\n        return new jsbn_1.BigInteger(this.mask() + '1'.repeat(constants.BITS - this.subnetMask), 2);\n    }\n    /**\n     * The last address in the range given by this address' subnet\n     * Often referred to as the Broadcast\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    endAddress() {\n        return Address4.fromBigInteger(this._endAddress());\n    }\n    /**\n     * The last host address in the range given by this address's subnet ie\n     * the last address prior to the Broadcast Address\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    endAddressExclusive() {\n        const adjust = new jsbn_1.BigInteger('1');\n        return Address4.fromBigInteger(this._endAddress().subtract(adjust));\n    }\n    /**\n     * Converts a BigInteger to a v4 address object\n     * @memberof Address4\n     * @static\n     * @param {BigInteger} bigInteger - a BigInteger to convert\n     * @returns {Address4}\n     */\n    static fromBigInteger(bigInteger) {\n        return Address4.fromInteger(parseInt(bigInteger.toString(), 10));\n    }\n    /**\n     * Returns the first n bits of the address, defaulting to the\n     * subnet mask\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    mask(mask) {\n        if (mask === undefined) {\n            mask = this.subnetMask;\n        }\n        return this.getBitsBase2(0, mask);\n    }\n    /**\n     * Returns the bits in the given range as a base-2 string\n     * @memberof Address4\n     * @instance\n     * @returns {string}\n     */\n    getBitsBase2(start, end) {\n        return this.binaryZeroPad().slice(start, end);\n    }\n    /**\n     * Return the reversed ip6.arpa form of the address\n     * @memberof Address4\n     * @param {Object} options\n     * @param {boolean} options.omitSuffix - omit the \"in-addr.arpa\" suffix\n     * @instance\n     * @returns {String}\n     */\n    reverseForm(options) {\n        if (!options) {\n            options = {};\n        }\n        const reversed = this.correctForm().split('.').reverse().join('.');\n        if (options.omitSuffix) {\n            return reversed;\n        }\n        return (0, sprintf_js_1.sprintf)('%s.in-addr.arpa.', reversed);\n    }\n    /**\n     * Returns true if the given address is a multicast address\n     * @memberof Address4\n     * @instance\n     * @returns {boolean}\n     */\n    isMulticast() {\n        return this.isInSubnet(new Address4('224.0.0.0/4'));\n    }\n    /**\n     * Returns a zero-padded base-2 string representation of the address\n     * @memberof Address4\n     * @instance\n     * @returns {string}\n     */\n    binaryZeroPad() {\n        return this.bigInteger().toString(2).padStart(constants.BITS, '0');\n    }\n    /**\n     * Groups an IPv4 address for inclusion at the end of an IPv6 address\n     * @returns {String}\n     */\n    groupForV6() {\n        const segments = this.parsedAddress;\n        return this.address.replace(constants.RE_ADDRESS, (0, sprintf_js_1.sprintf)('<span class=\"hover-group group-v4 group-6\">%s</span>.<span class=\"hover-group group-v4 group-7\">%s</span>', segments.slice(0, 2).join('.'), segments.slice(2, 4).join('.')));\n    }\n}\nexports.Address4 = Address4;\n//# sourceMappingURL=ipv4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2lwdjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLDRCQUE0QixtQkFBTyxDQUFDLGdFQUFVO0FBQzlDLCtCQUErQixtQkFBTyxDQUFDLDRFQUFnQjtBQUN2RCx3QkFBd0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLGdEQUFNO0FBQzdCLHFCQUFxQixtQkFBTyxDQUFDLGtFQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MyLXNraW4tdHJhY2tlci8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvaXB2NC5qcz9jMGY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzNCA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb21tb25cIikpO1xuY29uc3QgY29uc3RhbnRzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3Y0L2NvbnN0YW50c1wiKSk7XG5jb25zdCBhZGRyZXNzX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzLWVycm9yXCIpO1xuY29uc3QganNibl8xID0gcmVxdWlyZShcImpzYm5cIik7XG5jb25zdCBzcHJpbnRmX2pzXzEgPSByZXF1aXJlKFwic3ByaW50Zi1qc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBJUHY0IGFkZHJlc3NcbiAqIEBjbGFzcyBBZGRyZXNzNFxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBBbiBJUHY0IGFkZHJlc3Mgc3RyaW5nXG4gKi9cbmNsYXNzIEFkZHJlc3M0IHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gY29uc3RhbnRzLkdST1VQUztcbiAgICAgICAgdGhpcy5wYXJzZWRBZGRyZXNzID0gW107XG4gICAgICAgIHRoaXMucGFyc2VkU3VibmV0ID0gJyc7XG4gICAgICAgIHRoaXMuc3VibmV0ID0gJy8zMic7XG4gICAgICAgIHRoaXMuc3VibmV0TWFzayA9IDMyO1xuICAgICAgICB0aGlzLnY0ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBjb3JyZWN0LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNDb3JyZWN0ID0gY29tbW9uLmlzQ29ycmVjdChjb25zdGFudHMuQklUUyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFkZHJlc3MgaXMgaW4gdGhlIHN1Ym5ldCBvZiB0aGUgY3VycmVudCBhZGRyZXNzXG4gICAgICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzSW5TdWJuZXQgPSBjb21tb24uaXNJblN1Ym5ldDtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgY29uc3Qgc3VibmV0ID0gY29uc3RhbnRzLlJFX1NVQk5FVF9TVFJJTkcuZXhlYyhhZGRyZXNzKTtcbiAgICAgICAgaWYgKHN1Ym5ldCkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRTdWJuZXQgPSBzdWJuZXRbMF0ucmVwbGFjZSgnLycsICcnKTtcbiAgICAgICAgICAgIHRoaXMuc3VibmV0TWFzayA9IHBhcnNlSW50KHRoaXMucGFyc2VkU3VibmV0LCAxMCk7XG4gICAgICAgICAgICB0aGlzLnN1Ym5ldCA9IGAvJHt0aGlzLnN1Ym5ldE1hc2t9YDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1Ym5ldE1hc2sgPCAwIHx8IHRoaXMuc3VibmV0TWFzayA+IGNvbnN0YW50cy5CSVRTKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoJ0ludmFsaWQgc3VibmV0IG1hc2suJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKGNvbnN0YW50cy5SRV9TVUJORVRfU1RSSU5HLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRyZXNzTWludXNTdWZmaXggPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLnBhcnNlZEFkZHJlc3MgPSB0aGlzLnBhcnNlKGFkZHJlc3MpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZChhZGRyZXNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG4gICAgICAgICAgICBuZXcgQWRkcmVzczQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICogUGFyc2VzIGEgdjQgYWRkcmVzc1xuICAgICAqL1xuICAgIHBhcnNlKGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gYWRkcmVzcy5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoIWFkZHJlc3MubWF0Y2goY29uc3RhbnRzLlJFX0FERFJFU1MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcignSW52YWxpZCBJUHY0IGFkZHJlc3MuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29ycmVjdCBmb3JtIG9mIGFuIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNvcnJlY3RGb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRBZGRyZXNzLm1hcCgocGFydCkgPT4gcGFyc2VJbnQocGFydCwgMTApKS5qb2luKCcuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhbiBJUHY0IGFkZHJlc3Mgb2JqZWN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXggLSBhIGhleCBzdHJpbmcgdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgcGFkZGVkID0gaGV4LnJlcGxhY2UoLzovZywgJycpLnBhZFN0YXJ0KDgsICcwJyk7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaCA9IHBhZGRlZC5zbGljZShpLCBpICsgMik7XG4gICAgICAgICAgICBncm91cHMucHVzaChwYXJzZUludChoLCAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzczQoZ3JvdXBzLmpvaW4oJy4nKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIGludGVnZXIgaW50byBhIElQdjQgYWRkcmVzcyBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBpbnRlZ2VyIC0gYSBudW1iZXIgdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUludGVnZXIoaW50ZWdlcikge1xuICAgICAgICByZXR1cm4gQWRkcmVzczQuZnJvbUhleChpbnRlZ2VyLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhZGRyZXNzIGZyb20gaW4tYWRkci5hcnBhIGZvcm1cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFycGFGb3JtQWRkcmVzcyAtIGFuICdpbi1hZGRyLmFycGEnIGZvcm0gaXB2NCBhZGRyZXNzXG4gICAgICogQHJldHVybnMge0FkcmVzczR9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYWRkcmVzcyA9IEFkZHJlc3M0LmZyb21BcnBhKDQyLjIuMC4xOTIuaW4tYWRkci5hcnBhLilcbiAgICAgKiBhZGRyZXNzLmNvcnJlY3RGb3JtKCk7IC8vICcxOTIuMC4yLjQyJ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQXJwYShhcnBhRm9ybUFkZHJlc3MpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGVuZGluZyBcIi5pbi1hZGRyLmFycGEuXCIgb3IganVzdCBcIi5cIlxuICAgICAgICBjb25zdCBsZWFkZXIgPSBhcnBhRm9ybUFkZHJlc3MucmVwbGFjZSgvKFxcLmluLWFkZHJcXC5hcnBhKT9cXC4kLywgJycpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gbGVhZGVyLnNwbGl0KCcuJykucmV2ZXJzZSgpLmpvaW4oJy4nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzNChhZGRyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gSVB2NCBhZGRyZXNzIG9iamVjdCB0byBhIGhleCBzdHJpbmdcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRBZGRyZXNzLm1hcCgocGFydCkgPT4gKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnJTAyeCcsIHBhcnNlSW50KHBhcnQsIDEwKSkpLmpvaW4oJzonKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gSVB2NCBhZGRyZXNzIG9iamVjdCB0byBhbiBhcnJheSBvZiBieXRlc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRBZGRyZXNzLm1hcCgocGFydCkgPT4gcGFyc2VJbnQocGFydCwgMTApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gSVB2NCBhZGRyZXNzIG9iamVjdCB0byBhbiBJUHY2IGFkZHJlc3MgZ3JvdXBcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvR3JvdXA2KCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25zdGFudHMuR1JPVVBTOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9ICgwLCBzcHJpbnRmX2pzXzEuc3ByaW50ZikoJyUwMnglMDJ4JywgcGFyc2VJbnQodGhpcy5wYXJzZWRBZGRyZXNzW2ldLCAxMCksIHBhcnNlSW50KHRoaXMucGFyc2VkQWRkcmVzc1tpICsgMV0sIDEwKSk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCgoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCcleCcsIHBhcnNlSW50KGhleCwgMTYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCc6Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFkZHJlc3MgYXMgYSBCaWdJbnRlZ2VyXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0JpZ0ludGVnZXJ9XG4gICAgICovXG4gICAgYmlnSW50ZWdlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBqc2JuXzEuQmlnSW50ZWdlcih0aGlzLnBhcnNlZEFkZHJlc3MubWFwKChuKSA9PiAoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCclMDJ4JywgcGFyc2VJbnQobiwgMTApKSkuam9pbignJyksIDE2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGdldHRpbmcgc3RhcnQgYWRkcmVzcy5cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QmlnSW50ZWdlcn1cbiAgICAgKi9cbiAgICBfc3RhcnRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGpzYm5fMS5CaWdJbnRlZ2VyKHRoaXMubWFzaygpICsgJzAnLnJlcGVhdChjb25zdGFudHMuQklUUyAtIHRoaXMuc3VibmV0TWFzayksIDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgYWRkcmVzcyBpbiB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhpcyBhZGRyZXNzJyBzdWJuZXQuXG4gICAgICogT2Z0ZW4gcmVmZXJyZWQgdG8gYXMgdGhlIE5ldHdvcmsgQWRkcmVzcy5cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczR9XG4gICAgICovXG4gICAgc3RhcnRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQWRkcmVzczQuZnJvbUJpZ0ludGVnZXIodGhpcy5fc3RhcnRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgaG9zdCBhZGRyZXNzIGluIHRoZSByYW5nZSBnaXZlbiBieSB0aGlzIGFkZHJlc3MncyBzdWJuZXQgaWVcbiAgICAgKiB0aGUgZmlyc3QgYWRkcmVzcyBhZnRlciB0aGUgTmV0d29yayBBZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXJ0QWRkcmVzc0V4Y2x1c2l2ZSgpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ID0gbmV3IGpzYm5fMS5CaWdJbnRlZ2VyKCcxJyk7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNC5mcm9tQmlnSW50ZWdlcih0aGlzLl9zdGFydEFkZHJlc3MoKS5hZGQoYWRqdXN0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBnZXR0aW5nIGVuZCBhZGRyZXNzLlxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtCaWdJbnRlZ2VyfVxuICAgICAqL1xuICAgIF9lbmRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGpzYm5fMS5CaWdJbnRlZ2VyKHRoaXMubWFzaygpICsgJzEnLnJlcGVhdChjb25zdGFudHMuQklUUyAtIHRoaXMuc3VibmV0TWFzayksIDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBhZGRyZXNzIGluIHRoZSByYW5nZSBnaXZlbiBieSB0aGlzIGFkZHJlc3MnIHN1Ym5ldFxuICAgICAqIE9mdGVuIHJlZmVycmVkIHRvIGFzIHRoZSBCcm9hZGNhc3RcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczR9XG4gICAgICovXG4gICAgZW5kQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3M0LmZyb21CaWdJbnRlZ2VyKHRoaXMuX2VuZEFkZHJlc3MoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IGhvc3QgYWRkcmVzcyBpbiB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhpcyBhZGRyZXNzJ3Mgc3VibmV0IGllXG4gICAgICogdGhlIGxhc3QgYWRkcmVzcyBwcmlvciB0byB0aGUgQnJvYWRjYXN0IEFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczR9XG4gICAgICovXG4gICAgZW5kQWRkcmVzc0V4Y2x1c2l2ZSgpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ID0gbmV3IGpzYm5fMS5CaWdJbnRlZ2VyKCcxJyk7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNC5mcm9tQmlnSW50ZWdlcih0aGlzLl9lbmRBZGRyZXNzKCkuc3VidHJhY3QoYWRqdXN0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgQmlnSW50ZWdlciB0byBhIHY0IGFkZHJlc3Mgb2JqZWN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QmlnSW50ZWdlcn0gYmlnSW50ZWdlciAtIGEgQmlnSW50ZWdlciB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmlnSW50ZWdlcihiaWdJbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNC5mcm9tSW50ZWdlcihwYXJzZUludChiaWdJbnRlZ2VyLnRvU3RyaW5nKCksIDEwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IG4gYml0cyBvZiB0aGUgYWRkcmVzcywgZGVmYXVsdGluZyB0byB0aGVcbiAgICAgKiBzdWJuZXQgbWFza1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgbWFzayhtYXNrKSB7XG4gICAgICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1hc2sgPSB0aGlzLnN1Ym5ldE1hc2s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0c0Jhc2UyKDAsIG1hc2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXRzIGluIHRoZSBnaXZlbiByYW5nZSBhcyBhIGJhc2UtMiBzdHJpbmdcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEJpdHNCYXNlMihzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVplcm9QYWQoKS5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZXZlcnNlZCBpcDYuYXJwYSBmb3JtIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMub21pdFN1ZmZpeCAtIG9taXQgdGhlIFwiaW4tYWRkci5hcnBhXCIgc3VmZml4XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICByZXZlcnNlRm9ybShvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldmVyc2VkID0gdGhpcy5jb3JyZWN0Rm9ybSgpLnNwbGl0KCcuJykucmV2ZXJzZSgpLmpvaW4oJy4nKTtcbiAgICAgICAgaWYgKG9wdGlvbnMub21pdFN1ZmZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldmVyc2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCclcy5pbi1hZGRyLmFycGEuJywgcmV2ZXJzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFkZHJlc3MgaXMgYSBtdWx0aWNhc3QgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTXVsdGljYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0luU3VibmV0KG5ldyBBZGRyZXNzNCgnMjI0LjAuMC4wLzQnKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB6ZXJvLXBhZGRlZCBiYXNlLTIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBiaW5hcnlaZXJvUGFkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaWdJbnRlZ2VyKCkudG9TdHJpbmcoMikucGFkU3RhcnQoY29uc3RhbnRzLkJJVFMsICcwJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBhbiBJUHY0IGFkZHJlc3MgZm9yIGluY2x1c2lvbiBhdCB0aGUgZW5kIG9mIGFuIElQdjYgYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ3JvdXBGb3JWNigpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnBhcnNlZEFkZHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3MucmVwbGFjZShjb25zdGFudHMuUkVfQUREUkVTUywgKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnPHNwYW4gY2xhc3M9XCJob3Zlci1ncm91cCBncm91cC12NCBncm91cC02XCI+JXM8L3NwYW4+LjxzcGFuIGNsYXNzPVwiaG92ZXItZ3JvdXAgZ3JvdXAtdjQgZ3JvdXAtN1wiPiVzPC9zcGFuPicsIHNlZ21lbnRzLnNsaWNlKDAsIDIpLmpvaW4oJy4nKSwgc2VnbWVudHMuc2xpY2UoMiwgNCkuam9pbignLicpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzNCA9IEFkZHJlc3M0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXB2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/ipv4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/ipv6.js":
/*!**********************************************!*\
  !*** ./node_modules/ip-address/dist/ipv6.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-param-reassign */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address6 = void 0;\nconst common = __importStar(__webpack_require__(/*! ./common */ \"(rsc)/./node_modules/ip-address/dist/common.js\"));\nconst constants4 = __importStar(__webpack_require__(/*! ./v4/constants */ \"(rsc)/./node_modules/ip-address/dist/v4/constants.js\"));\nconst constants6 = __importStar(__webpack_require__(/*! ./v6/constants */ \"(rsc)/./node_modules/ip-address/dist/v6/constants.js\"));\nconst helpers = __importStar(__webpack_require__(/*! ./v6/helpers */ \"(rsc)/./node_modules/ip-address/dist/v6/helpers.js\"));\nconst ipv4_1 = __webpack_require__(/*! ./ipv4 */ \"(rsc)/./node_modules/ip-address/dist/ipv4.js\");\nconst regular_expressions_1 = __webpack_require__(/*! ./v6/regular-expressions */ \"(rsc)/./node_modules/ip-address/dist/v6/regular-expressions.js\");\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"(rsc)/./node_modules/ip-address/dist/address-error.js\");\nconst jsbn_1 = __webpack_require__(/*! jsbn */ \"(rsc)/./node_modules/jsbn/index.js\");\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"(rsc)/./node_modules/sprintf-js/src/sprintf.js\");\nfunction assert(condition) {\n    if (!condition) {\n        throw new Error('Assertion failed.');\n    }\n}\nfunction addCommas(number) {\n    const r = /(\\d+)(\\d{3})/;\n    while (r.test(number)) {\n        number = number.replace(r, '$1,$2');\n    }\n    return number;\n}\nfunction spanLeadingZeroes4(n) {\n    n = n.replace(/^(0{1,})([1-9]+)$/, '<span class=\"parse-error\">$1</span>$2');\n    n = n.replace(/^(0{1,})(0)$/, '<span class=\"parse-error\">$1</span>$2');\n    return n;\n}\n/*\n * A helper function to compact an array\n */\nfunction compact(address, slice) {\n    const s1 = [];\n    const s2 = [];\n    let i;\n    for (i = 0; i < address.length; i++) {\n        if (i < slice[0]) {\n            s1.push(address[i]);\n        }\n        else if (i > slice[1]) {\n            s2.push(address[i]);\n        }\n    }\n    return s1.concat(['compact']).concat(s2);\n}\nfunction paddedHex(octet) {\n    return (0, sprintf_js_1.sprintf)('%04x', parseInt(octet, 16));\n}\nfunction unsignByte(b) {\n    // eslint-disable-next-line no-bitwise\n    return b & 0xff;\n}\n/**\n * Represents an IPv6 address\n * @class Address6\n * @param {string} address - An IPv6 address string\n * @param {number} [groups=8] - How many octets to parse\n * @example\n * var address = new Address6('2001::/32');\n */\nclass Address6 {\n    constructor(address, optionalGroups) {\n        this.addressMinusSuffix = '';\n        this.parsedSubnet = '';\n        this.subnet = '/128';\n        this.subnetMask = 128;\n        this.v4 = false;\n        this.zone = '';\n        // #region Attributes\n        /**\n         * Returns true if the given address is in the subnet of the current address\n         * @memberof Address6\n         * @instance\n         * @returns {boolean}\n         */\n        this.isInSubnet = common.isInSubnet;\n        /**\n         * Returns true if the address is correct, false otherwise\n         * @memberof Address6\n         * @instance\n         * @returns {boolean}\n         */\n        this.isCorrect = common.isCorrect(constants6.BITS);\n        if (optionalGroups === undefined) {\n            this.groups = constants6.GROUPS;\n        }\n        else {\n            this.groups = optionalGroups;\n        }\n        this.address = address;\n        const subnet = constants6.RE_SUBNET_STRING.exec(address);\n        if (subnet) {\n            this.parsedSubnet = subnet[0].replace('/', '');\n            this.subnetMask = parseInt(this.parsedSubnet, 10);\n            this.subnet = `/${this.subnetMask}`;\n            if (Number.isNaN(this.subnetMask) ||\n                this.subnetMask < 0 ||\n                this.subnetMask > constants6.BITS) {\n                throw new address_error_1.AddressError('Invalid subnet mask.');\n            }\n            address = address.replace(constants6.RE_SUBNET_STRING, '');\n        }\n        else if (/\\//.test(address)) {\n            throw new address_error_1.AddressError('Invalid subnet mask.');\n        }\n        const zone = constants6.RE_ZONE_STRING.exec(address);\n        if (zone) {\n            this.zone = zone[0];\n            address = address.replace(constants6.RE_ZONE_STRING, '');\n        }\n        this.addressMinusSuffix = address;\n        this.parsedAddress = this.parse(this.addressMinusSuffix);\n    }\n    static isValid(address) {\n        try {\n            // eslint-disable-next-line no-new\n            new Address6(address);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Convert a BigInteger to a v6 address object\n     * @memberof Address6\n     * @static\n     * @param {BigInteger} bigInteger - a BigInteger to convert\n     * @returns {Address6}\n     * @example\n     * var bigInteger = new BigInteger('1000000000000');\n     * var address = Address6.fromBigInteger(bigInteger);\n     * address.correctForm(); // '::e8:d4a5:1000'\n     */\n    static fromBigInteger(bigInteger) {\n        const hex = bigInteger.toString(16).padStart(32, '0');\n        const groups = [];\n        let i;\n        for (i = 0; i < constants6.GROUPS; i++) {\n            groups.push(hex.slice(i * 4, (i + 1) * 4));\n        }\n        return new Address6(groups.join(':'));\n    }\n    /**\n     * Convert a URL (with optional port number) to an address object\n     * @memberof Address6\n     * @static\n     * @param {string} url - a URL with optional port number\n     * @example\n     * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');\n     * addressAndPort.address.correctForm(); // 'ffff::'\n     * addressAndPort.port; // 8080\n     */\n    static fromURL(url) {\n        let host;\n        let port = null;\n        let result;\n        // If we have brackets parse them and find a port\n        if (url.indexOf('[') !== -1 && url.indexOf(']:') !== -1) {\n            result = constants6.RE_URL_WITH_PORT.exec(url);\n            if (result === null) {\n                return {\n                    error: 'failed to parse address with port',\n                    address: null,\n                    port: null,\n                };\n            }\n            host = result[1];\n            port = result[2];\n            // If there's a URL extract the address\n        }\n        else if (url.indexOf('/') !== -1) {\n            // Remove the protocol prefix\n            url = url.replace(/^[a-z0-9]+:\\/\\//, '');\n            // Parse the address\n            result = constants6.RE_URL.exec(url);\n            if (result === null) {\n                return {\n                    error: 'failed to parse address from URL',\n                    address: null,\n                    port: null,\n                };\n            }\n            host = result[1];\n            // Otherwise just assign the URL to the host and let the library parse it\n        }\n        else {\n            host = url;\n        }\n        // If there's a port convert it to an integer\n        if (port) {\n            port = parseInt(port, 10);\n            // squelch out of range ports\n            if (port < 0 || port > 65536) {\n                port = null;\n            }\n        }\n        else {\n            // Standardize `undefined` to `null`\n            port = null;\n        }\n        return {\n            address: new Address6(host),\n            port,\n        };\n    }\n    /**\n     * Create an IPv6-mapped address given an IPv4 address\n     * @memberof Address6\n     * @static\n     * @param {string} address - An IPv4 address string\n     * @returns {Address6}\n     * @example\n     * var address = Address6.fromAddress4('192.168.0.1');\n     * address.correctForm(); // '::ffff:c0a8:1'\n     * address.to4in6(); // '::ffff:192.168.0.1'\n     */\n    static fromAddress4(address) {\n        const address4 = new ipv4_1.Address4(address);\n        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);\n        return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);\n    }\n    /**\n     * Return an address from ip6.arpa form\n     * @memberof Address6\n     * @static\n     * @param {string} arpaFormAddress - an 'ip6.arpa' form address\n     * @returns {Adress6}\n     * @example\n     * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)\n     * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'\n     */\n    static fromArpa(arpaFormAddress) {\n        // remove ending \".ip6.arpa.\" or just \".\"\n        let address = arpaFormAddress.replace(/(\\.ip6\\.arpa)?\\.$/, '');\n        const semicolonAmount = 7;\n        // correct ip6.arpa form with ending removed will be 63 characters\n        if (address.length !== 63) {\n            throw new address_error_1.AddressError(\"Invalid 'ip6.arpa' form.\");\n        }\n        const parts = address.split('.').reverse();\n        for (let i = semicolonAmount; i > 0; i--) {\n            const insertIndex = i * 4;\n            parts.splice(insertIndex, 0, ':');\n        }\n        address = parts.join('');\n        return new Address6(address);\n    }\n    /**\n     * Return the Microsoft UNC transcription of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String} the Microsoft UNC transcription of the address\n     */\n    microsoftTranscription() {\n        return (0, sprintf_js_1.sprintf)('%s.ipv6-literal.net', this.correctForm().replace(/:/g, '-'));\n    }\n    /**\n     * Return the first n bits of the address, defaulting to the subnet mask\n     * @memberof Address6\n     * @instance\n     * @param {number} [mask=subnet] - the number of bits to mask\n     * @returns {String} the first n bits of the address as a string\n     */\n    mask(mask = this.subnetMask) {\n        return this.getBitsBase2(0, mask);\n    }\n    /**\n     * Return the number of possible subnets of a given size in the address\n     * @memberof Address6\n     * @instance\n     * @param {number} [size=128] - the subnet size\n     * @returns {String}\n     */\n    // TODO: probably useful to have a numeric version of this too\n    possibleSubnets(subnetSize = 128) {\n        const availableBits = constants6.BITS - this.subnetMask;\n        const subnetBits = Math.abs(subnetSize - constants6.BITS);\n        const subnetPowers = availableBits - subnetBits;\n        if (subnetPowers < 0) {\n            return '0';\n        }\n        return addCommas(new jsbn_1.BigInteger('2', 10).pow(subnetPowers).toString(10));\n    }\n    /**\n     * Helper function getting start address.\n     * @memberof Address6\n     * @instance\n     * @returns {BigInteger}\n     */\n    _startAddress() {\n        return new jsbn_1.BigInteger(this.mask() + '0'.repeat(constants6.BITS - this.subnetMask), 2);\n    }\n    /**\n     * The first address in the range given by this address' subnet\n     * Often referred to as the Network Address.\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    startAddress() {\n        return Address6.fromBigInteger(this._startAddress());\n    }\n    /**\n     * The first host address in the range given by this address's subnet ie\n     * the first address after the Network Address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    startAddressExclusive() {\n        const adjust = new jsbn_1.BigInteger('1');\n        return Address6.fromBigInteger(this._startAddress().add(adjust));\n    }\n    /**\n     * Helper function getting end address.\n     * @memberof Address6\n     * @instance\n     * @returns {BigInteger}\n     */\n    _endAddress() {\n        return new jsbn_1.BigInteger(this.mask() + '1'.repeat(constants6.BITS - this.subnetMask), 2);\n    }\n    /**\n     * The last address in the range given by this address' subnet\n     * Often referred to as the Broadcast\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    endAddress() {\n        return Address6.fromBigInteger(this._endAddress());\n    }\n    /**\n     * The last host address in the range given by this address's subnet ie\n     * the last address prior to the Broadcast Address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    endAddressExclusive() {\n        const adjust = new jsbn_1.BigInteger('1');\n        return Address6.fromBigInteger(this._endAddress().subtract(adjust));\n    }\n    /**\n     * Return the scope of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getScope() {\n        let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];\n        if (this.getType() === 'Global unicast' && scope !== 'Link local') {\n            scope = 'Global';\n        }\n        return scope || 'Unknown';\n    }\n    /**\n     * Return the type of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getType() {\n        for (const subnet of Object.keys(constants6.TYPES)) {\n            if (this.isInSubnet(new Address6(subnet))) {\n                return constants6.TYPES[subnet];\n            }\n        }\n        return 'Global unicast';\n    }\n    /**\n     * Return the bits in the given range as a BigInteger\n     * @memberof Address6\n     * @instance\n     * @returns {BigInteger}\n     */\n    getBits(start, end) {\n        return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);\n    }\n    /**\n     * Return the bits in the given range as a base-2 string\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsBase2(start, end) {\n        return this.binaryZeroPad().slice(start, end);\n    }\n    /**\n     * Return the bits in the given range as a base-16 string\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsBase16(start, end) {\n        const length = end - start;\n        if (length % 4 !== 0) {\n            throw new Error('Length of bits to retrieve must be divisible by four');\n        }\n        return this.getBits(start, end)\n            .toString(16)\n            .padStart(length / 4, '0');\n    }\n    /**\n     * Return the bits that are set past the subnet mask length\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsPastSubnet() {\n        return this.getBitsBase2(this.subnetMask, constants6.BITS);\n    }\n    /**\n     * Return the reversed ip6.arpa form of the address\n     * @memberof Address6\n     * @param {Object} options\n     * @param {boolean} options.omitSuffix - omit the \"ip6.arpa\" suffix\n     * @instance\n     * @returns {String}\n     */\n    reverseForm(options) {\n        if (!options) {\n            options = {};\n        }\n        const characters = Math.floor(this.subnetMask / 4);\n        const reversed = this.canonicalForm()\n            .replace(/:/g, '')\n            .split('')\n            .slice(0, characters)\n            .reverse()\n            .join('.');\n        if (characters > 0) {\n            if (options.omitSuffix) {\n                return reversed;\n            }\n            return (0, sprintf_js_1.sprintf)('%s.ip6.arpa.', reversed);\n        }\n        if (options.omitSuffix) {\n            return '';\n        }\n        return 'ip6.arpa.';\n    }\n    /**\n     * Return the correct form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    correctForm() {\n        let i;\n        let groups = [];\n        let zeroCounter = 0;\n        const zeroes = [];\n        for (i = 0; i < this.parsedAddress.length; i++) {\n            const value = parseInt(this.parsedAddress[i], 16);\n            if (value === 0) {\n                zeroCounter++;\n            }\n            if (value !== 0 && zeroCounter > 0) {\n                if (zeroCounter > 1) {\n                    zeroes.push([i - zeroCounter, i - 1]);\n                }\n                zeroCounter = 0;\n            }\n        }\n        // Do we end with a string of zeroes?\n        if (zeroCounter > 1) {\n            zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);\n        }\n        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);\n        if (zeroes.length > 0) {\n            const index = zeroLengths.indexOf(Math.max(...zeroLengths));\n            groups = compact(this.parsedAddress, zeroes[index]);\n        }\n        else {\n            groups = this.parsedAddress;\n        }\n        for (i = 0; i < groups.length; i++) {\n            if (groups[i] !== 'compact') {\n                groups[i] = parseInt(groups[i], 16).toString(16);\n            }\n        }\n        let correct = groups.join(':');\n        correct = correct.replace(/^compact$/, '::');\n        correct = correct.replace(/^compact|compact$/, ':');\n        correct = correct.replace(/compact/, '');\n        return correct;\n    }\n    /**\n     * Return a zero-padded base-2 string representation of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     * @example\n     * var address = new Address6('2001:4860:4001:803::1011');\n     * address.binaryZeroPad();\n     * // '0010000000000001010010000110000001000000000000010000100000000011\n     * //  0000000000000000000000000000000000000000000000000001000000010001'\n     */\n    binaryZeroPad() {\n        return this.bigInteger().toString(2).padStart(constants6.BITS, '0');\n    }\n    // TODO: Improve the semantics of this helper function\n    parse4in6(address) {\n        const groups = address.split(':');\n        const lastGroup = groups.slice(-1)[0];\n        const address4 = lastGroup.match(constants4.RE_ADDRESS);\n        if (address4) {\n            this.parsedAddress4 = address4[0];\n            this.address4 = new ipv4_1.Address4(this.parsedAddress4);\n            for (let i = 0; i < this.address4.groups; i++) {\n                if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {\n                    throw new address_error_1.AddressError(\"IPv4 addresses can't have leading zeroes.\", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join('.')));\n                }\n            }\n            this.v4 = true;\n            groups[groups.length - 1] = this.address4.toGroup6();\n            address = groups.join(':');\n        }\n        return address;\n    }\n    // TODO: Make private?\n    parse(address) {\n        address = this.parse4in6(address);\n        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);\n        if (badCharacters) {\n            throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)('Bad character%s detected in address: %s', badCharacters.length > 1 ? 's' : '', badCharacters.join('')), address.replace(constants6.RE_BAD_CHARACTERS, '<span class=\"parse-error\">$1</span>'));\n        }\n        const badAddress = address.match(constants6.RE_BAD_ADDRESS);\n        if (badAddress) {\n            throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)('Address failed regex: %s', badAddress.join('')), address.replace(constants6.RE_BAD_ADDRESS, '<span class=\"parse-error\">$1</span>'));\n        }\n        let groups = [];\n        const halves = address.split('::');\n        if (halves.length === 2) {\n            let first = halves[0].split(':');\n            let last = halves[1].split(':');\n            if (first.length === 1 && first[0] === '') {\n                first = [];\n            }\n            if (last.length === 1 && last[0] === '') {\n                last = [];\n            }\n            const remaining = this.groups - (first.length + last.length);\n            if (!remaining) {\n                throw new address_error_1.AddressError('Error parsing groups');\n            }\n            this.elidedGroups = remaining;\n            this.elisionBegin = first.length;\n            this.elisionEnd = first.length + this.elidedGroups;\n            groups = groups.concat(first);\n            for (let i = 0; i < remaining; i++) {\n                groups.push('0');\n            }\n            groups = groups.concat(last);\n        }\n        else if (halves.length === 1) {\n            groups = address.split(':');\n            this.elidedGroups = 0;\n        }\n        else {\n            throw new address_error_1.AddressError('Too many :: groups found');\n        }\n        groups = groups.map((group) => (0, sprintf_js_1.sprintf)('%x', parseInt(group, 16)));\n        if (groups.length !== this.groups) {\n            throw new address_error_1.AddressError('Incorrect number of groups found');\n        }\n        return groups;\n    }\n    /**\n     * Return the canonical form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    canonicalForm() {\n        return this.parsedAddress.map(paddedHex).join(':');\n    }\n    /**\n     * Return the decimal form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    decimal() {\n        return this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)('%05d', parseInt(n, 16))).join(':');\n    }\n    /**\n     * Return the address as a BigInteger\n     * @memberof Address6\n     * @instance\n     * @returns {BigInteger}\n     */\n    bigInteger() {\n        return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(''), 16);\n    }\n    /**\n     * Return the last two groups of this address as an IPv4 address string\n     * @memberof Address6\n     * @instance\n     * @returns {Address4}\n     * @example\n     * var address = new Address6('2001:4860:4001::1825:bf11');\n     * address.to4().correctForm(); // '24.37.191.17'\n     */\n    to4() {\n        const binary = this.binaryZeroPad().split('');\n        return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(''), 2).toString(16));\n    }\n    /**\n     * Return the v4-in-v6 form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    to4in6() {\n        const address4 = this.to4();\n        const address6 = new Address6(this.parsedAddress.slice(0, 6).join(':'), 6);\n        const correct = address6.correctForm();\n        let infix = '';\n        if (!/:$/.test(correct)) {\n            infix = ':';\n        }\n        return correct + infix + address4.address;\n    }\n    /**\n     * Return an object containing the Teredo properties of the address\n     * @memberof Address6\n     * @instance\n     * @returns {Object}\n     */\n    inspectTeredo() {\n        /*\n        - Bits 0 to 31 are set to the Teredo prefix (normally 2001:0000::/32).\n        - Bits 32 to 63 embed the primary IPv4 address of the Teredo server that\n          is used.\n        - Bits 64 to 79 can be used to define some flags. Currently only the\n          higher order bit is used; it is set to 1 if the Teredo client is\n          located behind a cone NAT, 0 otherwise. For Microsoft's Windows Vista\n          and Windows Server 2008 implementations, more bits are used. In those\n          implementations, the format for these 16 bits is \"CRAAAAUG AAAAAAAA\",\n          where \"C\" remains the \"Cone\" flag. The \"R\" bit is reserved for future\n          use. The \"U\" bit is for the Universal/Local flag (set to 0). The \"G\" bit\n          is Individual/Group flag (set to 0). The A bits are set to a 12-bit\n          randomly generated number chosen by the Teredo client to introduce\n          additional protection for the Teredo node against IPv6-based scanning\n          attacks.\n        - Bits 80 to 95 contains the obfuscated UDP port number. This is the\n          port number that is mapped by the NAT to the Teredo client with all\n          bits inverted.\n        - Bits 96 to 127 contains the obfuscated IPv4 address. This is the\n          public IPv4 address of the NAT with all bits inverted.\n        */\n        const prefix = this.getBitsBase16(0, 32);\n        const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger('ffff', 16)).toString();\n        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));\n        const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger('ffffffff', 16)).toString(16));\n        const flags = this.getBits(64, 80);\n        const flagsBase2 = this.getBitsBase2(64, 80);\n        const coneNat = flags.testBit(15);\n        const reserved = flags.testBit(14);\n        const groupIndividual = flags.testBit(8);\n        const universalLocal = flags.testBit(9);\n        const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);\n        return {\n            prefix: (0, sprintf_js_1.sprintf)('%s:%s', prefix.slice(0, 4), prefix.slice(4, 8)),\n            server4: server4.address,\n            client4: client4.address,\n            flags: flagsBase2,\n            coneNat,\n            microsoft: {\n                reserved,\n                universalLocal,\n                groupIndividual,\n                nonce,\n            },\n            udpPort,\n        };\n    }\n    /**\n     * Return an object containing the 6to4 properties of the address\n     * @memberof Address6\n     * @instance\n     * @returns {Object}\n     */\n    inspect6to4() {\n        /*\n        - Bits 0 to 15 are set to the 6to4 prefix (2002::/16).\n        - Bits 16 to 48 embed the IPv4 address of the 6to4 gateway that is used.\n        */\n        const prefix = this.getBitsBase16(0, 16);\n        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));\n        return {\n            prefix: (0, sprintf_js_1.sprintf)('%s', prefix.slice(0, 4)),\n            gateway: gateway.address,\n        };\n    }\n    /**\n     * Return a v6 6to4 address from a v6 v4inv6 address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    to6to4() {\n        if (!this.is4()) {\n            return null;\n        }\n        const addr6to4 = [\n            '2002',\n            this.getBitsBase16(96, 112),\n            this.getBitsBase16(112, 128),\n            '',\n            '/16',\n        ].join(':');\n        return new Address6(addr6to4);\n    }\n    /**\n     * Return a byte array\n     * @memberof Address6\n     * @instance\n     * @returns {Array}\n     */\n    toByteArray() {\n        const byteArray = this.bigInteger().toByteArray();\n        // work around issue where `toByteArray` returns a leading 0 element\n        if (byteArray.length === 17 && byteArray[0] === 0) {\n            return byteArray.slice(1);\n        }\n        return byteArray;\n    }\n    /**\n     * Return an unsigned byte array\n     * @memberof Address6\n     * @instance\n     * @returns {Array}\n     */\n    toUnsignedByteArray() {\n        return this.toByteArray().map(unsignByte);\n    }\n    /**\n     * Convert a byte array to an Address6 object\n     * @memberof Address6\n     * @static\n     * @returns {Address6}\n     */\n    static fromByteArray(bytes) {\n        return this.fromUnsignedByteArray(bytes.map(unsignByte));\n    }\n    /**\n     * Convert an unsigned byte array to an Address6 object\n     * @memberof Address6\n     * @static\n     * @returns {Address6}\n     */\n    static fromUnsignedByteArray(bytes) {\n        const BYTE_MAX = new jsbn_1.BigInteger('256', 10);\n        let result = new jsbn_1.BigInteger('0', 10);\n        let multiplier = new jsbn_1.BigInteger('1', 10);\n        for (let i = bytes.length - 1; i >= 0; i--) {\n            result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));\n            multiplier = multiplier.multiply(BYTE_MAX);\n        }\n        return Address6.fromBigInteger(result);\n    }\n    /**\n     * Returns true if the address is in the canonical form, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isCanonical() {\n        return this.addressMinusSuffix === this.canonicalForm();\n    }\n    /**\n     * Returns true if the address is a link local address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isLinkLocal() {\n        // Zeroes are required, i.e. we can't check isInSubnet with 'fe80::/10'\n        if (this.getBitsBase2(0, 64) ===\n            '1111111010000000000000000000000000000000000000000000000000000000') {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns true if the address is a multicast address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isMulticast() {\n        return this.getType() === 'Multicast';\n    }\n    /**\n     * Returns true if the address is a v4-in-v6 address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    is4() {\n        return this.v4;\n    }\n    /**\n     * Returns true if the address is a Teredo address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isTeredo() {\n        return this.isInSubnet(new Address6('2001::/32'));\n    }\n    /**\n     * Returns true if the address is a 6to4 address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    is6to4() {\n        return this.isInSubnet(new Address6('2002::/16'));\n    }\n    /**\n     * Returns true if the address is a loopback address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isLoopback() {\n        return this.getType() === 'Loopback';\n    }\n    // #endregion\n    // #region HTML\n    /**\n     * @returns {String} the address in link form with a default port of 80\n     */\n    href(optionalPort) {\n        if (optionalPort === undefined) {\n            optionalPort = '';\n        }\n        else {\n            optionalPort = (0, sprintf_js_1.sprintf)(':%s', optionalPort);\n        }\n        return (0, sprintf_js_1.sprintf)('http://[%s]%s/', this.correctForm(), optionalPort);\n    }\n    /**\n     * @returns {String} a link suitable for conveying the address via a URL hash\n     */\n    link(options) {\n        if (!options) {\n            options = {};\n        }\n        if (options.className === undefined) {\n            options.className = '';\n        }\n        if (options.prefix === undefined) {\n            options.prefix = '/#address=';\n        }\n        if (options.v4 === undefined) {\n            options.v4 = false;\n        }\n        let formFunction = this.correctForm;\n        if (options.v4) {\n            formFunction = this.to4in6;\n        }\n        if (options.className) {\n            return (0, sprintf_js_1.sprintf)('<a href=\"%1$s%2$s\" class=\"%3$s\">%2$s</a>', options.prefix, formFunction.call(this), options.className);\n        }\n        return (0, sprintf_js_1.sprintf)('<a href=\"%1$s%2$s\">%2$s</a>', options.prefix, formFunction.call(this));\n    }\n    /**\n     * Groups an address\n     * @returns {String}\n     */\n    group() {\n        if (this.elidedGroups === 0) {\n            // The simple case\n            return helpers.simpleGroup(this.address).join(':');\n        }\n        assert(typeof this.elidedGroups === 'number');\n        assert(typeof this.elisionBegin === 'number');\n        // The elided case\n        const output = [];\n        const [left, right] = this.address.split('::');\n        if (left.length) {\n            output.push(...helpers.simpleGroup(left));\n        }\n        else {\n            output.push('');\n        }\n        const classes = ['hover-group'];\n        for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {\n            classes.push((0, sprintf_js_1.sprintf)('group-%d', i));\n        }\n        output.push((0, sprintf_js_1.sprintf)('<span class=\"%s\"></span>', classes.join(' ')));\n        if (right.length) {\n            output.push(...helpers.simpleGroup(right, this.elisionEnd));\n        }\n        else {\n            output.push('');\n        }\n        if (this.is4()) {\n            assert(this.address4 instanceof ipv4_1.Address4);\n            output.pop();\n            output.push(this.address4.groupForV6());\n        }\n        return output.join(':');\n    }\n    // #endregion\n    // #region Regular expressions\n    /**\n     * Generate a regular expression string that can be used to find or validate\n     * all variations of this address\n     * @memberof Address6\n     * @instance\n     * @param {boolean} substringSearch\n     * @returns {string}\n     */\n    regularExpressionString(substringSearch = false) {\n        let output = [];\n        // TODO: revisit why this is necessary\n        const address6 = new Address6(this.correctForm());\n        if (address6.elidedGroups === 0) {\n            // The simple case\n            output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));\n        }\n        else if (address6.elidedGroups === constants6.GROUPS) {\n            // A completely elided address\n            output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));\n        }\n        else {\n            // A partially elided address\n            const halves = address6.address.split('::');\n            if (halves[0].length) {\n                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(':')));\n            }\n            assert(typeof address6.elidedGroups === 'number');\n            output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));\n            if (halves[1].length) {\n                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(':')));\n            }\n            output = [output.join(':')];\n        }\n        if (!substringSearch) {\n            output = [\n                '(?=^|',\n                regular_expressions_1.ADDRESS_BOUNDARY,\n                '|[^\\\\w\\\\:])(',\n                ...output,\n                ')(?=[^\\\\w\\\\:]|',\n                regular_expressions_1.ADDRESS_BOUNDARY,\n                '|$)',\n            ];\n        }\n        return output.join('');\n    }\n    /**\n     * Generate a regular expression that can be used to find or validate all\n     * variations of this address.\n     * @memberof Address6\n     * @instance\n     * @param {boolean} substringSearch\n     * @returns {RegExp}\n     */\n    regularExpression(substringSearch = false) {\n        return new RegExp(this.regularExpressionString(substringSearch), 'i');\n    }\n}\nexports.Address6 = Address6;\n//# sourceMappingURL=ipv6.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2lwdjYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsNEJBQTRCLG1CQUFPLENBQUMsZ0VBQVU7QUFDOUMsZ0NBQWdDLG1CQUFPLENBQUMsNEVBQWdCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUN4RCw2QkFBNkIsbUJBQU8sQ0FBQyx3RUFBYztBQUNuRCxlQUFlLG1CQUFPLENBQUMsNERBQVE7QUFDL0IsOEJBQThCLG1CQUFPLENBQUMsZ0dBQTBCO0FBQ2hFLHdCQUF3QixtQkFBTyxDQUFDLDhFQUFpQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsZ0RBQU07QUFDN0IscUJBQXFCLG1CQUFPLENBQUMsa0VBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCLEdBQUcsTUFBTTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkNBQTJDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jczItc2tpbi10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2lwLWFkZHJlc3MvZGlzdC9pcHY2LmpzPzFlMGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzNiA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb21tb25cIikpO1xuY29uc3QgY29uc3RhbnRzNCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92NC9jb25zdGFudHNcIikpO1xuY29uc3QgY29uc3RhbnRzNiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92Ni9jb25zdGFudHNcIikpO1xuY29uc3QgaGVscGVycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi92Ni9oZWxwZXJzXCIpKTtcbmNvbnN0IGlwdjRfMSA9IHJlcXVpcmUoXCIuL2lwdjRcIik7XG5jb25zdCByZWd1bGFyX2V4cHJlc3Npb25zXzEgPSByZXF1aXJlKFwiLi92Ni9yZWd1bGFyLWV4cHJlc3Npb25zXCIpO1xuY29uc3QgYWRkcmVzc19lcnJvcl8xID0gcmVxdWlyZShcIi4vYWRkcmVzcy1lcnJvclwiKTtcbmNvbnN0IGpzYm5fMSA9IHJlcXVpcmUoXCJqc2JuXCIpO1xuY29uc3Qgc3ByaW50Zl9qc18xID0gcmVxdWlyZShcInNwcmludGYtanNcIik7XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZENvbW1hcyhudW1iZXIpIHtcbiAgICBjb25zdCByID0gLyhcXGQrKShcXGR7M30pLztcbiAgICB3aGlsZSAoci50ZXN0KG51bWJlcikpIHtcbiAgICAgICAgbnVtYmVyID0gbnVtYmVyLnJlcGxhY2UociwgJyQxLCQyJyk7XG4gICAgfVxuICAgIHJldHVybiBudW1iZXI7XG59XG5mdW5jdGlvbiBzcGFuTGVhZGluZ1plcm9lczQobikge1xuICAgIG4gPSBuLnJlcGxhY2UoL14oMHsxLH0pKFsxLTldKykkLywgJzxzcGFuIGNsYXNzPVwicGFyc2UtZXJyb3JcIj4kMTwvc3Bhbj4kMicpO1xuICAgIG4gPSBuLnJlcGxhY2UoL14oMHsxLH0pKDApJC8sICc8c3BhbiBjbGFzcz1cInBhcnNlLWVycm9yXCI+JDE8L3NwYW4+JDInKTtcbiAgICByZXR1cm4gbjtcbn1cbi8qXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBjb21wYWN0IGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNvbXBhY3QoYWRkcmVzcywgc2xpY2UpIHtcbiAgICBjb25zdCBzMSA9IFtdO1xuICAgIGNvbnN0IHMyID0gW107XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCBzbGljZVswXSkge1xuICAgICAgICAgICAgczEucHVzaChhZGRyZXNzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpID4gc2xpY2VbMV0pIHtcbiAgICAgICAgICAgIHMyLnB1c2goYWRkcmVzc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHMxLmNvbmNhdChbJ2NvbXBhY3QnXSkuY29uY2F0KHMyKTtcbn1cbmZ1bmN0aW9uIHBhZGRlZEhleChvY3RldCkge1xuICAgIHJldHVybiAoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCclMDR4JywgcGFyc2VJbnQob2N0ZXQsIDE2KSk7XG59XG5mdW5jdGlvbiB1bnNpZ25CeXRlKGIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIHJldHVybiBiICYgMHhmZjtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJUHY2IGFkZHJlc3NcbiAqIEBjbGFzcyBBZGRyZXNzNlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBBbiBJUHY2IGFkZHJlc3Mgc3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gW2dyb3Vwcz04XSAtIEhvdyBtYW55IG9jdGV0cyB0byBwYXJzZVxuICogQGV4YW1wbGVcbiAqIHZhciBhZGRyZXNzID0gbmV3IEFkZHJlc3M2KCcyMDAxOjovMzInKTtcbiAqL1xuY2xhc3MgQWRkcmVzczYge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIG9wdGlvbmFsR3JvdXBzKSB7XG4gICAgICAgIHRoaXMuYWRkcmVzc01pbnVzU3VmZml4ID0gJyc7XG4gICAgICAgIHRoaXMucGFyc2VkU3VibmV0ID0gJyc7XG4gICAgICAgIHRoaXMuc3VibmV0ID0gJy8xMjgnO1xuICAgICAgICB0aGlzLnN1Ym5ldE1hc2sgPSAxMjg7XG4gICAgICAgIHRoaXMudjQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy56b25lID0gJyc7XG4gICAgICAgIC8vICNyZWdpb24gQXR0cmlidXRlc1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBhZGRyZXNzIGlzIGluIHRoZSBzdWJuZXQgb2YgdGhlIGN1cnJlbnQgYWRkcmVzc1xuICAgICAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0luU3VibmV0ID0gY29tbW9uLmlzSW5TdWJuZXQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ29ycmVjdCA9IGNvbW1vbi5pc0NvcnJlY3QoY29uc3RhbnRzNi5CSVRTKTtcbiAgICAgICAgaWYgKG9wdGlvbmFsR3JvdXBzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0gY29uc3RhbnRzNi5HUk9VUFM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwcyA9IG9wdGlvbmFsR3JvdXBzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIGNvbnN0IHN1Ym5ldCA9IGNvbnN0YW50czYuUkVfU1VCTkVUX1NUUklORy5leGVjKGFkZHJlc3MpO1xuICAgICAgICBpZiAoc3VibmV0KSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFN1Ym5ldCA9IHN1Ym5ldFswXS5yZXBsYWNlKCcvJywgJycpO1xuICAgICAgICAgICAgdGhpcy5zdWJuZXRNYXNrID0gcGFyc2VJbnQodGhpcy5wYXJzZWRTdWJuZXQsIDEwKTtcbiAgICAgICAgICAgIHRoaXMuc3VibmV0ID0gYC8ke3RoaXMuc3VibmV0TWFza31gO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTih0aGlzLnN1Ym5ldE1hc2spIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJuZXRNYXNrIDwgMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3VibmV0TWFzayA+IGNvbnN0YW50czYuQklUUykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKCdJbnZhbGlkIHN1Ym5ldCBtYXNrLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZShjb25zdGFudHM2LlJFX1NVQk5FVF9TVFJJTkcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXFwvLy50ZXN0KGFkZHJlc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcignSW52YWxpZCBzdWJuZXQgbWFzay4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB6b25lID0gY29uc3RhbnRzNi5SRV9aT05FX1NUUklORy5leGVjKGFkZHJlc3MpO1xuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgICAgdGhpcy56b25lID0gem9uZVswXTtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoY29uc3RhbnRzNi5SRV9aT05FX1NUUklORywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzc01pbnVzU3VmZml4ID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5wYXJzZWRBZGRyZXNzID0gdGhpcy5wYXJzZSh0aGlzLmFkZHJlc3NNaW51c1N1ZmZpeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkKGFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICAgICAgICAgIG5ldyBBZGRyZXNzNihhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIEJpZ0ludGVnZXIgdG8gYSB2NiBhZGRyZXNzIG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0JpZ0ludGVnZXJ9IGJpZ0ludGVnZXIgLSBhIEJpZ0ludGVnZXIgdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBiaWdJbnRlZ2VyID0gbmV3IEJpZ0ludGVnZXIoJzEwMDAwMDAwMDAwMDAnKTtcbiAgICAgKiB2YXIgYWRkcmVzcyA9IEFkZHJlc3M2LmZyb21CaWdJbnRlZ2VyKGJpZ0ludGVnZXIpO1xuICAgICAqIGFkZHJlc3MuY29ycmVjdEZvcm0oKTsgLy8gJzo6ZTg6ZDRhNToxMDAwJ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmlnSW50ZWdlcihiaWdJbnRlZ2VyKSB7XG4gICAgICAgIGNvbnN0IGhleCA9IGJpZ0ludGVnZXIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDMyLCAnMCcpO1xuICAgICAgICBjb25zdCBncm91cHMgPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25zdGFudHM2LkdST1VQUzsgaSsrKSB7XG4gICAgICAgICAgICBncm91cHMucHVzaChoZXguc2xpY2UoaSAqIDQsIChpICsgMSkgKiA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzNihncm91cHMuam9pbignOicpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIFVSTCAod2l0aCBvcHRpb25hbCBwb3J0IG51bWJlcikgdG8gYW4gYWRkcmVzcyBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIGEgVVJMIHdpdGggb3B0aW9uYWwgcG9ydCBudW1iZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhZGRyZXNzQW5kUG9ydCA9IEFkZHJlc3M2LmZyb21VUkwoJ2h0dHA6Ly9bZmZmZjo6XTo4MDgwL2Zvby8nKTtcbiAgICAgKiBhZGRyZXNzQW5kUG9ydC5hZGRyZXNzLmNvcnJlY3RGb3JtKCk7IC8vICdmZmZmOjonXG4gICAgICogYWRkcmVzc0FuZFBvcnQucG9ydDsgLy8gODA4MFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVVJMKHVybCkge1xuICAgICAgICBsZXQgaG9zdDtcbiAgICAgICAgbGV0IHBvcnQgPSBudWxsO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGJyYWNrZXRzIHBhcnNlIHRoZW0gYW5kIGZpbmQgYSBwb3J0XG4gICAgICAgIGlmICh1cmwuaW5kZXhPZignWycpICE9PSAtMSAmJiB1cmwuaW5kZXhPZignXTonKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnN0YW50czYuUkVfVVJMX1dJVEhfUE9SVC5leGVjKHVybCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdmYWlsZWQgdG8gcGFyc2UgYWRkcmVzcyB3aXRoIHBvcnQnLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3N0ID0gcmVzdWx0WzFdO1xuICAgICAgICAgICAgcG9ydCA9IHJlc3VsdFsyXTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBVUkwgZXh0cmFjdCB0aGUgYWRkcmVzc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVybC5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHByb3RvY29sIHByZWZpeFxuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15bYS16MC05XSs6XFwvXFwvLywgJycpO1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnN0YW50czYuUkVfVVJMLmV4ZWModXJsKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ2ZhaWxlZCB0byBwYXJzZSBhZGRyZXNzIGZyb20gVVJMJyxcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG9zdCA9IHJlc3VsdFsxXTtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGFzc2lnbiB0aGUgVVJMIHRvIHRoZSBob3N0IGFuZCBsZXQgdGhlIGxpYnJhcnkgcGFyc2UgaXRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3QgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHBvcnQgY29udmVydCBpdCB0byBhbiBpbnRlZ2VyXG4gICAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgICAgICBwb3J0ID0gcGFyc2VJbnQocG9ydCwgMTApO1xuICAgICAgICAgICAgLy8gc3F1ZWxjaCBvdXQgb2YgcmFuZ2UgcG9ydHNcbiAgICAgICAgICAgIGlmIChwb3J0IDwgMCB8fCBwb3J0ID4gNjU1MzYpIHtcbiAgICAgICAgICAgICAgICBwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN0YW5kYXJkaXplIGB1bmRlZmluZWRgIHRvIGBudWxsYFxuICAgICAgICAgICAgcG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IG5ldyBBZGRyZXNzNihob3N0KSxcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBJUHY2LW1hcHBlZCBhZGRyZXNzIGdpdmVuIGFuIElQdjQgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEFuIElQdjQgYWRkcmVzcyBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYWRkcmVzcyA9IEFkZHJlc3M2LmZyb21BZGRyZXNzNCgnMTkyLjE2OC4wLjEnKTtcbiAgICAgKiBhZGRyZXNzLmNvcnJlY3RGb3JtKCk7IC8vICc6OmZmZmY6YzBhODoxJ1xuICAgICAqIGFkZHJlc3MudG80aW42KCk7IC8vICc6OmZmZmY6MTkyLjE2OC4wLjEnXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BZGRyZXNzNChhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3M0ID0gbmV3IGlwdjRfMS5BZGRyZXNzNChhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgbWFzazYgPSBjb25zdGFudHM2LkJJVFMgLSAoY29uc3RhbnRzNC5CSVRTIC0gYWRkcmVzczQuc3VibmV0TWFzayk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzczYoYDo6ZmZmZjoke2FkZHJlc3M0LmNvcnJlY3RGb3JtKCl9LyR7bWFzazZ9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhZGRyZXNzIGZyb20gaXA2LmFycGEgZm9ybVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJwYUZvcm1BZGRyZXNzIC0gYW4gJ2lwNi5hcnBhJyBmb3JtIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7QWRyZXNzNn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhZGRyZXNzID0gQWRkcmVzczYuZnJvbUFycGEoZS5mLmYuZi4zLmMuMi42LmYuZi5mLmUuNi42LjguZS4xLjAuNi43LjkuNC5lLmMuMC4wLjAuMC4xLjAuMC4yLmlwNi5hcnBhLilcbiAgICAgKiBhZGRyZXNzLmNvcnJlY3RGb3JtKCk7IC8vICcyMDAxOjA6Y2U0OTo3NjAxOmU4NjY6ZWZmZjo2MmMzOmZmZmUnXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BcnBhKGFycGFGb3JtQWRkcmVzcykge1xuICAgICAgICAvLyByZW1vdmUgZW5kaW5nIFwiLmlwNi5hcnBhLlwiIG9yIGp1c3QgXCIuXCJcbiAgICAgICAgbGV0IGFkZHJlc3MgPSBhcnBhRm9ybUFkZHJlc3MucmVwbGFjZSgvKFxcLmlwNlxcLmFycGEpP1xcLiQvLCAnJyk7XG4gICAgICAgIGNvbnN0IHNlbWljb2xvbkFtb3VudCA9IDc7XG4gICAgICAgIC8vIGNvcnJlY3QgaXA2LmFycGEgZm9ybSB3aXRoIGVuZGluZyByZW1vdmVkIHdpbGwgYmUgNjMgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoYWRkcmVzcy5sZW5ndGggIT09IDYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcihcIkludmFsaWQgJ2lwNi5hcnBhJyBmb3JtLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJy4nKS5yZXZlcnNlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzZW1pY29sb25BbW91bnQ7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGluc2VydEluZGV4ID0gaSAqIDQ7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsICc6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzcyA9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3M2KGFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIE1pY3Jvc29mdCBVTkMgdHJhbnNjcmlwdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBNaWNyb3NvZnQgVU5DIHRyYW5zY3JpcHRpb24gb2YgdGhlIGFkZHJlc3NcbiAgICAgKi9cbiAgICBtaWNyb3NvZnRUcmFuc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnJXMuaXB2Ni1saXRlcmFsLm5ldCcsIHRoaXMuY29ycmVjdEZvcm0oKS5yZXBsYWNlKC86L2csICctJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGZpcnN0IG4gYml0cyBvZiB0aGUgYWRkcmVzcywgZGVmYXVsdGluZyB0byB0aGUgc3VibmV0IG1hc2tcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21hc2s9c3VibmV0XSAtIHRoZSBudW1iZXIgb2YgYml0cyB0byBtYXNrXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIGZpcnN0IG4gYml0cyBvZiB0aGUgYWRkcmVzcyBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIG1hc2sobWFzayA9IHRoaXMuc3VibmV0TWFzaykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCaXRzQmFzZTIoMCwgbWFzayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHBvc3NpYmxlIHN1Ym5ldHMgb2YgYSBnaXZlbiBzaXplIGluIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTEyOF0gLSB0aGUgc3VibmV0IHNpemVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIC8vIFRPRE86IHByb2JhYmx5IHVzZWZ1bCB0byBoYXZlIGEgbnVtZXJpYyB2ZXJzaW9uIG9mIHRoaXMgdG9vXG4gICAgcG9zc2libGVTdWJuZXRzKHN1Ym5ldFNpemUgPSAxMjgpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlQml0cyA9IGNvbnN0YW50czYuQklUUyAtIHRoaXMuc3VibmV0TWFzaztcbiAgICAgICAgY29uc3Qgc3VibmV0Qml0cyA9IE1hdGguYWJzKHN1Ym5ldFNpemUgLSBjb25zdGFudHM2LkJJVFMpO1xuICAgICAgICBjb25zdCBzdWJuZXRQb3dlcnMgPSBhdmFpbGFibGVCaXRzIC0gc3VibmV0Qml0cztcbiAgICAgICAgaWYgKHN1Ym5ldFBvd2VycyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZENvbW1hcyhuZXcganNibl8xLkJpZ0ludGVnZXIoJzInLCAxMCkucG93KHN1Ym5ldFBvd2VycykudG9TdHJpbmcoMTApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGdldHRpbmcgc3RhcnQgYWRkcmVzcy5cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QmlnSW50ZWdlcn1cbiAgICAgKi9cbiAgICBfc3RhcnRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGpzYm5fMS5CaWdJbnRlZ2VyKHRoaXMubWFzaygpICsgJzAnLnJlcGVhdChjb25zdGFudHM2LkJJVFMgLSB0aGlzLnN1Ym5ldE1hc2spLCAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcycgc3VibmV0XG4gICAgICogT2Z0ZW4gcmVmZXJyZWQgdG8gYXMgdGhlIE5ldHdvcmsgQWRkcmVzcy5cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICovXG4gICAgc3RhcnRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQWRkcmVzczYuZnJvbUJpZ0ludGVnZXIodGhpcy5fc3RhcnRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgaG9zdCBhZGRyZXNzIGluIHRoZSByYW5nZSBnaXZlbiBieSB0aGlzIGFkZHJlc3MncyBzdWJuZXQgaWVcbiAgICAgKiB0aGUgZmlyc3QgYWRkcmVzcyBhZnRlciB0aGUgTmV0d29yayBBZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M2fVxuICAgICAqL1xuICAgIHN0YXJ0QWRkcmVzc0V4Y2x1c2l2ZSgpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ID0gbmV3IGpzYm5fMS5CaWdJbnRlZ2VyKCcxJyk7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNi5mcm9tQmlnSW50ZWdlcih0aGlzLl9zdGFydEFkZHJlc3MoKS5hZGQoYWRqdXN0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBnZXR0aW5nIGVuZCBhZGRyZXNzLlxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtCaWdJbnRlZ2VyfVxuICAgICAqL1xuICAgIF9lbmRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGpzYm5fMS5CaWdJbnRlZ2VyKHRoaXMubWFzaygpICsgJzEnLnJlcGVhdChjb25zdGFudHM2LkJJVFMgLSB0aGlzLnN1Ym5ldE1hc2spLCAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxhc3QgYWRkcmVzcyBpbiB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhpcyBhZGRyZXNzJyBzdWJuZXRcbiAgICAgKiBPZnRlbiByZWZlcnJlZCB0byBhcyB0aGUgQnJvYWRjYXN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M2fVxuICAgICAqL1xuICAgIGVuZEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNi5mcm9tQmlnSW50ZWdlcih0aGlzLl9lbmRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBob3N0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcydzIHN1Ym5ldCBpZVxuICAgICAqIHRoZSBsYXN0IGFkZHJlc3MgcHJpb3IgdG8gdGhlIEJyb2FkY2FzdCBBZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M2fVxuICAgICAqL1xuICAgIGVuZEFkZHJlc3NFeGNsdXNpdmUoKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdCA9IG5ldyBqc2JuXzEuQmlnSW50ZWdlcignMScpO1xuICAgICAgICByZXR1cm4gQWRkcmVzczYuZnJvbUJpZ0ludGVnZXIodGhpcy5fZW5kQWRkcmVzcygpLnN1YnRyYWN0KGFkanVzdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHNjb3BlIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTY29wZSgpIHtcbiAgICAgICAgbGV0IHNjb3BlID0gY29uc3RhbnRzNi5TQ09QRVNbdGhpcy5nZXRCaXRzKDEyLCAxNikuaW50VmFsdWUoKV07XG4gICAgICAgIGlmICh0aGlzLmdldFR5cGUoKSA9PT0gJ0dsb2JhbCB1bmljYXN0JyAmJiBzY29wZSAhPT0gJ0xpbmsgbG9jYWwnKSB7XG4gICAgICAgICAgICBzY29wZSA9ICdHbG9iYWwnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29wZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdHlwZSBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJuZXQgb2YgT2JqZWN0LmtleXMoY29uc3RhbnRzNi5UWVBFUykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5TdWJuZXQobmV3IEFkZHJlc3M2KHN1Ym5ldCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50czYuVFlQRVNbc3VibmV0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0dsb2JhbCB1bmljYXN0JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaXRzIGluIHRoZSBnaXZlbiByYW5nZSBhcyBhIEJpZ0ludGVnZXJcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QmlnSW50ZWdlcn1cbiAgICAgKi9cbiAgICBnZXRCaXRzKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBqc2JuXzEuQmlnSW50ZWdlcih0aGlzLmdldEJpdHNCYXNlMihzdGFydCwgZW5kKSwgMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYml0cyBpbiB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBiYXNlLTIgc3RyaW5nXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRCaXRzQmFzZTIoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlaZXJvUGFkKCkuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYml0cyBpbiB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBiYXNlLTE2IHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Qml0c0Jhc2UxNihzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBpZiAobGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggb2YgYml0cyB0byByZXRyaWV2ZSBtdXN0IGJlIGRpdmlzaWJsZSBieSBmb3VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0cyhzdGFydCwgZW5kKVxuICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgLnBhZFN0YXJ0KGxlbmd0aCAvIDQsICcwJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYml0cyB0aGF0IGFyZSBzZXQgcGFzdCB0aGUgc3VibmV0IG1hc2sgbGVuZ3RoXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRCaXRzUGFzdFN1Ym5ldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0c0Jhc2UyKHRoaXMuc3VibmV0TWFzaywgY29uc3RhbnRzNi5CSVRTKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZXZlcnNlZCBpcDYuYXJwYSBmb3JtIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMub21pdFN1ZmZpeCAtIG9taXQgdGhlIFwiaXA2LmFycGFcIiBzdWZmaXhcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJldmVyc2VGb3JtKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IE1hdGguZmxvb3IodGhpcy5zdWJuZXRNYXNrIC8gNCk7XG4gICAgICAgIGNvbnN0IHJldmVyc2VkID0gdGhpcy5jYW5vbmljYWxGb3JtKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC86L2csICcnKVxuICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgLnNsaWNlKDAsIGNoYXJhY3RlcnMpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAuam9pbignLicpO1xuICAgICAgICBpZiAoY2hhcmFjdGVycyA+IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9taXRTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2ZXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnJXMuaXA2LmFycGEuJywgcmV2ZXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9taXRTdWZmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2lwNi5hcnBhLic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY29ycmVjdCBmb3JtIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBjb3JyZWN0Rm9ybSgpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBncm91cHMgPSBbXTtcbiAgICAgICAgbGV0IHplcm9Db3VudGVyID0gMDtcbiAgICAgICAgY29uc3QgemVyb2VzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBhcnNlZEFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQodGhpcy5wYXJzZWRBZGRyZXNzW2ldLCAxNik7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB6ZXJvQ291bnRlcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHplcm9Db3VudGVyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh6ZXJvQ291bnRlciA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgemVyb2VzLnB1c2goW2kgLSB6ZXJvQ291bnRlciwgaSAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgemVyb0NvdW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERvIHdlIGVuZCB3aXRoIGEgc3RyaW5nIG9mIHplcm9lcz9cbiAgICAgICAgaWYgKHplcm9Db3VudGVyID4gMSkge1xuICAgICAgICAgICAgemVyb2VzLnB1c2goW3RoaXMucGFyc2VkQWRkcmVzcy5sZW5ndGggLSB6ZXJvQ291bnRlciwgdGhpcy5wYXJzZWRBZGRyZXNzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB6ZXJvTGVuZ3RocyA9IHplcm9lcy5tYXAoKG4pID0+IG5bMV0gLSBuWzBdICsgMSk7XG4gICAgICAgIGlmICh6ZXJvZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB6ZXJvTGVuZ3Rocy5pbmRleE9mKE1hdGgubWF4KC4uLnplcm9MZW5ndGhzKSk7XG4gICAgICAgICAgICBncm91cHMgPSBjb21wYWN0KHRoaXMucGFyc2VkQWRkcmVzcywgemVyb2VzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBncm91cHMgPSB0aGlzLnBhcnNlZEFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGdyb3Vwc1tpXSAhPT0gJ2NvbXBhY3QnKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2ldID0gcGFyc2VJbnQoZ3JvdXBzW2ldLCAxNikudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb3JyZWN0ID0gZ3JvdXBzLmpvaW4oJzonKTtcbiAgICAgICAgY29ycmVjdCA9IGNvcnJlY3QucmVwbGFjZSgvXmNvbXBhY3QkLywgJzo6Jyk7XG4gICAgICAgIGNvcnJlY3QgPSBjb3JyZWN0LnJlcGxhY2UoL15jb21wYWN0fGNvbXBhY3QkLywgJzonKTtcbiAgICAgICAgY29ycmVjdCA9IGNvcnJlY3QucmVwbGFjZSgvY29tcGFjdC8sICcnKTtcbiAgICAgICAgcmV0dXJuIGNvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHplcm8tcGFkZGVkIGJhc2UtMiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGFkZHJlc3MgPSBuZXcgQWRkcmVzczYoJzIwMDE6NDg2MDo0MDAxOjgwMzo6MTAxMScpO1xuICAgICAqIGFkZHJlc3MuYmluYXJ5WmVyb1BhZCgpO1xuICAgICAqIC8vICcwMDEwMDAwMDAwMDAwMDAxMDEwMDEwMDAwMTEwMDAwMDAxMDAwMDAwMDAwMDAwMDEwMDAwMTAwMDAwMDAwMDExXG4gICAgICogLy8gIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMTAwMDEnXG4gICAgICovXG4gICAgYmluYXJ5WmVyb1BhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmlnSW50ZWdlcigpLnRvU3RyaW5nKDIpLnBhZFN0YXJ0KGNvbnN0YW50czYuQklUUywgJzAnKTtcbiAgICB9XG4gICAgLy8gVE9ETzogSW1wcm92ZSB0aGUgc2VtYW50aWNzIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uXG4gICAgcGFyc2U0aW42KGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gYWRkcmVzcy5zcGxpdCgnOicpO1xuICAgICAgICBjb25zdCBsYXN0R3JvdXAgPSBncm91cHMuc2xpY2UoLTEpWzBdO1xuICAgICAgICBjb25zdCBhZGRyZXNzNCA9IGxhc3RHcm91cC5tYXRjaChjb25zdGFudHM0LlJFX0FERFJFU1MpO1xuICAgICAgICBpZiAoYWRkcmVzczQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkQWRkcmVzczQgPSBhZGRyZXNzNFswXTtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzczQgPSBuZXcgaXB2NF8xLkFkZHJlc3M0KHRoaXMucGFyc2VkQWRkcmVzczQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFkZHJlc3M0Lmdyb3VwczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eMFswLTldKy8udGVzdCh0aGlzLmFkZHJlc3M0LnBhcnNlZEFkZHJlc3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKFwiSVB2NCBhZGRyZXNzZXMgY2FuJ3QgaGF2ZSBsZWFkaW5nIHplcm9lcy5cIiwgYWRkcmVzcy5yZXBsYWNlKGNvbnN0YW50czQuUkVfQUREUkVTUywgdGhpcy5hZGRyZXNzNC5wYXJzZWRBZGRyZXNzLm1hcChzcGFuTGVhZGluZ1plcm9lczQpLmpvaW4oJy4nKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudjQgPSB0cnVlO1xuICAgICAgICAgICAgZ3JvdXBzW2dyb3Vwcy5sZW5ndGggLSAxXSA9IHRoaXMuYWRkcmVzczQudG9Hcm91cDYoKTtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBncm91cHMuam9pbignOicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICAvLyBUT0RPOiBNYWtlIHByaXZhdGU/XG4gICAgcGFyc2UoYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gdGhpcy5wYXJzZTRpbjYoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IGJhZENoYXJhY3RlcnMgPSBhZGRyZXNzLm1hdGNoKGNvbnN0YW50czYuUkVfQkFEX0NIQVJBQ1RFUlMpO1xuICAgICAgICBpZiAoYmFkQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnQmFkIGNoYXJhY3RlciVzIGRldGVjdGVkIGluIGFkZHJlc3M6ICVzJywgYmFkQ2hhcmFjdGVycy5sZW5ndGggPiAxID8gJ3MnIDogJycsIGJhZENoYXJhY3RlcnMuam9pbignJykpLCBhZGRyZXNzLnJlcGxhY2UoY29uc3RhbnRzNi5SRV9CQURfQ0hBUkFDVEVSUywgJzxzcGFuIGNsYXNzPVwicGFyc2UtZXJyb3JcIj4kMTwvc3Bhbj4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFkQWRkcmVzcyA9IGFkZHJlc3MubWF0Y2goY29uc3RhbnRzNi5SRV9CQURfQUREUkVTUyk7XG4gICAgICAgIGlmIChiYWRBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcigoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCdBZGRyZXNzIGZhaWxlZCByZWdleDogJXMnLCBiYWRBZGRyZXNzLmpvaW4oJycpKSwgYWRkcmVzcy5yZXBsYWNlKGNvbnN0YW50czYuUkVfQkFEX0FERFJFU1MsICc8c3BhbiBjbGFzcz1cInBhcnNlLWVycm9yXCI+JDE8L3NwYW4+JykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBncm91cHMgPSBbXTtcbiAgICAgICAgY29uc3QgaGFsdmVzID0gYWRkcmVzcy5zcGxpdCgnOjonKTtcbiAgICAgICAgaWYgKGhhbHZlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGhhbHZlc1swXS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBoYWx2ZXNbMV0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgIGlmIChmaXJzdC5sZW5ndGggPT09IDEgJiYgZmlyc3RbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0Lmxlbmd0aCA9PT0gMSAmJiBsYXN0WzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgIGxhc3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMuZ3JvdXBzIC0gKGZpcnN0Lmxlbmd0aCArIGxhc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICghcmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoJ0Vycm9yIHBhcnNpbmcgZ3JvdXBzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVsaWRlZEdyb3VwcyA9IHJlbWFpbmluZztcbiAgICAgICAgICAgIHRoaXMuZWxpc2lvbkJlZ2luID0gZmlyc3QubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5lbGlzaW9uRW5kID0gZmlyc3QubGVuZ3RoICsgdGhpcy5lbGlkZWRHcm91cHM7XG4gICAgICAgICAgICBncm91cHMgPSBncm91cHMuY29uY2F0KGZpcnN0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtYWluaW5nOyBpKyspIHtcbiAgICAgICAgICAgICAgICBncm91cHMucHVzaCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLmNvbmNhdChsYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYWx2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBncm91cHMgPSBhZGRyZXNzLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICB0aGlzLmVsaWRlZEdyb3VwcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcignVG9vIG1hbnkgOjogZ3JvdXBzIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLm1hcCgoZ3JvdXApID0+ICgwLCBzcHJpbnRmX2pzXzEuc3ByaW50ZikoJyV4JywgcGFyc2VJbnQoZ3JvdXAsIDE2KSkpO1xuICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCAhPT0gdGhpcy5ncm91cHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKCdJbmNvcnJlY3QgbnVtYmVyIG9mIGdyb3VwcyBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2Fub25pY2FsIGZvcm0gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNhbm9uaWNhbEZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEFkZHJlc3MubWFwKHBhZGRlZEhleCkuam9pbignOicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRlY2ltYWwgZm9ybSBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZGVjaW1hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkQWRkcmVzcy5tYXAoKG4pID0+ICgwLCBzcHJpbnRmX2pzXzEuc3ByaW50ZikoJyUwNWQnLCBwYXJzZUludChuLCAxNikpKS5qb2luKCc6Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYWRkcmVzcyBhcyBhIEJpZ0ludGVnZXJcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QmlnSW50ZWdlcn1cbiAgICAgKi9cbiAgICBiaWdJbnRlZ2VyKCkge1xuICAgICAgICByZXR1cm4gbmV3IGpzYm5fMS5CaWdJbnRlZ2VyKHRoaXMucGFyc2VkQWRkcmVzcy5tYXAocGFkZGVkSGV4KS5qb2luKCcnKSwgMTYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxhc3QgdHdvIGdyb3VwcyBvZiB0aGlzIGFkZHJlc3MgYXMgYW4gSVB2NCBhZGRyZXNzIHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhZGRyZXNzID0gbmV3IEFkZHJlc3M2KCcyMDAxOjQ4NjA6NDAwMTo6MTgyNTpiZjExJyk7XG4gICAgICogYWRkcmVzcy50bzQoKS5jb3JyZWN0Rm9ybSgpOyAvLyAnMjQuMzcuMTkxLjE3J1xuICAgICAqL1xuICAgIHRvNCgpIHtcbiAgICAgICAgY29uc3QgYmluYXJ5ID0gdGhpcy5iaW5hcnlaZXJvUGFkKCkuc3BsaXQoJycpO1xuICAgICAgICByZXR1cm4gaXB2NF8xLkFkZHJlc3M0LmZyb21IZXgobmV3IGpzYm5fMS5CaWdJbnRlZ2VyKGJpbmFyeS5zbGljZSg5NiwgMTI4KS5qb2luKCcnKSwgMikudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2NC1pbi12NiBmb3JtIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICB0bzRpbjYoKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3M0ID0gdGhpcy50bzQoKTtcbiAgICAgICAgY29uc3QgYWRkcmVzczYgPSBuZXcgQWRkcmVzczYodGhpcy5wYXJzZWRBZGRyZXNzLnNsaWNlKDAsIDYpLmpvaW4oJzonKSwgNik7XG4gICAgICAgIGNvbnN0IGNvcnJlY3QgPSBhZGRyZXNzNi5jb3JyZWN0Rm9ybSgpO1xuICAgICAgICBsZXQgaW5maXggPSAnJztcbiAgICAgICAgaWYgKCEvOiQvLnRlc3QoY29ycmVjdCkpIHtcbiAgICAgICAgICAgIGluZml4ID0gJzonO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3JyZWN0ICsgaW5maXggKyBhZGRyZXNzNC5hZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIFRlcmVkbyBwcm9wZXJ0aWVzIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBpbnNwZWN0VGVyZWRvKCkge1xuICAgICAgICAvKlxuICAgICAgICAtIEJpdHMgMCB0byAzMSBhcmUgc2V0IHRvIHRoZSBUZXJlZG8gcHJlZml4IChub3JtYWxseSAyMDAxOjAwMDA6Oi8zMikuXG4gICAgICAgIC0gQml0cyAzMiB0byA2MyBlbWJlZCB0aGUgcHJpbWFyeSBJUHY0IGFkZHJlc3Mgb2YgdGhlIFRlcmVkbyBzZXJ2ZXIgdGhhdFxuICAgICAgICAgIGlzIHVzZWQuXG4gICAgICAgIC0gQml0cyA2NCB0byA3OSBjYW4gYmUgdXNlZCB0byBkZWZpbmUgc29tZSBmbGFncy4gQ3VycmVudGx5IG9ubHkgdGhlXG4gICAgICAgICAgaGlnaGVyIG9yZGVyIGJpdCBpcyB1c2VkOyBpdCBpcyBzZXQgdG8gMSBpZiB0aGUgVGVyZWRvIGNsaWVudCBpc1xuICAgICAgICAgIGxvY2F0ZWQgYmVoaW5kIGEgY29uZSBOQVQsIDAgb3RoZXJ3aXNlLiBGb3IgTWljcm9zb2Z0J3MgV2luZG93cyBWaXN0YVxuICAgICAgICAgIGFuZCBXaW5kb3dzIFNlcnZlciAyMDA4IGltcGxlbWVudGF0aW9ucywgbW9yZSBiaXRzIGFyZSB1c2VkLiBJbiB0aG9zZVxuICAgICAgICAgIGltcGxlbWVudGF0aW9ucywgdGhlIGZvcm1hdCBmb3IgdGhlc2UgMTYgYml0cyBpcyBcIkNSQUFBQVVHIEFBQUFBQUFBXCIsXG4gICAgICAgICAgd2hlcmUgXCJDXCIgcmVtYWlucyB0aGUgXCJDb25lXCIgZmxhZy4gVGhlIFwiUlwiIGJpdCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlXG4gICAgICAgICAgdXNlLiBUaGUgXCJVXCIgYml0IGlzIGZvciB0aGUgVW5pdmVyc2FsL0xvY2FsIGZsYWcgKHNldCB0byAwKS4gVGhlIFwiR1wiIGJpdFxuICAgICAgICAgIGlzIEluZGl2aWR1YWwvR3JvdXAgZmxhZyAoc2V0IHRvIDApLiBUaGUgQSBiaXRzIGFyZSBzZXQgdG8gYSAxMi1iaXRcbiAgICAgICAgICByYW5kb21seSBnZW5lcmF0ZWQgbnVtYmVyIGNob3NlbiBieSB0aGUgVGVyZWRvIGNsaWVudCB0byBpbnRyb2R1Y2VcbiAgICAgICAgICBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZm9yIHRoZSBUZXJlZG8gbm9kZSBhZ2FpbnN0IElQdjYtYmFzZWQgc2Nhbm5pbmdcbiAgICAgICAgICBhdHRhY2tzLlxuICAgICAgICAtIEJpdHMgODAgdG8gOTUgY29udGFpbnMgdGhlIG9iZnVzY2F0ZWQgVURQIHBvcnQgbnVtYmVyLiBUaGlzIGlzIHRoZVxuICAgICAgICAgIHBvcnQgbnVtYmVyIHRoYXQgaXMgbWFwcGVkIGJ5IHRoZSBOQVQgdG8gdGhlIFRlcmVkbyBjbGllbnQgd2l0aCBhbGxcbiAgICAgICAgICBiaXRzIGludmVydGVkLlxuICAgICAgICAtIEJpdHMgOTYgdG8gMTI3IGNvbnRhaW5zIHRoZSBvYmZ1c2NhdGVkIElQdjQgYWRkcmVzcy4gVGhpcyBpcyB0aGVcbiAgICAgICAgICBwdWJsaWMgSVB2NCBhZGRyZXNzIG9mIHRoZSBOQVQgd2l0aCBhbGwgYml0cyBpbnZlcnRlZC5cbiAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5nZXRCaXRzQmFzZTE2KDAsIDMyKTtcbiAgICAgICAgY29uc3QgdWRwUG9ydCA9IHRoaXMuZ2V0Qml0cyg4MCwgOTYpLnhvcihuZXcganNibl8xLkJpZ0ludGVnZXIoJ2ZmZmYnLCAxNikpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHNlcnZlcjQgPSBpcHY0XzEuQWRkcmVzczQuZnJvbUhleCh0aGlzLmdldEJpdHNCYXNlMTYoMzIsIDY0KSk7XG4gICAgICAgIGNvbnN0IGNsaWVudDQgPSBpcHY0XzEuQWRkcmVzczQuZnJvbUhleCh0aGlzLmdldEJpdHMoOTYsIDEyOCkueG9yKG5ldyBqc2JuXzEuQmlnSW50ZWdlcignZmZmZmZmZmYnLCAxNikpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gdGhpcy5nZXRCaXRzKDY0LCA4MCk7XG4gICAgICAgIGNvbnN0IGZsYWdzQmFzZTIgPSB0aGlzLmdldEJpdHNCYXNlMig2NCwgODApO1xuICAgICAgICBjb25zdCBjb25lTmF0ID0gZmxhZ3MudGVzdEJpdCgxNSk7XG4gICAgICAgIGNvbnN0IHJlc2VydmVkID0gZmxhZ3MudGVzdEJpdCgxNCk7XG4gICAgICAgIGNvbnN0IGdyb3VwSW5kaXZpZHVhbCA9IGZsYWdzLnRlc3RCaXQoOCk7XG4gICAgICAgIGNvbnN0IHVuaXZlcnNhbExvY2FsID0gZmxhZ3MudGVzdEJpdCg5KTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuZXcganNibl8xLkJpZ0ludGVnZXIoZmxhZ3NCYXNlMi5zbGljZSgyLCA2KSArIGZsYWdzQmFzZTIuc2xpY2UoOCwgMTYpLCAyKS50b1N0cmluZygxMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVmaXg6ICgwLCBzcHJpbnRmX2pzXzEuc3ByaW50ZikoJyVzOiVzJywgcHJlZml4LnNsaWNlKDAsIDQpLCBwcmVmaXguc2xpY2UoNCwgOCkpLFxuICAgICAgICAgICAgc2VydmVyNDogc2VydmVyNC5hZGRyZXNzLFxuICAgICAgICAgICAgY2xpZW50NDogY2xpZW50NC5hZGRyZXNzLFxuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzQmFzZTIsXG4gICAgICAgICAgICBjb25lTmF0LFxuICAgICAgICAgICAgbWljcm9zb2Z0OiB7XG4gICAgICAgICAgICAgICAgcmVzZXJ2ZWQsXG4gICAgICAgICAgICAgICAgdW5pdmVyc2FsTG9jYWwsXG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRpdmlkdWFsLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVkcFBvcnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgNnRvNCBwcm9wZXJ0aWVzIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBpbnNwZWN0NnRvNCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgLSBCaXRzIDAgdG8gMTUgYXJlIHNldCB0byB0aGUgNnRvNCBwcmVmaXggKDIwMDI6Oi8xNikuXG4gICAgICAgIC0gQml0cyAxNiB0byA0OCBlbWJlZCB0aGUgSVB2NCBhZGRyZXNzIG9mIHRoZSA2dG80IGdhdGV3YXkgdGhhdCBpcyB1c2VkLlxuICAgICAgICAqL1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmdldEJpdHNCYXNlMTYoMCwgMTYpO1xuICAgICAgICBjb25zdCBnYXRld2F5ID0gaXB2NF8xLkFkZHJlc3M0LmZyb21IZXgodGhpcy5nZXRCaXRzQmFzZTE2KDE2LCA0OCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4OiAoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCclcycsIHByZWZpeC5zbGljZSgwLCA0KSksXG4gICAgICAgICAgICBnYXRld2F5OiBnYXRld2F5LmFkZHJlc3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHY2IDZ0bzQgYWRkcmVzcyBmcm9tIGEgdjYgdjRpbnY2IGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICovXG4gICAgdG82dG80KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXM0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHI2dG80ID0gW1xuICAgICAgICAgICAgJzIwMDInLFxuICAgICAgICAgICAgdGhpcy5nZXRCaXRzQmFzZTE2KDk2LCAxMTIpLFxuICAgICAgICAgICAgdGhpcy5nZXRCaXRzQmFzZTE2KDExMiwgMTI4KSxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJy8xNicsXG4gICAgICAgIF0uam9pbignOicpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3M2KGFkZHI2dG80KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgYnl0ZSBhcnJheVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICB0b0J5dGVBcnJheSgpIHtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gdGhpcy5iaWdJbnRlZ2VyKCkudG9CeXRlQXJyYXkoKTtcbiAgICAgICAgLy8gd29yayBhcm91bmQgaXNzdWUgd2hlcmUgYHRvQnl0ZUFycmF5YCByZXR1cm5zIGEgbGVhZGluZyAwIGVsZW1lbnRcbiAgICAgICAgaWYgKGJ5dGVBcnJheS5sZW5ndGggPT09IDE3ICYmIGJ5dGVBcnJheVswXSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVBcnJheS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZUFycmF5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gdW5zaWduZWQgYnl0ZSBhcnJheVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICB0b1Vuc2lnbmVkQnl0ZUFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVBcnJheSgpLm1hcCh1bnNpZ25CeXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYW4gQWRkcmVzczYgb2JqZWN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ5dGVBcnJheShieXRlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tVW5zaWduZWRCeXRlQXJyYXkoYnl0ZXMubWFwKHVuc2lnbkJ5dGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiB1bnNpZ25lZCBieXRlIGFycmF5IHRvIGFuIEFkZHJlc3M2IG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21VbnNpZ25lZEJ5dGVBcnJheShieXRlcykge1xuICAgICAgICBjb25zdCBCWVRFX01BWCA9IG5ldyBqc2JuXzEuQmlnSW50ZWdlcignMjU2JywgMTApO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IGpzYm5fMS5CaWdJbnRlZ2VyKCcwJywgMTApO1xuICAgICAgICBsZXQgbXVsdGlwbGllciA9IG5ldyBqc2JuXzEuQmlnSW50ZWdlcignMScsIDEwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKG11bHRpcGxpZXIubXVsdGlwbHkobmV3IGpzYm5fMS5CaWdJbnRlZ2VyKGJ5dGVzW2ldLnRvU3RyaW5nKDEwKSwgMTApKSk7XG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gbXVsdGlwbGllci5tdWx0aXBseShCWVRFX01BWCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFkZHJlc3M2LmZyb21CaWdJbnRlZ2VyKHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBpbiB0aGUgY2Fub25pY2FsIGZvcm0sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzQ2Fub25pY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzTWludXNTdWZmaXggPT09IHRoaXMuY2Fub25pY2FsRm9ybSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgYSBsaW5rIGxvY2FsIGFkZHJlc3MsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTGlua0xvY2FsKCkge1xuICAgICAgICAvLyBaZXJvZXMgYXJlIHJlcXVpcmVkLCBpLmUuIHdlIGNhbid0IGNoZWNrIGlzSW5TdWJuZXQgd2l0aCAnZmU4MDo6LzEwJ1xuICAgICAgICBpZiAodGhpcy5nZXRCaXRzQmFzZTIoMCwgNjQpID09PVxuICAgICAgICAgICAgJzExMTExMTEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIG11bHRpY2FzdCBhZGRyZXNzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc011bHRpY2FzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpID09PSAnTXVsdGljYXN0JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIGEgdjQtaW4tdjYgYWRkcmVzcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXM0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52NDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIGEgVGVyZWRvIGFkZHJlc3MsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVGVyZWRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0luU3VibmV0KG5ldyBBZGRyZXNzNignMjAwMTo6LzMyJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgYSA2dG80IGFkZHJlc3MsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzNnRvNCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblN1Ym5ldChuZXcgQWRkcmVzczYoJzIwMDI6Oi8xNicpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIGEgbG9vcGJhY2sgYWRkcmVzcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNMb29wYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpID09PSAnTG9vcGJhY2snO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBIVE1MXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIGFkZHJlc3MgaW4gbGluayBmb3JtIHdpdGggYSBkZWZhdWx0IHBvcnQgb2YgODBcbiAgICAgKi9cbiAgICBocmVmKG9wdGlvbmFsUG9ydCkge1xuICAgICAgICBpZiAob3B0aW9uYWxQb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsUG9ydCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uYWxQb3J0ID0gKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnOiVzJywgb3B0aW9uYWxQb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnaHR0cDovL1slc10lcy8nLCB0aGlzLmNvcnJlY3RGb3JtKCksIG9wdGlvbmFsUG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGEgbGluayBzdWl0YWJsZSBmb3IgY29udmV5aW5nIHRoZSBhZGRyZXNzIHZpYSBhIFVSTCBoYXNoXG4gICAgICovXG4gICAgbGluayhvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNsYXNzTmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnByZWZpeCA9ICcvI2FkZHJlc3M9JztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy52NCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnY0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvcm1GdW5jdGlvbiA9IHRoaXMuY29ycmVjdEZvcm07XG4gICAgICAgIGlmIChvcHRpb25zLnY0KSB7XG4gICAgICAgICAgICBmb3JtRnVuY3Rpb24gPSB0aGlzLnRvNGluNjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCc8YSBocmVmPVwiJTEkcyUyJHNcIiBjbGFzcz1cIiUzJHNcIj4lMiRzPC9hPicsIG9wdGlvbnMucHJlZml4LCBmb3JtRnVuY3Rpb24uY2FsbCh0aGlzKSwgb3B0aW9ucy5jbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCc8YSBocmVmPVwiJTEkcyUyJHNcIj4lMiRzPC9hPicsIG9wdGlvbnMucHJlZml4LCBmb3JtRnVuY3Rpb24uY2FsbCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBhbiBhZGRyZXNzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBncm91cCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxpZGVkR3JvdXBzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2ltcGxlIGNhc2VcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLnNpbXBsZUdyb3VwKHRoaXMuYWRkcmVzcykuam9pbignOicpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdGhpcy5lbGlkZWRHcm91cHMgPT09ICdudW1iZXInKTtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB0aGlzLmVsaXNpb25CZWdpbiA9PT0gJ251bWJlcicpO1xuICAgICAgICAvLyBUaGUgZWxpZGVkIGNhc2VcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmFkZHJlc3Muc3BsaXQoJzo6Jyk7XG4gICAgICAgIGlmIChsZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goLi4uaGVscGVycy5zaW1wbGVHcm91cChsZWZ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IFsnaG92ZXItZ3JvdXAnXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZWxpc2lvbkJlZ2luOyBpIDwgdGhpcy5lbGlzaW9uQmVnaW4gKyB0aGlzLmVsaWRlZEdyb3VwczsgaSsrKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnZ3JvdXAtJWQnLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2goKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnPHNwYW4gY2xhc3M9XCIlc1wiPjwvc3Bhbj4nLCBjbGFzc2VzLmpvaW4oJyAnKSkpO1xuICAgICAgICBpZiAocmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCguLi5oZWxwZXJzLnNpbXBsZUdyb3VwKHJpZ2h0LCB0aGlzLmVsaXNpb25FbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pczQoKSkge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuYWRkcmVzczQgaW5zdGFuY2VvZiBpcHY0XzEuQWRkcmVzczQpO1xuICAgICAgICAgICAgb3V0cHV0LnBvcCgpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godGhpcy5hZGRyZXNzNC5ncm91cEZvclY2KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignOicpO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBSZWd1bGFyIGV4cHJlc3Npb25zXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmluZCBvciB2YWxpZGF0ZVxuICAgICAqIGFsbCB2YXJpYXRpb25zIG9mIHRoaXMgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3Vic3RyaW5nU2VhcmNoXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICByZWd1bGFyRXhwcmVzc2lvblN0cmluZyhzdWJzdHJpbmdTZWFyY2ggPSBmYWxzZSkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gW107XG4gICAgICAgIC8vIFRPRE86IHJldmlzaXQgd2h5IHRoaXMgaXMgbmVjZXNzYXJ5XG4gICAgICAgIGNvbnN0IGFkZHJlc3M2ID0gbmV3IEFkZHJlc3M2KHRoaXMuY29ycmVjdEZvcm0oKSk7XG4gICAgICAgIGlmIChhZGRyZXNzNi5lbGlkZWRHcm91cHMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRoZSBzaW1wbGUgY2FzZVxuICAgICAgICAgICAgb3V0cHV0LnB1c2goKDAsIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5zaW1wbGVSZWd1bGFyRXhwcmVzc2lvbikoYWRkcmVzczYucGFyc2VkQWRkcmVzcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFkZHJlc3M2LmVsaWRlZEdyb3VwcyA9PT0gY29uc3RhbnRzNi5HUk9VUFMpIHtcbiAgICAgICAgICAgIC8vIEEgY29tcGxldGVseSBlbGlkZWQgYWRkcmVzc1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goKDAsIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5wb3NzaWJsZUVsaXNpb25zKShjb25zdGFudHM2LkdST1VQUykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQSBwYXJ0aWFsbHkgZWxpZGVkIGFkZHJlc3NcbiAgICAgICAgICAgIGNvbnN0IGhhbHZlcyA9IGFkZHJlc3M2LmFkZHJlc3Muc3BsaXQoJzo6Jyk7XG4gICAgICAgICAgICBpZiAoaGFsdmVzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCgwLCByZWd1bGFyX2V4cHJlc3Npb25zXzEuc2ltcGxlUmVndWxhckV4cHJlc3Npb24pKGhhbHZlc1swXS5zcGxpdCgnOicpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIGFkZHJlc3M2LmVsaWRlZEdyb3VwcyA9PT0gJ251bWJlcicpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goKDAsIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5wb3NzaWJsZUVsaXNpb25zKShhZGRyZXNzNi5lbGlkZWRHcm91cHMsIGhhbHZlc1swXS5sZW5ndGggIT09IDAsIGhhbHZlc1sxXS5sZW5ndGggIT09IDApKTtcbiAgICAgICAgICAgIGlmIChoYWx2ZXNbMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKDAsIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5zaW1wbGVSZWd1bGFyRXhwcmVzc2lvbikoaGFsdmVzWzFdLnNwbGl0KCc6JykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCA9IFtvdXRwdXQuam9pbignOicpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YnN0cmluZ1NlYXJjaCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gW1xuICAgICAgICAgICAgICAgICcoPz1efCcsXG4gICAgICAgICAgICAgICAgcmVndWxhcl9leHByZXNzaW9uc18xLkFERFJFU1NfQk9VTkRBUlksXG4gICAgICAgICAgICAgICAgJ3xbXlxcXFx3XFxcXDpdKSgnLFxuICAgICAgICAgICAgICAgIC4uLm91dHB1dCxcbiAgICAgICAgICAgICAgICAnKSg/PVteXFxcXHdcXFxcOl18JyxcbiAgICAgICAgICAgICAgICByZWd1bGFyX2V4cHJlc3Npb25zXzEuQUREUkVTU19CT1VOREFSWSxcbiAgICAgICAgICAgICAgICAnfCQpJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCB0byBmaW5kIG9yIHZhbGlkYXRlIGFsbFxuICAgICAqIHZhcmlhdGlvbnMgb2YgdGhpcyBhZGRyZXNzLlxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3Vic3RyaW5nU2VhcmNoXG4gICAgICogQHJldHVybnMge1JlZ0V4cH1cbiAgICAgKi9cbiAgICByZWd1bGFyRXhwcmVzc2lvbihzdWJzdHJpbmdTZWFyY2ggPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh0aGlzLnJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nKHN1YnN0cmluZ1NlYXJjaCksICdpJyk7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzNiA9IEFkZHJlc3M2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXB2Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/ipv6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/v4/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/ip-address/dist/v4/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RE_SUBNET_STRING = exports.RE_ADDRESS = exports.GROUPS = exports.BITS = void 0;\nexports.BITS = 32;\nexports.GROUPS = 4;\nexports.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;\nexports.RE_SUBNET_STRING = /\\/\\d{1,2}$/;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsWUFBWTtBQUM3RSxZQUFZO0FBQ1osY0FBYztBQUNkLGtCQUFrQjtBQUNsQix3QkFBd0IsU0FBUyxJQUFJO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MyLXNraW4tdHJhY2tlci8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvdjQvY29uc3RhbnRzLmpzPzQ4MzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFX1NVQk5FVF9TVFJJTkcgPSBleHBvcnRzLlJFX0FERFJFU1MgPSBleHBvcnRzLkdST1VQUyA9IGV4cG9ydHMuQklUUyA9IHZvaWQgMDtcbmV4cG9ydHMuQklUUyA9IDMyO1xuZXhwb3J0cy5HUk9VUFMgPSA0O1xuZXhwb3J0cy5SRV9BRERSRVNTID0gL14oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSQvZztcbmV4cG9ydHMuUkVfU1VCTkVUX1NUUklORyA9IC9cXC9cXGR7MSwyfSQvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/v4/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/v6/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RE_URL_WITH_PORT = exports.RE_URL = exports.RE_ZONE_STRING = exports.RE_SUBNET_STRING = exports.RE_BAD_ADDRESS = exports.RE_BAD_CHARACTERS = exports.TYPES = exports.SCOPES = exports.GROUPS = exports.BITS = void 0;\nexports.BITS = 128;\nexports.GROUPS = 8;\n/**\n * Represents IPv6 address scopes\n * @memberof Address6\n * @static\n */\nexports.SCOPES = {\n    0: 'Reserved',\n    1: 'Interface local',\n    2: 'Link local',\n    4: 'Admin local',\n    5: 'Site local',\n    8: 'Organization local',\n    14: 'Global',\n    15: 'Reserved',\n};\n/**\n * Represents IPv6 address types\n * @memberof Address6\n * @static\n */\nexports.TYPES = {\n    'ff01::1/128': 'Multicast (All nodes on this interface)',\n    'ff01::2/128': 'Multicast (All routers on this interface)',\n    'ff02::1/128': 'Multicast (All nodes on this link)',\n    'ff02::2/128': 'Multicast (All routers on this link)',\n    'ff05::2/128': 'Multicast (All routers in this site)',\n    'ff02::5/128': 'Multicast (OSPFv3 AllSPF routers)',\n    'ff02::6/128': 'Multicast (OSPFv3 AllDR routers)',\n    'ff02::9/128': 'Multicast (RIP routers)',\n    'ff02::a/128': 'Multicast (EIGRP routers)',\n    'ff02::d/128': 'Multicast (PIM routers)',\n    'ff02::16/128': 'Multicast (MLDv2 reports)',\n    'ff01::fb/128': 'Multicast (mDNSv6)',\n    'ff02::fb/128': 'Multicast (mDNSv6)',\n    'ff05::fb/128': 'Multicast (mDNSv6)',\n    'ff02::1:2/128': 'Multicast (All DHCP servers and relay agents on this link)',\n    'ff05::1:2/128': 'Multicast (All DHCP servers and relay agents in this site)',\n    'ff02::1:3/128': 'Multicast (All DHCP servers on this link)',\n    'ff05::1:3/128': 'Multicast (All DHCP servers in this site)',\n    '::/128': 'Unspecified',\n    '::1/128': 'Loopback',\n    'ff00::/8': 'Multicast',\n    'fe80::/10': 'Link-local unicast',\n};\n/**\n * A regular expression that matches bad characters in an IPv6 address\n * @memberof Address6\n * @static\n */\nexports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;\n/**\n * A regular expression that matches an incorrect IPv6 address\n * @memberof Address6\n * @static\n */\nexports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\\/$)/gi;\n/**\n * A regular expression that matches an IPv6 subnet\n * @memberof Address6\n * @static\n */\nexports.RE_SUBNET_STRING = /\\/\\d{1,3}(?=%|$)/;\n/**\n * A regular expression that matches an IPv6 zone\n * @memberof Address6\n * @static\n */\nexports.RE_ZONE_STRING = /%.*$/;\nexports.RE_URL = new RegExp(/^\\[{0,1}([0-9a-f:]+)\\]{0,1}/);\nexports.RE_URL_WITH_PORT = new RegExp(/\\[([0-9a-f:]+)\\]:([0-9]{1,5})/);\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y2L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxjQUFjLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsWUFBWTtBQUNuTixZQUFZO0FBQ1osY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsR0FBRyxHQUFHLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixjQUFjLG1CQUFtQixJQUFJLGVBQWUsSUFBSTtBQUN4RCx3QkFBd0IsdUNBQXVDLElBQUk7QUFDbkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jczItc2tpbi10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2lwLWFkZHJlc3MvZGlzdC92Ni9jb25zdGFudHMuanM/MThhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUkVfVVJMX1dJVEhfUE9SVCA9IGV4cG9ydHMuUkVfVVJMID0gZXhwb3J0cy5SRV9aT05FX1NUUklORyA9IGV4cG9ydHMuUkVfU1VCTkVUX1NUUklORyA9IGV4cG9ydHMuUkVfQkFEX0FERFJFU1MgPSBleHBvcnRzLlJFX0JBRF9DSEFSQUNURVJTID0gZXhwb3J0cy5UWVBFUyA9IGV4cG9ydHMuU0NPUEVTID0gZXhwb3J0cy5HUk9VUFMgPSBleHBvcnRzLkJJVFMgPSB2b2lkIDA7XG5leHBvcnRzLkJJVFMgPSAxMjg7XG5leHBvcnRzLkdST1VQUyA9IDg7XG4vKipcbiAqIFJlcHJlc2VudHMgSVB2NiBhZGRyZXNzIHNjb3Blc1xuICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuU0NPUEVTID0ge1xuICAgIDA6ICdSZXNlcnZlZCcsXG4gICAgMTogJ0ludGVyZmFjZSBsb2NhbCcsXG4gICAgMjogJ0xpbmsgbG9jYWwnLFxuICAgIDQ6ICdBZG1pbiBsb2NhbCcsXG4gICAgNTogJ1NpdGUgbG9jYWwnLFxuICAgIDg6ICdPcmdhbml6YXRpb24gbG9jYWwnLFxuICAgIDE0OiAnR2xvYmFsJyxcbiAgICAxNTogJ1Jlc2VydmVkJyxcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgSVB2NiBhZGRyZXNzIHR5cGVzXG4gKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5UWVBFUyA9IHtcbiAgICAnZmYwMTo6MS8xMjgnOiAnTXVsdGljYXN0IChBbGwgbm9kZXMgb24gdGhpcyBpbnRlcmZhY2UpJyxcbiAgICAnZmYwMTo6Mi8xMjgnOiAnTXVsdGljYXN0IChBbGwgcm91dGVycyBvbiB0aGlzIGludGVyZmFjZSknLFxuICAgICdmZjAyOjoxLzEyOCc6ICdNdWx0aWNhc3QgKEFsbCBub2RlcyBvbiB0aGlzIGxpbmspJyxcbiAgICAnZmYwMjo6Mi8xMjgnOiAnTXVsdGljYXN0IChBbGwgcm91dGVycyBvbiB0aGlzIGxpbmspJyxcbiAgICAnZmYwNTo6Mi8xMjgnOiAnTXVsdGljYXN0IChBbGwgcm91dGVycyBpbiB0aGlzIHNpdGUpJyxcbiAgICAnZmYwMjo6NS8xMjgnOiAnTXVsdGljYXN0IChPU1BGdjMgQWxsU1BGIHJvdXRlcnMpJyxcbiAgICAnZmYwMjo6Ni8xMjgnOiAnTXVsdGljYXN0IChPU1BGdjMgQWxsRFIgcm91dGVycyknLFxuICAgICdmZjAyOjo5LzEyOCc6ICdNdWx0aWNhc3QgKFJJUCByb3V0ZXJzKScsXG4gICAgJ2ZmMDI6OmEvMTI4JzogJ011bHRpY2FzdCAoRUlHUlAgcm91dGVycyknLFxuICAgICdmZjAyOjpkLzEyOCc6ICdNdWx0aWNhc3QgKFBJTSByb3V0ZXJzKScsXG4gICAgJ2ZmMDI6OjE2LzEyOCc6ICdNdWx0aWNhc3QgKE1MRHYyIHJlcG9ydHMpJyxcbiAgICAnZmYwMTo6ZmIvMTI4JzogJ011bHRpY2FzdCAobUROU3Y2KScsXG4gICAgJ2ZmMDI6OmZiLzEyOCc6ICdNdWx0aWNhc3QgKG1ETlN2NiknLFxuICAgICdmZjA1OjpmYi8xMjgnOiAnTXVsdGljYXN0IChtRE5TdjYpJyxcbiAgICAnZmYwMjo6MToyLzEyOCc6ICdNdWx0aWNhc3QgKEFsbCBESENQIHNlcnZlcnMgYW5kIHJlbGF5IGFnZW50cyBvbiB0aGlzIGxpbmspJyxcbiAgICAnZmYwNTo6MToyLzEyOCc6ICdNdWx0aWNhc3QgKEFsbCBESENQIHNlcnZlcnMgYW5kIHJlbGF5IGFnZW50cyBpbiB0aGlzIHNpdGUpJyxcbiAgICAnZmYwMjo6MTozLzEyOCc6ICdNdWx0aWNhc3QgKEFsbCBESENQIHNlcnZlcnMgb24gdGhpcyBsaW5rKScsXG4gICAgJ2ZmMDU6OjE6My8xMjgnOiAnTXVsdGljYXN0IChBbGwgREhDUCBzZXJ2ZXJzIGluIHRoaXMgc2l0ZSknLFxuICAgICc6Oi8xMjgnOiAnVW5zcGVjaWZpZWQnLFxuICAgICc6OjEvMTI4JzogJ0xvb3BiYWNrJyxcbiAgICAnZmYwMDo6LzgnOiAnTXVsdGljYXN0JyxcbiAgICAnZmU4MDo6LzEwJzogJ0xpbmstbG9jYWwgdW5pY2FzdCcsXG59O1xuLyoqXG4gKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYmFkIGNoYXJhY3RlcnMgaW4gYW4gSVB2NiBhZGRyZXNzXG4gKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5SRV9CQURfQ0hBUkFDVEVSUyA9IC8oW14wLTlhLWY6LyVdKS9naTtcbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGFuIGluY29ycmVjdCBJUHY2IGFkZHJlc3NcbiAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICogQHN0YXRpY1xuICovXG5leHBvcnRzLlJFX0JBRF9BRERSRVNTID0gLyhbMC05YS1mXXs1LH18OnszLH18W146XTokfF46W146XXxcXC8kKS9naTtcbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGFuIElQdjYgc3VibmV0XG4gKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5SRV9TVUJORVRfU1RSSU5HID0gL1xcL1xcZHsxLDN9KD89JXwkKS87XG4vKipcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhbiBJUHY2IHpvbmVcbiAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICogQHN0YXRpY1xuICovXG5leHBvcnRzLlJFX1pPTkVfU1RSSU5HID0gLyUuKiQvO1xuZXhwb3J0cy5SRV9VUkwgPSBuZXcgUmVnRXhwKC9eXFxbezAsMX0oWzAtOWEtZjpdKylcXF17MCwxfS8pO1xuZXhwb3J0cy5SRV9VUkxfV0lUSF9QT1JUID0gbmV3IFJlZ0V4cCgvXFxbKFswLTlhLWY6XSspXFxdOihbMC05XXsxLDV9KS8pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/v6/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/v6/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.simpleGroup = exports.spanLeadingZeroes = exports.spanAll = exports.spanAllZeroes = void 0;\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"(rsc)/./node_modules/sprintf-js/src/sprintf.js\");\n/**\n * @returns {String} the string with all zeroes contained in a <span>\n */\nfunction spanAllZeroes(s) {\n    return s.replace(/(0+)/g, '<span class=\"zero\">$1</span>');\n}\nexports.spanAllZeroes = spanAllZeroes;\n/**\n * @returns {String} the string with each character contained in a <span>\n */\nfunction spanAll(s, offset = 0) {\n    const letters = s.split('');\n    return letters\n        .map((n, i) => (0, sprintf_js_1.sprintf)('<span class=\"digit value-%s position-%d\">%s</span>', n, i + offset, spanAllZeroes(n)) // XXX Use #base-2 .value-0 instead?\n    )\n        .join('');\n}\nexports.spanAll = spanAll;\nfunction spanLeadingZeroesSimple(group) {\n    return group.replace(/^(0+)/, '<span class=\"zero\">$1</span>');\n}\n/**\n * @returns {String} the string with leading zeroes contained in a <span>\n */\nfunction spanLeadingZeroes(address) {\n    const groups = address.split(':');\n    return groups.map((g) => spanLeadingZeroesSimple(g)).join(':');\n}\nexports.spanLeadingZeroes = spanLeadingZeroes;\n/**\n * Groups an address\n * @returns {String} a grouped address\n */\nfunction simpleGroup(addressString, offset = 0) {\n    const groups = addressString.split(':');\n    return groups.map((g, i) => {\n        if (/group-v4/.test(g)) {\n            return g;\n        }\n        return (0, sprintf_js_1.sprintf)('<span class=\"hover-group group-%d\">%s</span>', i + offset, spanLeadingZeroesSimple(g));\n    });\n}\nexports.simpleGroup = simpleGroup;\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y2L2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsZUFBZSxHQUFHLHFCQUFxQjtBQUN6RixxQkFBcUIsbUJBQU8sQ0FBQyxrRUFBWTtBQUN6QztBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MyLXNraW4tdHJhY2tlci8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvdjYvaGVscGVycy5qcz9jYWQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaW1wbGVHcm91cCA9IGV4cG9ydHMuc3BhbkxlYWRpbmdaZXJvZXMgPSBleHBvcnRzLnNwYW5BbGwgPSBleHBvcnRzLnNwYW5BbGxaZXJvZXMgPSB2b2lkIDA7XG5jb25zdCBzcHJpbnRmX2pzXzEgPSByZXF1aXJlKFwic3ByaW50Zi1qc1wiKTtcbi8qKlxuICogQHJldHVybnMge1N0cmluZ30gdGhlIHN0cmluZyB3aXRoIGFsbCB6ZXJvZXMgY29udGFpbmVkIGluIGEgPHNwYW4+XG4gKi9cbmZ1bmN0aW9uIHNwYW5BbGxaZXJvZXMocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoLygwKykvZywgJzxzcGFuIGNsYXNzPVwiemVyb1wiPiQxPC9zcGFuPicpO1xufVxuZXhwb3J0cy5zcGFuQWxsWmVyb2VzID0gc3BhbkFsbFplcm9lcztcbi8qKlxuICogQHJldHVybnMge1N0cmluZ30gdGhlIHN0cmluZyB3aXRoIGVhY2ggY2hhcmFjdGVyIGNvbnRhaW5lZCBpbiBhIDxzcGFuPlxuICovXG5mdW5jdGlvbiBzcGFuQWxsKHMsIG9mZnNldCA9IDApIHtcbiAgICBjb25zdCBsZXR0ZXJzID0gcy5zcGxpdCgnJyk7XG4gICAgcmV0dXJuIGxldHRlcnNcbiAgICAgICAgLm1hcCgobiwgaSkgPT4gKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnPHNwYW4gY2xhc3M9XCJkaWdpdCB2YWx1ZS0lcyBwb3NpdGlvbi0lZFwiPiVzPC9zcGFuPicsIG4sIGkgKyBvZmZzZXQsIHNwYW5BbGxaZXJvZXMobikpIC8vIFhYWCBVc2UgI2Jhc2UtMiAudmFsdWUtMCBpbnN0ZWFkP1xuICAgIClcbiAgICAgICAgLmpvaW4oJycpO1xufVxuZXhwb3J0cy5zcGFuQWxsID0gc3BhbkFsbDtcbmZ1bmN0aW9uIHNwYW5MZWFkaW5nWmVyb2VzU2ltcGxlKGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoL14oMCspLywgJzxzcGFuIGNsYXNzPVwiemVyb1wiPiQxPC9zcGFuPicpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgc3RyaW5nIHdpdGggbGVhZGluZyB6ZXJvZXMgY29udGFpbmVkIGluIGEgPHNwYW4+XG4gKi9cbmZ1bmN0aW9uIHNwYW5MZWFkaW5nWmVyb2VzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBncm91cHMgPSBhZGRyZXNzLnNwbGl0KCc6Jyk7XG4gICAgcmV0dXJuIGdyb3Vwcy5tYXAoKGcpID0+IHNwYW5MZWFkaW5nWmVyb2VzU2ltcGxlKGcpKS5qb2luKCc6Jyk7XG59XG5leHBvcnRzLnNwYW5MZWFkaW5nWmVyb2VzID0gc3BhbkxlYWRpbmdaZXJvZXM7XG4vKipcbiAqIEdyb3VwcyBhbiBhZGRyZXNzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhIGdyb3VwZWQgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBzaW1wbGVHcm91cChhZGRyZXNzU3RyaW5nLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgZ3JvdXBzID0gYWRkcmVzc1N0cmluZy5zcGxpdCgnOicpO1xuICAgIHJldHVybiBncm91cHMubWFwKChnLCBpKSA9PiB7XG4gICAgICAgIGlmICgvZ3JvdXAtdjQvLnRlc3QoZykpIHtcbiAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCc8c3BhbiBjbGFzcz1cImhvdmVyLWdyb3VwIGdyb3VwLSVkXCI+JXM8L3NwYW4+JywgaSArIG9mZnNldCwgc3BhbkxlYWRpbmdaZXJvZXNTaW1wbGUoZykpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zaW1wbGVHcm91cCA9IHNpbXBsZUdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/v6/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/v6/regular-expressions.js":
/*!****************************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/regular-expressions.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.possibleElisions = exports.simpleRegularExpression = exports.ADDRESS_BOUNDARY = exports.padGroup = exports.groupPossibilities = void 0;\nconst v6 = __importStar(__webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ip-address/dist/v6/constants.js\"));\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"(rsc)/./node_modules/sprintf-js/src/sprintf.js\");\nfunction groupPossibilities(possibilities) {\n    return (0, sprintf_js_1.sprintf)('(%s)', possibilities.join('|'));\n}\nexports.groupPossibilities = groupPossibilities;\nfunction padGroup(group) {\n    if (group.length < 4) {\n        return (0, sprintf_js_1.sprintf)('0{0,%d}%s', 4 - group.length, group);\n    }\n    return group;\n}\nexports.padGroup = padGroup;\nexports.ADDRESS_BOUNDARY = '[^A-Fa-f0-9:]';\nfunction simpleRegularExpression(groups) {\n    const zeroIndexes = [];\n    groups.forEach((group, i) => {\n        const groupInteger = parseInt(group, 16);\n        if (groupInteger === 0) {\n            zeroIndexes.push(i);\n        }\n    });\n    // You can technically elide a single 0, this creates the regular expressions\n    // to match that eventuality\n    const possibilities = zeroIndexes.map((zeroIndex) => groups\n        .map((group, i) => {\n        if (i === zeroIndex) {\n            const elision = i === 0 || i === v6.GROUPS - 1 ? ':' : '';\n            return groupPossibilities([padGroup(group), elision]);\n        }\n        return padGroup(group);\n    })\n        .join(':'));\n    // The simplest case\n    possibilities.push(groups.map(padGroup).join(':'));\n    return groupPossibilities(possibilities);\n}\nexports.simpleRegularExpression = simpleRegularExpression;\nfunction possibleElisions(elidedGroups, moreLeft, moreRight) {\n    const left = moreLeft ? '' : ':';\n    const right = moreRight ? '' : ':';\n    const possibilities = [];\n    // 1. elision of everything (::)\n    if (!moreLeft && !moreRight) {\n        possibilities.push('::');\n    }\n    // 2. complete elision of the middle\n    if (moreLeft && moreRight) {\n        possibilities.push('');\n    }\n    if ((moreRight && !moreLeft) || (!moreRight && moreLeft)) {\n        // 3. complete elision of one side\n        possibilities.push(':');\n    }\n    // 4. elision from the left side\n    possibilities.push((0, sprintf_js_1.sprintf)('%s(:0{1,4}){1,%d}', left, elidedGroups - 1));\n    // 5. elision from the right side\n    possibilities.push((0, sprintf_js_1.sprintf)('(0{1,4}:){1,%d}%s', elidedGroups - 1, right));\n    // 6. no elision\n    possibilities.push((0, sprintf_js_1.sprintf)('(0{1,4}:){%d}0{1,4}', elidedGroups - 1));\n    // 7. elision (including sloppy elision) from the middle\n    for (let groups = 1; groups < elidedGroups - 1; groups++) {\n        for (let position = 1; position < elidedGroups - groups; position++) {\n            possibilities.push((0, sprintf_js_1.sprintf)('(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}', position, elidedGroups - position - groups - 1));\n        }\n    }\n    return groupPossibilities(possibilities);\n}\nexports.possibleElisions = possibleElisions;\n//# sourceMappingURL=regular-expressions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y2L3JlZ3VsYXItZXhwcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLCtCQUErQixHQUFHLHdCQUF3QixHQUFHLGdCQUFnQixHQUFHLDBCQUEwQjtBQUNySSx3QkFBd0IsbUJBQU8sQ0FBQyx5RUFBYTtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQyxrRUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJLEVBQUUsS0FBSztBQUNuRTtBQUNBLHFEQUFxRCxJQUFJLEdBQUcsS0FBSztBQUNqRTtBQUNBLHFEQUFxRCxJQUFJLEdBQUcsR0FBRyxFQUFFLElBQUk7QUFDckU7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BELCtCQUErQixrQ0FBa0M7QUFDakUsNkRBQTZELElBQUksR0FBRyxHQUFHLElBQUksSUFBSSxHQUFHLEdBQUcsRUFBRSxJQUFJO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MyLXNraW4tdHJhY2tlci8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvdjYvcmVndWxhci1leHByZXNzaW9ucy5qcz9iMzU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBvc3NpYmxlRWxpc2lvbnMgPSBleHBvcnRzLnNpbXBsZVJlZ3VsYXJFeHByZXNzaW9uID0gZXhwb3J0cy5BRERSRVNTX0JPVU5EQVJZID0gZXhwb3J0cy5wYWRHcm91cCA9IGV4cG9ydHMuZ3JvdXBQb3NzaWJpbGl0aWVzID0gdm9pZCAwO1xuY29uc3QgdjYgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpKTtcbmNvbnN0IHNwcmludGZfanNfMSA9IHJlcXVpcmUoXCJzcHJpbnRmLWpzXCIpO1xuZnVuY3Rpb24gZ3JvdXBQb3NzaWJpbGl0aWVzKHBvc3NpYmlsaXRpZXMpIHtcbiAgICByZXR1cm4gKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnKCVzKScsIHBvc3NpYmlsaXRpZXMuam9pbignfCcpKTtcbn1cbmV4cG9ydHMuZ3JvdXBQb3NzaWJpbGl0aWVzID0gZ3JvdXBQb3NzaWJpbGl0aWVzO1xuZnVuY3Rpb24gcGFkR3JvdXAoZ3JvdXApIHtcbiAgICBpZiAoZ3JvdXAubGVuZ3RoIDwgNCkge1xuICAgICAgICByZXR1cm4gKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnMHswLCVkfSVzJywgNCAtIGdyb3VwLmxlbmd0aCwgZ3JvdXApO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG59XG5leHBvcnRzLnBhZEdyb3VwID0gcGFkR3JvdXA7XG5leHBvcnRzLkFERFJFU1NfQk9VTkRBUlkgPSAnW15BLUZhLWYwLTk6XSc7XG5mdW5jdGlvbiBzaW1wbGVSZWd1bGFyRXhwcmVzc2lvbihncm91cHMpIHtcbiAgICBjb25zdCB6ZXJvSW5kZXhlcyA9IFtdO1xuICAgIGdyb3Vwcy5mb3JFYWNoKChncm91cCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBncm91cEludGVnZXIgPSBwYXJzZUludChncm91cCwgMTYpO1xuICAgICAgICBpZiAoZ3JvdXBJbnRlZ2VyID09PSAwKSB7XG4gICAgICAgICAgICB6ZXJvSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gWW91IGNhbiB0ZWNobmljYWxseSBlbGlkZSBhIHNpbmdsZSAwLCB0aGlzIGNyZWF0ZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAvLyB0byBtYXRjaCB0aGF0IGV2ZW50dWFsaXR5XG4gICAgY29uc3QgcG9zc2liaWxpdGllcyA9IHplcm9JbmRleGVzLm1hcCgoemVyb0luZGV4KSA9PiBncm91cHNcbiAgICAgICAgLm1hcCgoZ3JvdXAsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IHplcm9JbmRleCkge1xuICAgICAgICAgICAgY29uc3QgZWxpc2lvbiA9IGkgPT09IDAgfHwgaSA9PT0gdjYuR1JPVVBTIC0gMSA/ICc6JyA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwUG9zc2liaWxpdGllcyhbcGFkR3JvdXAoZ3JvdXApLCBlbGlzaW9uXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZEdyb3VwKGdyb3VwKTtcbiAgICB9KVxuICAgICAgICAuam9pbignOicpKTtcbiAgICAvLyBUaGUgc2ltcGxlc3QgY2FzZVxuICAgIHBvc3NpYmlsaXRpZXMucHVzaChncm91cHMubWFwKHBhZEdyb3VwKS5qb2luKCc6JykpO1xuICAgIHJldHVybiBncm91cFBvc3NpYmlsaXRpZXMocG9zc2liaWxpdGllcyk7XG59XG5leHBvcnRzLnNpbXBsZVJlZ3VsYXJFeHByZXNzaW9uID0gc2ltcGxlUmVndWxhckV4cHJlc3Npb247XG5mdW5jdGlvbiBwb3NzaWJsZUVsaXNpb25zKGVsaWRlZEdyb3VwcywgbW9yZUxlZnQsIG1vcmVSaWdodCkge1xuICAgIGNvbnN0IGxlZnQgPSBtb3JlTGVmdCA/ICcnIDogJzonO1xuICAgIGNvbnN0IHJpZ2h0ID0gbW9yZVJpZ2h0ID8gJycgOiAnOic7XG4gICAgY29uc3QgcG9zc2liaWxpdGllcyA9IFtdO1xuICAgIC8vIDEuIGVsaXNpb24gb2YgZXZlcnl0aGluZyAoOjopXG4gICAgaWYgKCFtb3JlTGVmdCAmJiAhbW9yZVJpZ2h0KSB7XG4gICAgICAgIHBvc3NpYmlsaXRpZXMucHVzaCgnOjonKTtcbiAgICB9XG4gICAgLy8gMi4gY29tcGxldGUgZWxpc2lvbiBvZiB0aGUgbWlkZGxlXG4gICAgaWYgKG1vcmVMZWZ0ICYmIG1vcmVSaWdodCkge1xuICAgICAgICBwb3NzaWJpbGl0aWVzLnB1c2goJycpO1xuICAgIH1cbiAgICBpZiAoKG1vcmVSaWdodCAmJiAhbW9yZUxlZnQpIHx8ICghbW9yZVJpZ2h0ICYmIG1vcmVMZWZ0KSkge1xuICAgICAgICAvLyAzLiBjb21wbGV0ZSBlbGlzaW9uIG9mIG9uZSBzaWRlXG4gICAgICAgIHBvc3NpYmlsaXRpZXMucHVzaCgnOicpO1xuICAgIH1cbiAgICAvLyA0LiBlbGlzaW9uIGZyb20gdGhlIGxlZnQgc2lkZVxuICAgIHBvc3NpYmlsaXRpZXMucHVzaCgoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCclcyg6MHsxLDR9KXsxLCVkfScsIGxlZnQsIGVsaWRlZEdyb3VwcyAtIDEpKTtcbiAgICAvLyA1LiBlbGlzaW9uIGZyb20gdGhlIHJpZ2h0IHNpZGVcbiAgICBwb3NzaWJpbGl0aWVzLnB1c2goKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnKDB7MSw0fTopezEsJWR9JXMnLCBlbGlkZWRHcm91cHMgLSAxLCByaWdodCkpO1xuICAgIC8vIDYuIG5vIGVsaXNpb25cbiAgICBwb3NzaWJpbGl0aWVzLnB1c2goKDAsIHNwcmludGZfanNfMS5zcHJpbnRmKSgnKDB7MSw0fTopeyVkfTB7MSw0fScsIGVsaWRlZEdyb3VwcyAtIDEpKTtcbiAgICAvLyA3LiBlbGlzaW9uIChpbmNsdWRpbmcgc2xvcHB5IGVsaXNpb24pIGZyb20gdGhlIG1pZGRsZVxuICAgIGZvciAobGV0IGdyb3VwcyA9IDE7IGdyb3VwcyA8IGVsaWRlZEdyb3VwcyAtIDE7IGdyb3VwcysrKSB7XG4gICAgICAgIGZvciAobGV0IHBvc2l0aW9uID0gMTsgcG9zaXRpb24gPCBlbGlkZWRHcm91cHMgLSBncm91cHM7IHBvc2l0aW9uKyspIHtcbiAgICAgICAgICAgIHBvc3NpYmlsaXRpZXMucHVzaCgoMCwgc3ByaW50Zl9qc18xLnNwcmludGYpKCcoMHsxLDR9Oil7JWR9OigwezEsNH06KXslZH0wezEsNH0nLCBwb3NpdGlvbiwgZWxpZGVkR3JvdXBzIC0gcG9zaXRpb24gLSBncm91cHMgLSAxKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwUG9zc2liaWxpdGllcyhwb3NzaWJpbGl0aWVzKTtcbn1cbmV4cG9ydHMucG9zc2libGVFbGlzaW9ucyA9IHBvc3NpYmxlRWxpc2lvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWd1bGFyLWV4cHJlc3Npb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/v6/regular-expressions.js\n");

/***/ })

};
;