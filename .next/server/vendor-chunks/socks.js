"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socks";
exports.ids = ["vendor-chunks/socks"];
exports.modules = {

/***/ "(rsc)/./node_modules/socks/build/client/socksclient.js":
/*!********************************************************!*\
  !*** ./node_modules/socks/build/client/socksclient.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SocksClientError = exports.SocksClient = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst smart_buffer_1 = __webpack_require__(/*! smart-buffer */ \"(rsc)/./node_modules/smart-buffer/build/smartbuffer.js\");\nconst constants_1 = __webpack_require__(/*! ../common/constants */ \"(rsc)/./node_modules/socks/build/common/constants.js\");\nconst helpers_1 = __webpack_require__(/*! ../common/helpers */ \"(rsc)/./node_modules/socks/build/common/helpers.js\");\nconst receivebuffer_1 = __webpack_require__(/*! ../common/receivebuffer */ \"(rsc)/./node_modules/socks/build/common/receivebuffer.js\");\nconst util_1 = __webpack_require__(/*! ../common/util */ \"(rsc)/./node_modules/socks/build/common/util.js\");\nObject.defineProperty(exports, \"SocksClientError\", ({ enumerable: true, get: function () { return util_1.SocksClientError; } }));\nconst ip_address_1 = __webpack_require__(/*! ip-address */ \"(rsc)/./node_modules/ip-address/dist/ip-address.js\");\nclass SocksClient extends events_1.EventEmitter {\n    constructor(options) {\n        super();\n        this.options = Object.assign({}, options);\n        // Validate SocksClientOptions\n        (0, helpers_1.validateSocksClientOptions)(options);\n        // Default state\n        this.setState(constants_1.SocksClientState.Created);\n    }\n    /**\n     * Creates a new SOCKS connection.\n     *\n     * Note: Supports callbacks and promises. Only supports the connect command.\n     * @param options { SocksClientOptions } Options.\n     * @param callback { Function } An optional callback function.\n     * @returns { Promise }\n     */\n    static createConnection(options, callback) {\n        return new Promise((resolve, reject) => {\n            // Validate SocksClientOptions\n            try {\n                (0, helpers_1.validateSocksClientOptions)(options, ['connect']);\n            }\n            catch (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    return resolve(err); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    return reject(err);\n                }\n            }\n            const client = new SocksClient(options);\n            client.connect(options.existing_socket);\n            client.once('established', (info) => {\n                client.removeAllListeners();\n                if (typeof callback === 'function') {\n                    callback(null, info);\n                    resolve(info); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    resolve(info);\n                }\n            });\n            // Error occurred, failed to establish connection.\n            client.once('error', (err) => {\n                client.removeAllListeners();\n                if (typeof callback === 'function') {\n                    callback(err);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    resolve(err); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.\n     *\n     * Note: Supports callbacks and promises. Only supports the connect method.\n     * Note: Implemented via createConnection() factory function.\n     * @param options { SocksClientChainOptions } Options\n     * @param callback { Function } An optional callback function.\n     * @returns { Promise }\n     */\n    static createConnectionChain(options, callback) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            // Validate SocksClientChainOptions\n            try {\n                (0, helpers_1.validateSocksClientChainOptions)(options);\n            }\n            catch (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    return resolve(err); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    return reject(err);\n                }\n            }\n            // Shuffle proxies\n            if (options.randomizeChain) {\n                (0, util_1.shuffleArray)(options.proxies);\n            }\n            try {\n                let sock;\n                for (let i = 0; i < options.proxies.length; i++) {\n                    const nextProxy = options.proxies[i];\n                    // If we've reached the last proxy in the chain, the destination is the actual destination, otherwise it's the next proxy.\n                    const nextDestination = i === options.proxies.length - 1\n                        ? options.destination\n                        : {\n                            host: options.proxies[i + 1].host ||\n                                options.proxies[i + 1].ipaddress,\n                            port: options.proxies[i + 1].port,\n                        };\n                    // Creates the next connection in the chain.\n                    const result = yield SocksClient.createConnection({\n                        command: 'connect',\n                        proxy: nextProxy,\n                        destination: nextDestination,\n                        existing_socket: sock,\n                    });\n                    // If sock is undefined, assign it here.\n                    sock = sock || result.socket;\n                }\n                if (typeof callback === 'function') {\n                    callback(null, { socket: sock });\n                    resolve({ socket: sock }); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    resolve({ socket: sock });\n                }\n            }\n            catch (err) {\n                if (typeof callback === 'function') {\n                    callback(err);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    resolve(err); // Resolves pending promise (prevents memory leaks).\n                }\n                else {\n                    reject(err);\n                }\n            }\n        }));\n    }\n    /**\n     * Creates a SOCKS UDP Frame.\n     * @param options\n     */\n    static createUDPFrame(options) {\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt16BE(0);\n        buff.writeUInt8(options.frameNumber || 0);\n        // IPv4/IPv6/Hostname\n        if (net.isIPv4(options.remoteHost.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n            buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));\n        }\n        else if (net.isIPv6(options.remoteHost.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n            buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));\n        }\n        else {\n            buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n            buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));\n            buff.writeString(options.remoteHost.host);\n        }\n        // Port\n        buff.writeUInt16BE(options.remoteHost.port);\n        // Data\n        buff.writeBuffer(options.data);\n        return buff.toBuffer();\n    }\n    /**\n     * Parses a SOCKS UDP frame.\n     * @param data\n     */\n    static parseUDPFrame(data) {\n        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n        buff.readOffset = 2;\n        const frameNumber = buff.readUInt8();\n        const hostType = buff.readUInt8();\n        let remoteHost;\n        if (hostType === constants_1.Socks5HostType.IPv4) {\n            remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());\n        }\n        else if (hostType === constants_1.Socks5HostType.IPv6) {\n            remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();\n        }\n        else {\n            remoteHost = buff.readString(buff.readUInt8());\n        }\n        const remotePort = buff.readUInt16BE();\n        return {\n            frameNumber,\n            remoteHost: {\n                host: remoteHost,\n                port: remotePort,\n            },\n            data: buff.readBuffer(),\n        };\n    }\n    /**\n     * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.\n     */\n    setState(newState) {\n        if (this.state !== constants_1.SocksClientState.Error) {\n            this.state = newState;\n        }\n    }\n    /**\n     * Starts the connection establishment to the proxy and destination.\n     * @param existingSocket Connected socket to use instead of creating a new one (internal use).\n     */\n    connect(existingSocket) {\n        this.onDataReceived = (data) => this.onDataReceivedHandler(data);\n        this.onClose = () => this.onCloseHandler();\n        this.onError = (err) => this.onErrorHandler(err);\n        this.onConnect = () => this.onConnectHandler();\n        // Start timeout timer (defaults to 30 seconds)\n        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);\n        // check whether unref is available as it differs from browser to NodeJS (#33)\n        if (timer.unref && typeof timer.unref === 'function') {\n            timer.unref();\n        }\n        // If an existing socket is provided, use it to negotiate SOCKS handshake. Otherwise create a new Socket.\n        if (existingSocket) {\n            this.socket = existingSocket;\n        }\n        else {\n            this.socket = new net.Socket();\n        }\n        // Attach Socket error handlers.\n        this.socket.once('close', this.onClose);\n        this.socket.once('error', this.onError);\n        this.socket.once('connect', this.onConnect);\n        this.socket.on('data', this.onDataReceived);\n        this.setState(constants_1.SocksClientState.Connecting);\n        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();\n        if (existingSocket) {\n            this.socket.emit('connect');\n        }\n        else {\n            this.socket.connect(this.getSocketOptions());\n            if (this.options.set_tcp_nodelay !== undefined &&\n                this.options.set_tcp_nodelay !== null) {\n                this.socket.setNoDelay(!!this.options.set_tcp_nodelay);\n            }\n        }\n        // Listen for established event so we can re-emit any excess data received during handshakes.\n        this.prependOnceListener('established', (info) => {\n            setImmediate(() => {\n                if (this.receiveBuffer.length > 0) {\n                    const excessData = this.receiveBuffer.get(this.receiveBuffer.length);\n                    info.socket.emit('data', excessData);\n                }\n                info.socket.resume();\n            });\n        });\n    }\n    // Socket options (defaults host/port to options.proxy.host/options.proxy.port)\n    getSocketOptions() {\n        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });\n    }\n    /**\n     * Handles internal Socks timeout callback.\n     * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.\n     */\n    onEstablishedTimeout() {\n        if (this.state !== constants_1.SocksClientState.Established &&\n            this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {\n            this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);\n        }\n    }\n    /**\n     * Handles Socket connect event.\n     */\n    onConnectHandler() {\n        this.setState(constants_1.SocksClientState.Connected);\n        // Send initial handshake.\n        if (this.options.proxy.type === 4) {\n            this.sendSocks4InitialHandshake();\n        }\n        else {\n            this.sendSocks5InitialHandshake();\n        }\n        this.setState(constants_1.SocksClientState.SentInitialHandshake);\n    }\n    /**\n     * Handles Socket data event.\n     * @param data\n     */\n    onDataReceivedHandler(data) {\n        /*\n          All received data is appended to a ReceiveBuffer.\n          This makes sure that all the data we need is received before we attempt to process it.\n        */\n        this.receiveBuffer.append(data);\n        // Process data that we have.\n        this.processData();\n    }\n    /**\n     * Handles processing of the data we have received.\n     */\n    processData() {\n        // If we have enough data to process the next step in the SOCKS handshake, proceed.\n        while (this.state !== constants_1.SocksClientState.Established &&\n            this.state !== constants_1.SocksClientState.Error &&\n            this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {\n            // Sent initial handshake, waiting for response.\n            if (this.state === constants_1.SocksClientState.SentInitialHandshake) {\n                if (this.options.proxy.type === 4) {\n                    // Socks v4 only has one handshake response.\n                    this.handleSocks4FinalHandshakeResponse();\n                }\n                else {\n                    // Socks v5 has two handshakes, handle initial one here.\n                    this.handleInitialSocks5HandshakeResponse();\n                }\n                // Sent auth request for Socks v5, waiting for response.\n            }\n            else if (this.state === constants_1.SocksClientState.SentAuthentication) {\n                this.handleInitialSocks5AuthenticationHandshakeResponse();\n                // Sent final Socks v5 handshake, waiting for final response.\n            }\n            else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {\n                this.handleSocks5FinalHandshakeResponse();\n                // Socks BIND established. Waiting for remote connection via proxy.\n            }\n            else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {\n                if (this.options.proxy.type === 4) {\n                    this.handleSocks4IncomingConnectionResponse();\n                }\n                else {\n                    this.handleSocks5IncomingConnectionResponse();\n                }\n            }\n            else {\n                this.closeSocket(constants_1.ERRORS.InternalError);\n                break;\n            }\n        }\n    }\n    /**\n     * Handles Socket close event.\n     * @param had_error\n     */\n    onCloseHandler() {\n        this.closeSocket(constants_1.ERRORS.SocketClosed);\n    }\n    /**\n     * Handles Socket error event.\n     * @param err\n     */\n    onErrorHandler(err) {\n        this.closeSocket(err.message);\n    }\n    /**\n     * Removes internal event listeners on the underlying Socket.\n     */\n    removeInternalSocketHandlers() {\n        // Pauses data flow of the socket (this is internally resumed after 'established' is emitted)\n        this.socket.pause();\n        this.socket.removeListener('data', this.onDataReceived);\n        this.socket.removeListener('close', this.onClose);\n        this.socket.removeListener('error', this.onError);\n        this.socket.removeListener('connect', this.onConnect);\n    }\n    /**\n     * Closes and destroys the underlying Socket. Emits an error event.\n     * @param err { String } An error string to include in error event.\n     */\n    closeSocket(err) {\n        // Make sure only one 'error' event is fired for the lifetime of this SocksClient instance.\n        if (this.state !== constants_1.SocksClientState.Error) {\n            // Set internal state to Error.\n            this.setState(constants_1.SocksClientState.Error);\n            // Destroy Socket\n            this.socket.destroy();\n            // Remove internal listeners\n            this.removeInternalSocketHandlers();\n            // Fire 'error' event.\n            this.emit('error', new util_1.SocksClientError(err, this.options));\n        }\n    }\n    /**\n     * Sends initial Socks v4 handshake request.\n     */\n    sendSocks4InitialHandshake() {\n        const userId = this.options.proxy.userId || '';\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x04);\n        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);\n        buff.writeUInt16BE(this.options.destination.port);\n        // Socks 4 (IPv4)\n        if (net.isIPv4(this.options.destination.host)) {\n            buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));\n            buff.writeStringNT(userId);\n            // Socks 4a (hostname)\n        }\n        else {\n            buff.writeUInt8(0x00);\n            buff.writeUInt8(0x00);\n            buff.writeUInt8(0x00);\n            buff.writeUInt8(0x01);\n            buff.writeStringNT(userId);\n            buff.writeStringNT(this.options.destination.host);\n        }\n        this.nextRequiredPacketBufferSize =\n            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;\n        this.socket.write(buff.toBuffer());\n    }\n    /**\n     * Handles Socks v4 handshake response.\n     * @param data\n     */\n    handleSocks4FinalHandshakeResponse() {\n        const data = this.receiveBuffer.get(8);\n        if (data[1] !== constants_1.Socks4Response.Granted) {\n            this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);\n        }\n        else {\n            // Bind response\n            if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {\n                const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n                buff.readOffset = 2;\n                const remoteHost = {\n                    port: buff.readUInt16BE(),\n                    host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),\n                };\n                // If host is 0.0.0.0, set to proxy host.\n                if (remoteHost.host === '0.0.0.0') {\n                    remoteHost.host = this.options.proxy.ipaddress;\n                }\n                this.setState(constants_1.SocksClientState.BoundWaitingForConnection);\n                this.emit('bound', { remoteHost, socket: this.socket });\n                // Connect response\n            }\n            else {\n                this.setState(constants_1.SocksClientState.Established);\n                this.removeInternalSocketHandlers();\n                this.emit('established', { socket: this.socket });\n            }\n        }\n    }\n    /**\n     * Handles Socks v4 incoming connection request (BIND)\n     * @param data\n     */\n    handleSocks4IncomingConnectionResponse() {\n        const data = this.receiveBuffer.get(8);\n        if (data[1] !== constants_1.Socks4Response.Granted) {\n            this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);\n        }\n        else {\n            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n            buff.readOffset = 2;\n            const remoteHost = {\n                port: buff.readUInt16BE(),\n                host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),\n            };\n            this.setState(constants_1.SocksClientState.Established);\n            this.removeInternalSocketHandlers();\n            this.emit('established', { remoteHost, socket: this.socket });\n        }\n    }\n    /**\n     * Sends initial Socks v5 handshake request.\n     */\n    sendSocks5InitialHandshake() {\n        const buff = new smart_buffer_1.SmartBuffer();\n        // By default we always support no auth.\n        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];\n        // We should only tell the proxy we support user/pass auth if auth info is actually provided.\n        // Note: As of Tor v0.3.5.7+, if user/pass auth is an option from the client, by default it will always take priority.\n        if (this.options.proxy.userId || this.options.proxy.password) {\n            supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);\n        }\n        // Custom auth method?\n        if (this.options.proxy.custom_auth_method !== undefined) {\n            supportedAuthMethods.push(this.options.proxy.custom_auth_method);\n        }\n        // Build handshake packet\n        buff.writeUInt8(0x05);\n        buff.writeUInt8(supportedAuthMethods.length);\n        for (const authMethod of supportedAuthMethods) {\n            buff.writeUInt8(authMethod);\n        }\n        this.nextRequiredPacketBufferSize =\n            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;\n        this.socket.write(buff.toBuffer());\n        this.setState(constants_1.SocksClientState.SentInitialHandshake);\n    }\n    /**\n     * Handles initial Socks v5 handshake response.\n     * @param data\n     */\n    handleInitialSocks5HandshakeResponse() {\n        const data = this.receiveBuffer.get(2);\n        if (data[0] !== 0x05) {\n            this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);\n        }\n        else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {\n            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);\n        }\n        else {\n            // If selected Socks v5 auth method is no auth, send final handshake request.\n            if (data[1] === constants_1.Socks5Auth.NoAuth) {\n                this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;\n                this.sendSocks5CommandRequest();\n                // If selected Socks v5 auth method is user/password, send auth handshake.\n            }\n            else if (data[1] === constants_1.Socks5Auth.UserPass) {\n                this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;\n                this.sendSocks5UserPassAuthentication();\n                // If selected Socks v5 auth method is the custom_auth_method, send custom handshake.\n            }\n            else if (data[1] === this.options.proxy.custom_auth_method) {\n                this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;\n                this.sendSocks5CustomAuthentication();\n            }\n            else {\n                this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);\n            }\n        }\n    }\n    /**\n     * Sends Socks v5 user & password auth handshake.\n     *\n     * Note: No auth and user/pass are currently supported.\n     */\n    sendSocks5UserPassAuthentication() {\n        const userId = this.options.proxy.userId || '';\n        const password = this.options.proxy.password || '';\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x01);\n        buff.writeUInt8(Buffer.byteLength(userId));\n        buff.writeString(userId);\n        buff.writeUInt8(Buffer.byteLength(password));\n        buff.writeString(password);\n        this.nextRequiredPacketBufferSize =\n            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;\n        this.socket.write(buff.toBuffer());\n        this.setState(constants_1.SocksClientState.SentAuthentication);\n    }\n    sendSocks5CustomAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.nextRequiredPacketBufferSize =\n                this.options.proxy.custom_auth_response_size;\n            this.socket.write(yield this.options.proxy.custom_auth_request_handler());\n            this.setState(constants_1.SocksClientState.SentAuthentication);\n        });\n    }\n    handleSocks5CustomAuthHandshakeResponse(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.options.proxy.custom_auth_response_handler(data);\n        });\n    }\n    handleSocks5AuthenticationNoAuthHandshakeResponse(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return data[1] === 0x00;\n        });\n    }\n    handleSocks5AuthenticationUserPassHandshakeResponse(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return data[1] === 0x00;\n        });\n    }\n    /**\n     * Handles Socks v5 auth handshake response.\n     * @param data\n     */\n    handleInitialSocks5AuthenticationHandshakeResponse() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);\n            let authResult = false;\n            if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {\n                authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));\n            }\n            else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {\n                authResult =\n                    yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));\n            }\n            else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {\n                authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));\n            }\n            if (!authResult) {\n                this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);\n            }\n            else {\n                this.sendSocks5CommandRequest();\n            }\n        });\n    }\n    /**\n     * Sends Socks v5 final handshake request.\n     */\n    sendSocks5CommandRequest() {\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x05);\n        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);\n        buff.writeUInt8(0x00);\n        // ipv4, ipv6, domain?\n        if (net.isIPv4(this.options.destination.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n            buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));\n        }\n        else if (net.isIPv6(this.options.destination.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n            buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));\n        }\n        else {\n            buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n            buff.writeUInt8(this.options.destination.host.length);\n            buff.writeString(this.options.destination.host);\n        }\n        buff.writeUInt16BE(this.options.destination.port);\n        this.nextRequiredPacketBufferSize =\n            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n        this.socket.write(buff.toBuffer());\n        this.setState(constants_1.SocksClientState.SentFinalHandshake);\n    }\n    /**\n     * Handles Socks v5 final handshake response.\n     * @param data\n     */\n    handleSocks5FinalHandshakeResponse() {\n        // Peek at available data (we need at least 5 bytes to get the hostname length)\n        const header = this.receiveBuffer.peek(5);\n        if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n            this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);\n        }\n        else {\n            // Read address type\n            const addressType = header[3];\n            let remoteHost;\n            let buff;\n            // IPv4\n            if (addressType === constants_1.Socks5HostType.IPv4) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),\n                    port: buff.readUInt16BE(),\n                };\n                // If given host is 0.0.0.0, assume remote proxy ip instead.\n                if (remoteHost.host === '0.0.0.0') {\n                    remoteHost.host = this.options.proxy.ipaddress;\n                }\n                // Hostname\n            }\n            else if (addressType === constants_1.Socks5HostType.Hostname) {\n                const hostLength = header[4];\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + host + port\n                // Check if data is available.\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));\n                remoteHost = {\n                    host: buff.readString(hostLength),\n                    port: buff.readUInt16BE(),\n                };\n                // IPv6\n            }\n            else if (addressType === constants_1.Socks5HostType.IPv6) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),\n                    port: buff.readUInt16BE(),\n                };\n            }\n            // We have everything we need\n            this.setState(constants_1.SocksClientState.ReceivedFinalResponse);\n            // If using CONNECT, the client is now in the established state.\n            if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {\n                this.setState(constants_1.SocksClientState.Established);\n                this.removeInternalSocketHandlers();\n                this.emit('established', { remoteHost, socket: this.socket });\n            }\n            else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {\n                /* If using BIND, the Socks client is now in BoundWaitingForConnection state.\n                   This means that the remote proxy server is waiting for a remote connection to the bound port. */\n                this.setState(constants_1.SocksClientState.BoundWaitingForConnection);\n                this.nextRequiredPacketBufferSize =\n                    constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n                this.emit('bound', { remoteHost, socket: this.socket });\n                /*\n                  If using Associate, the Socks client is now Established. And the proxy server is now accepting UDP packets at the\n                  given bound port. This initial Socks TCP connection must remain open for the UDP relay to continue to work.\n                */\n            }\n            else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {\n                this.setState(constants_1.SocksClientState.Established);\n                this.removeInternalSocketHandlers();\n                this.emit('established', {\n                    remoteHost,\n                    socket: this.socket,\n                });\n            }\n        }\n    }\n    /**\n     * Handles Socks v5 incoming connection request (BIND).\n     */\n    handleSocks5IncomingConnectionResponse() {\n        // Peek at available data (we need at least 5 bytes to get the hostname length)\n        const header = this.receiveBuffer.peek(5);\n        if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n            this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);\n        }\n        else {\n            // Read address type\n            const addressType = header[3];\n            let remoteHost;\n            let buff;\n            // IPv4\n            if (addressType === constants_1.Socks5HostType.IPv4) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),\n                    port: buff.readUInt16BE(),\n                };\n                // If given host is 0.0.0.0, assume remote proxy ip instead.\n                if (remoteHost.host === '0.0.0.0') {\n                    remoteHost.host = this.options.proxy.ipaddress;\n                }\n                // Hostname\n            }\n            else if (addressType === constants_1.Socks5HostType.Hostname) {\n                const hostLength = header[4];\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + port\n                // Check if data is available.\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));\n                remoteHost = {\n                    host: buff.readString(hostLength),\n                    port: buff.readUInt16BE(),\n                };\n                // IPv6\n            }\n            else if (addressType === constants_1.Socks5HostType.IPv6) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),\n                    port: buff.readUInt16BE(),\n                };\n            }\n            this.setState(constants_1.SocksClientState.Established);\n            this.removeInternalSocketHandlers();\n            this.emit('established', { remoteHost, socket: this.socket });\n        }\n    }\n    get socksClientOptions() {\n        return Object.assign({}, this.options);\n    }\n}\nexports.SocksClient = SocksClient;\n//# sourceMappingURL=socksclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY2xpZW50L3NvY2tzY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxtQkFBbUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLHVCQUF1QixtQkFBTyxDQUFDLDRFQUFjO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFxQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBbUI7QUFDN0Msd0JBQXdCLG1CQUFPLENBQUMseUZBQXlCO0FBQ3pELGVBQWUsbUJBQU8sQ0FBQyx1RUFBZ0I7QUFDdkMsb0RBQW1ELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzlILHFCQUFxQixtQkFBTyxDQUFDLHNFQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDLHlCQUF5QixXQUFXO0FBQ3BDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xELHlCQUF5QixXQUFXO0FBQ3BDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQsOEJBQThCLGNBQWMsR0FBRztBQUMvQztBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0NBQWtDLDhGQUE4RjtBQUM3SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtEQUFrRCxLQUFLLG9DQUFvQztBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUErRCxLQUFLLG9DQUFvQztBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQ0FBaUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUF3RCxJQUFJLHNDQUFzQztBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUNBQWlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUErRCxJQUFJLHNDQUFzQztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlDQUFpQztBQUN4RTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NzMi1za2luLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY2xpZW50L3NvY2tzY2xpZW50LmpzPzgxMjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja3NDbGllbnRFcnJvciA9IGV4cG9ydHMuU29ja3NDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBuZXQgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3Qgc21hcnRfYnVmZmVyXzEgPSByZXF1aXJlKFwic21hcnQtYnVmZmVyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaGVscGVyc1wiKTtcbmNvbnN0IHJlY2VpdmVidWZmZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcmVjZWl2ZWJ1ZmZlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdXRpbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tzQ2xpZW50RXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yOyB9IH0pO1xuY29uc3QgaXBfYWRkcmVzc18xID0gcmVxdWlyZShcImlwLWFkZHJlc3NcIik7XG5jbGFzcyBTb2Nrc0NsaWVudCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgU29ja3NDbGllbnRPcHRpb25zXG4gICAgICAgICgwLCBoZWxwZXJzXzEudmFsaWRhdGVTb2Nrc0NsaWVudE9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICAvLyBEZWZhdWx0IHN0YXRlXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5DcmVhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTT0NLUyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogTm90ZTogU3VwcG9ydHMgY2FsbGJhY2tzIGFuZCBwcm9taXNlcy4gT25seSBzdXBwb3J0cyB0aGUgY29ubmVjdCBjb21tYW5kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHsgU29ja3NDbGllbnRPcHRpb25zIH0gT3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgeyBGdW5jdGlvbiB9IEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHsgUHJvbWlzZSB9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIFNvY2tzQ2xpZW50T3B0aW9uc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAoMCwgaGVscGVyc18xLnZhbGlkYXRlU29ja3NDbGllbnRPcHRpb25zKShvcHRpb25zLCBbJ2Nvbm5lY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShlcnIpOyAvLyBSZXNvbHZlcyBwZW5kaW5nIHByb21pc2UgKHByZXZlbnRzIG1lbW9yeSBsZWFrcykuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IFNvY2tzQ2xpZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgY2xpZW50LmNvbm5lY3Qob3B0aW9ucy5leGlzdGluZ19zb2NrZXQpO1xuICAgICAgICAgICAgY2xpZW50Lm9uY2UoJ2VzdGFibGlzaGVkJywgKGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBjbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbmZvKTsgLy8gUmVzb2x2ZXMgcGVuZGluZyBwcm9taXNlIChwcmV2ZW50cyBtZW1vcnkgbGVha3MpLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEVycm9yIG9jY3VycmVkLCBmYWlsZWQgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICBjbGllbnQub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlcnIpOyAvLyBSZXNvbHZlcyBwZW5kaW5nIHByb21pc2UgKHByZXZlbnRzIG1lbW9yeSBsZWFrcykuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU09DS1MgY29ubmVjdGlvbiBjaGFpbiB0byBhIGRlc3RpbmF0aW9uIGhvc3QgdGhyb3VnaCAyIG9yIG1vcmUgU09DS1MgcHJveGllcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFN1cHBvcnRzIGNhbGxiYWNrcyBhbmQgcHJvbWlzZXMuIE9ubHkgc3VwcG9ydHMgdGhlIGNvbm5lY3QgbWV0aG9kLlxuICAgICAqIE5vdGU6IEltcGxlbWVudGVkIHZpYSBjcmVhdGVDb25uZWN0aW9uKCkgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7IFNvY2tzQ2xpZW50Q2hhaW5PcHRpb25zIH0gT3B0aW9uc1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7IEZ1bmN0aW9uIH0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMgeyBQcm9taXNlIH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29ubmVjdGlvbkNoYWluKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBTb2Nrc0NsaWVudENoYWluT3B0aW9uc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAoMCwgaGVscGVyc18xLnZhbGlkYXRlU29ja3NDbGllbnRDaGFpbk9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZXJyKTsgLy8gUmVzb2x2ZXMgcGVuZGluZyBwcm9taXNlIChwcmV2ZW50cyBtZW1vcnkgbGVha3MpLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNodWZmbGUgcHJveGllc1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmFuZG9taXplQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLnNodWZmbGVBcnJheSkob3B0aW9ucy5wcm94aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHNvY2s7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLnByb3hpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFByb3h5ID0gb3B0aW9ucy5wcm94aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoZSBsYXN0IHByb3h5IGluIHRoZSBjaGFpbiwgdGhlIGRlc3RpbmF0aW9uIGlzIHRoZSBhY3R1YWwgZGVzdGluYXRpb24sIG90aGVyd2lzZSBpdCdzIHRoZSBuZXh0IHByb3h5LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVzdGluYXRpb24gPSBpID09PSBvcHRpb25zLnByb3hpZXMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmRlc3RpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBvcHRpb25zLnByb3hpZXNbaSArIDFdLmhvc3QgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm94aWVzW2kgKyAxXS5pcGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wcm94aWVzW2kgKyAxXS5wb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyB0aGUgbmV4dCBjb25uZWN0aW9uIGluIHRoZSBjaGFpbi5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgU29ja3NDbGllbnQuY3JlYXRlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eTogbmV4dFByb3h5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb246IG5leHREZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nX3NvY2tldDogc29jayxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNvY2sgaXMgdW5kZWZpbmVkLCBhc3NpZ24gaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgc29jayA9IHNvY2sgfHwgcmVzdWx0LnNvY2tldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IHNvY2tldDogc29jayB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHNvY2tldDogc29jayB9KTsgLy8gUmVzb2x2ZXMgcGVuZGluZyBwcm9taXNlIChwcmV2ZW50cyBtZW1vcnkgbGVha3MpLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHNvY2tldDogc29jayB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGVycik7IC8vIFJlc29sdmVzIHBlbmRpbmcgcHJvbWlzZSAocHJldmVudHMgbWVtb3J5IGxlYWtzKS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgU09DS1MgVURQIEZyYW1lLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVVEUEZyYW1lKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlcigpO1xuICAgICAgICBidWZmLndyaXRlVUludDE2QkUoMCk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50OChvcHRpb25zLmZyYW1lTnVtYmVyIHx8IDApO1xuICAgICAgICAvLyBJUHY0L0lQdjYvSG9zdG5hbWVcbiAgICAgICAgaWYgKG5ldC5pc0lQdjQob3B0aW9ucy5yZW1vdGVIb3N0Lmhvc3QpKSB7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoY29uc3RhbnRzXzEuU29ja3M1SG9zdFR5cGUuSVB2NCk7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDMyQkUoKDAsIGhlbHBlcnNfMS5pcHY0VG9JbnQzMikob3B0aW9ucy5yZW1vdGVIb3N0Lmhvc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXQuaXNJUHY2KG9wdGlvbnMucmVtb3RlSG9zdC5ob3N0KSkge1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLklQdjYpO1xuICAgICAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcigoMCwgaGVscGVyc18xLmlwVG9CdWZmZXIpKG9wdGlvbnMucmVtb3RlSG9zdC5ob3N0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoY29uc3RhbnRzXzEuU29ja3M1SG9zdFR5cGUuSG9zdG5hbWUpO1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMucmVtb3RlSG9zdC5ob3N0KSk7XG4gICAgICAgICAgICBidWZmLndyaXRlU3RyaW5nKG9wdGlvbnMucmVtb3RlSG9zdC5ob3N0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3J0XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50MTZCRShvcHRpb25zLnJlbW90ZUhvc3QucG9ydCk7XG4gICAgICAgIC8vIERhdGFcbiAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcihvcHRpb25zLmRhdGEpO1xuICAgICAgICByZXR1cm4gYnVmZi50b0J1ZmZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBTT0NLUyBVRFAgZnJhbWUuXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VVRFBGcmFtZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlci5mcm9tQnVmZmVyKGRhdGEpO1xuICAgICAgICBidWZmLnJlYWRPZmZzZXQgPSAyO1xuICAgICAgICBjb25zdCBmcmFtZU51bWJlciA9IGJ1ZmYucmVhZFVJbnQ4KCk7XG4gICAgICAgIGNvbnN0IGhvc3RUeXBlID0gYnVmZi5yZWFkVUludDgoKTtcbiAgICAgICAgbGV0IHJlbW90ZUhvc3Q7XG4gICAgICAgIGlmIChob3N0VHlwZSA9PT0gY29uc3RhbnRzXzEuU29ja3M1SG9zdFR5cGUuSVB2NCkge1xuICAgICAgICAgICAgcmVtb3RlSG9zdCA9ICgwLCBoZWxwZXJzXzEuaW50MzJUb0lwdjQpKGJ1ZmYucmVhZFVJbnQzMkJFKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvc3RUeXBlID09PSBjb25zdGFudHNfMS5Tb2NrczVIb3N0VHlwZS5JUHY2KSB7XG4gICAgICAgICAgICByZW1vdGVIb3N0ID0gaXBfYWRkcmVzc18xLkFkZHJlc3M2LmZyb21CeXRlQXJyYXkoQXJyYXkuZnJvbShidWZmLnJlYWRCdWZmZXIoMTYpKSkuY2Fub25pY2FsRm9ybSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3RlSG9zdCA9IGJ1ZmYucmVhZFN0cmluZyhidWZmLnJlYWRVSW50OCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdGVQb3J0ID0gYnVmZi5yZWFkVUludDE2QkUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyYW1lTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3RlSG9zdDoge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHJlbW90ZUhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogcmVtb3RlUG9ydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiBidWZmLnJlYWRCdWZmZXIoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgc3RhdGUgc2V0dGVyLiBJZiB0aGUgU29ja3NDbGllbnQgaXMgaW4gYW4gZXJyb3Igc3RhdGUsIGl0IGNhbm5vdCBiZSBjaGFuZ2VkIHRvIGEgbm9uIGVycm9yIHN0YXRlLlxuICAgICAqL1xuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQgdG8gdGhlIHByb3h5IGFuZCBkZXN0aW5hdGlvbi5cbiAgICAgKiBAcGFyYW0gZXhpc3RpbmdTb2NrZXQgQ29ubmVjdGVkIHNvY2tldCB0byB1c2UgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUgKGludGVybmFsIHVzZSkuXG4gICAgICovXG4gICAgY29ubmVjdChleGlzdGluZ1NvY2tldCkge1xuICAgICAgICB0aGlzLm9uRGF0YVJlY2VpdmVkID0gKGRhdGEpID0+IHRoaXMub25EYXRhUmVjZWl2ZWRIYW5kbGVyKGRhdGEpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSAoKSA9PiB0aGlzLm9uQ2xvc2VIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMub25FcnJvciA9IChlcnIpID0+IHRoaXMub25FcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3QgPSAoKSA9PiB0aGlzLm9uQ29ubmVjdEhhbmRsZXIoKTtcbiAgICAgICAgLy8gU3RhcnQgdGltZW91dCB0aW1lciAoZGVmYXVsdHMgdG8gMzAgc2Vjb25kcylcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25Fc3RhYmxpc2hlZFRpbWVvdXQoKSwgdGhpcy5vcHRpb25zLnRpbWVvdXQgfHwgY29uc3RhbnRzXzEuREVGQVVMVF9USU1FT1VUKTtcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciB1bnJlZiBpcyBhdmFpbGFibGUgYXMgaXQgZGlmZmVycyBmcm9tIGJyb3dzZXIgdG8gTm9kZUpTICgjMzMpXG4gICAgICAgIGlmICh0aW1lci51bnJlZiAmJiB0eXBlb2YgdGltZXIudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYW4gZXhpc3Rpbmcgc29ja2V0IGlzIHByb3ZpZGVkLCB1c2UgaXQgdG8gbmVnb3RpYXRlIFNPQ0tTIGhhbmRzaGFrZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBTb2NrZXQuXG4gICAgICAgIGlmIChleGlzdGluZ1NvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBleGlzdGluZ1NvY2tldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gbmV3IG5ldC5Tb2NrZXQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdHRhY2ggU29ja2V0IGVycm9yIGhhbmRsZXJzLlxuICAgICAgICB0aGlzLnNvY2tldC5vbmNlKCdjbG9zZScsIHRoaXMub25DbG9zZSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2UoJ2Vycm9yJywgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25jZSgnY29ubmVjdCcsIHRoaXMub25Db25uZWN0KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2RhdGEnLCB0aGlzLm9uRGF0YVJlY2VpdmVkKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkNvbm5lY3RpbmcpO1xuICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBuZXcgcmVjZWl2ZWJ1ZmZlcl8xLlJlY2VpdmVCdWZmZXIoKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nU29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdjb25uZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KHRoaXMuZ2V0U29ja2V0T3B0aW9ucygpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2V0X3RjcF9ub2RlbGF5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2V0X3RjcF9ub2RlbGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2V0Tm9EZWxheSghIXRoaXMub3B0aW9ucy5zZXRfdGNwX25vZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExpc3RlbiBmb3IgZXN0YWJsaXNoZWQgZXZlbnQgc28gd2UgY2FuIHJlLWVtaXQgYW55IGV4Y2VzcyBkYXRhIHJlY2VpdmVkIGR1cmluZyBoYW5kc2hha2VzLlxuICAgICAgICB0aGlzLnByZXBlbmRPbmNlTGlzdGVuZXIoJ2VzdGFibGlzaGVkJywgKGluZm8pID0+IHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2Vzc0RhdGEgPSB0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNvY2tldC5lbWl0KCdkYXRhJywgZXhjZXNzRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZm8uc29ja2V0LnJlc3VtZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTb2NrZXQgb3B0aW9ucyAoZGVmYXVsdHMgaG9zdC9wb3J0IHRvIG9wdGlvbnMucHJveHkuaG9zdC9vcHRpb25zLnByb3h5LnBvcnQpXG4gICAgZ2V0U29ja2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLnNvY2tldF9vcHRpb25zKSwgeyBob3N0OiB0aGlzLm9wdGlvbnMucHJveHkuaG9zdCB8fCB0aGlzLm9wdGlvbnMucHJveHkuaXBhZGRyZXNzLCBwb3J0OiB0aGlzLm9wdGlvbnMucHJveHkucG9ydCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBpbnRlcm5hbCBTb2NrcyB0aW1lb3V0IGNhbGxiYWNrLlxuICAgICAqIE5vdGU6IElmIHRoZSBTb2NrcyBjbGllbnQgaXMgbm90IEJvdW5kV2FpdGluZ0ZvckNvbm5lY3Rpb24gb3IgRXN0YWJsaXNoZWQsIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgY2xvc2VkLlxuICAgICAqL1xuICAgIG9uRXN0YWJsaXNoZWRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Fc3RhYmxpc2hlZCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Cb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU29ja2V0KGNvbnN0YW50c18xLkVSUk9SUy5Qcm94eUNvbm5lY3Rpb25UaW1lZE91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBTb2NrZXQgY29ubmVjdCBldmVudC5cbiAgICAgKi9cbiAgICBvbkNvbm5lY3RIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgICAgLy8gU2VuZCBpbml0aWFsIGhhbmRzaGFrZS5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm94eS50eXBlID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRTb2NrczRJbml0aWFsSGFuZHNoYWtlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRTb2NrczVJbml0aWFsSGFuZHNoYWtlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLlNlbnRJbml0aWFsSGFuZHNoYWtlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBTb2NrZXQgZGF0YSBldmVudC5cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uRGF0YVJlY2VpdmVkSGFuZGxlcihkYXRhKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgQWxsIHJlY2VpdmVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gYSBSZWNlaXZlQnVmZmVyLlxuICAgICAgICAgIFRoaXMgbWFrZXMgc3VyZSB0aGF0IGFsbCB0aGUgZGF0YSB3ZSBuZWVkIGlzIHJlY2VpdmVkIGJlZm9yZSB3ZSBhdHRlbXB0IHRvIHByb2Nlc3MgaXQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5hcHBlbmQoZGF0YSk7XG4gICAgICAgIC8vIFByb2Nlc3MgZGF0YSB0aGF0IHdlIGhhdmUuXG4gICAgICAgIHRoaXMucHJvY2Vzc0RhdGEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBwcm9jZXNzaW5nIG9mIHRoZSBkYXRhIHdlIGhhdmUgcmVjZWl2ZWQuXG4gICAgICovXG4gICAgcHJvY2Vzc0RhdGEoKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgZW5vdWdoIGRhdGEgdG8gcHJvY2VzcyB0aGUgbmV4dCBzdGVwIGluIHRoZSBTT0NLUyBoYW5kc2hha2UsIHByb2NlZWQuXG4gICAgICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVzdGFibGlzaGVkICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVycm9yICYmXG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoID49IHRoaXMubmV4dFJlcXVpcmVkUGFja2V0QnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgLy8gU2VudCBpbml0aWFsIGhhbmRzaGFrZSwgd2FpdGluZyBmb3IgcmVzcG9uc2UuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5TZW50SW5pdGlhbEhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJveHkudHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb2NrcyB2NCBvbmx5IGhhcyBvbmUgaGFuZHNoYWtlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNvY2tzNEZpbmFsSGFuZHNoYWtlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvY2tzIHY1IGhhcyB0d28gaGFuZHNoYWtlcywgaGFuZGxlIGluaXRpYWwgb25lIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5pdGlhbFNvY2tzNUhhbmRzaGFrZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlbnQgYXV0aCByZXF1ZXN0IGZvciBTb2NrcyB2NSwgd2FpdGluZyBmb3IgcmVzcG9uc2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLlNlbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5pdGlhbFNvY2tzNUF1dGhlbnRpY2F0aW9uSGFuZHNoYWtlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBTZW50IGZpbmFsIFNvY2tzIHY1IGhhbmRzaGFrZSwgd2FpdGluZyBmb3IgZmluYWwgcmVzcG9uc2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLlNlbnRGaW5hbEhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU29ja3M1RmluYWxIYW5kc2hha2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIC8vIFNvY2tzIEJJTkQgZXN0YWJsaXNoZWQuIFdhaXRpbmcgZm9yIHJlbW90ZSBjb25uZWN0aW9uIHZpYSBwcm94eS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuQm91bmRXYWl0aW5nRm9yQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJveHkudHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNvY2tzNEluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNvY2tzNUluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChjb25zdGFudHNfMS5FUlJPUlMuSW50ZXJuYWxFcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBTb2NrZXQgY2xvc2UgZXZlbnQuXG4gICAgICogQHBhcmFtIGhhZF9lcnJvclxuICAgICAqL1xuICAgIG9uQ2xvc2VIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmNsb3NlU29ja2V0KGNvbnN0YW50c18xLkVSUk9SUy5Tb2NrZXRDbG9zZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIFNvY2tldCBlcnJvciBldmVudC5cbiAgICAgKiBAcGFyYW0gZXJyXG4gICAgICovXG4gICAgb25FcnJvckhhbmRsZXIoZXJyKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoZXJyLm1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGludGVybmFsIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgdW5kZXJseWluZyBTb2NrZXQuXG4gICAgICovXG4gICAgcmVtb3ZlSW50ZXJuYWxTb2NrZXRIYW5kbGVycygpIHtcbiAgICAgICAgLy8gUGF1c2VzIGRhdGEgZmxvdyBvZiB0aGUgc29ja2V0ICh0aGlzIGlzIGludGVybmFsbHkgcmVzdW1lZCBhZnRlciAnZXN0YWJsaXNoZWQnIGlzIGVtaXR0ZWQpXG4gICAgICAgIHRoaXMuc29ja2V0LnBhdXNlKCk7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgdGhpcy5vbkRhdGFSZWNlaXZlZCk7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHRoaXMub25DbG9zZSk7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMub25FcnJvcik7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgdGhpcy5vbkNvbm5lY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYW5kIGRlc3Ryb3lzIHRoZSB1bmRlcmx5aW5nIFNvY2tldC4gRW1pdHMgYW4gZXJyb3IgZXZlbnQuXG4gICAgICogQHBhcmFtIGVyciB7IFN0cmluZyB9IEFuIGVycm9yIHN0cmluZyB0byBpbmNsdWRlIGluIGVycm9yIGV2ZW50LlxuICAgICAqL1xuICAgIGNsb3NlU29ja2V0KGVycikge1xuICAgICAgICAvLyBNYWtlIHN1cmUgb25seSBvbmUgJ2Vycm9yJyBldmVudCBpcyBmaXJlZCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoaXMgU29ja3NDbGllbnQgaW5zdGFuY2UuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVycm9yKSB7XG4gICAgICAgICAgICAvLyBTZXQgaW50ZXJuYWwgc3RhdGUgdG8gRXJyb3IuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuRXJyb3IpO1xuICAgICAgICAgICAgLy8gRGVzdHJveSBTb2NrZXRcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBpbnRlcm5hbCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW50ZXJuYWxTb2NrZXRIYW5kbGVycygpO1xuICAgICAgICAgICAgLy8gRmlyZSAnZXJyb3InIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihlcnIsIHRoaXMub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGluaXRpYWwgU29ja3MgdjQgaGFuZHNoYWtlIHJlcXVlc3QuXG4gICAgICovXG4gICAgc2VuZFNvY2tzNEluaXRpYWxIYW5kc2hha2UoKSB7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHRoaXMub3B0aW9ucy5wcm94eS51c2VySWQgfHwgJyc7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIoKTtcbiAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDQpO1xuICAgICAgICBidWZmLndyaXRlVUludDgoY29uc3RhbnRzXzEuU29ja3NDb21tYW5kW3RoaXMub3B0aW9ucy5jb21tYW5kXSk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50MTZCRSh0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24ucG9ydCk7XG4gICAgICAgIC8vIFNvY2tzIDQgKElQdjQpXG4gICAgICAgIGlmIChuZXQuaXNJUHY0KHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KSkge1xuICAgICAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcigoMCwgaGVscGVyc18xLmlwVG9CdWZmZXIpKHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KSk7XG4gICAgICAgICAgICBidWZmLndyaXRlU3RyaW5nTlQodXNlcklkKTtcbiAgICAgICAgICAgIC8vIFNvY2tzIDRhIChob3N0bmFtZSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAwKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAwKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAwKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAxKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVTdHJpbmdOVCh1c2VySWQpO1xuICAgICAgICAgICAgYnVmZi53cml0ZVN0cmluZ05UKHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPVxuICAgICAgICAgICAgY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNFJlc3BvbnNlO1xuICAgICAgICB0aGlzLnNvY2tldC53cml0ZShidWZmLnRvQnVmZmVyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIFNvY2tzIHY0IGhhbmRzaGFrZSByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGhhbmRsZVNvY2tzNEZpbmFsSGFuZHNoYWtlUmVzcG9uc2UoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KDgpO1xuICAgICAgICBpZiAoZGF0YVsxXSAhPT0gY29uc3RhbnRzXzEuU29ja3M0UmVzcG9uc2UuR3JhbnRlZCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChgJHtjb25zdGFudHNfMS5FUlJPUlMuU29ja3M0UHJveHlSZWplY3RlZENvbm5lY3Rpb259IC0gKCR7Y29uc3RhbnRzXzEuU29ja3M0UmVzcG9uc2VbZGF0YVsxXV19KWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQmluZCByZXNwb25zZVxuICAgICAgICAgICAgaWYgKGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZFt0aGlzLm9wdGlvbnMuY29tbWFuZF0gPT09IGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZC5iaW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IHNtYXJ0X2J1ZmZlcl8xLlNtYXJ0QnVmZmVyLmZyb21CdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICAgICAgYnVmZi5yZWFkT2Zmc2V0ID0gMjtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3J0OiBidWZmLnJlYWRVSW50MTZCRSgpLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiAoMCwgaGVscGVyc18xLmludDMyVG9JcHY0KShidWZmLnJlYWRVSW50MzJCRSgpKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElmIGhvc3QgaXMgMC4wLjAuMCwgc2V0IHRvIHByb3h5IGhvc3QuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZUhvc3QuaG9zdCA9PT0gJzAuMC4wLjAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUhvc3QuaG9zdCA9IHRoaXMub3B0aW9ucy5wcm94eS5pcGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Cb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2JvdW5kJywgeyByZW1vdGVIb3N0LCBzb2NrZXQ6IHRoaXMuc29ja2V0IH0pO1xuICAgICAgICAgICAgICAgIC8vIENvbm5lY3QgcmVzcG9uc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Fc3RhYmxpc2hlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJbnRlcm5hbFNvY2tldEhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlc3RhYmxpc2hlZCcsIHsgc29ja2V0OiB0aGlzLnNvY2tldCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIFNvY2tzIHY0IGluY29taW5nIGNvbm5lY3Rpb24gcmVxdWVzdCAoQklORClcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGhhbmRsZVNvY2tzNEluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5yZWNlaXZlQnVmZmVyLmdldCg4KTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGNvbnN0YW50c18xLlNvY2tzNFJlc3BvbnNlLkdyYW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoYCR7Y29uc3RhbnRzXzEuRVJST1JTLlNvY2tzNFByb3h5UmVqZWN0ZWRJbmNvbWluZ0JvdW5kQ29ubmVjdGlvbn0gLSAoJHtjb25zdGFudHNfMS5Tb2NrczRSZXNwb25zZVtkYXRhWzFdXX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIuZnJvbUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIGJ1ZmYucmVhZE9mZnNldCA9IDI7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgIHBvcnQ6IGJ1ZmYucmVhZFVJbnQxNkJFKCksXG4gICAgICAgICAgICAgICAgaG9zdDogKDAsIGhlbHBlcnNfMS5pbnQzMlRvSXB2NCkoYnVmZi5yZWFkVUludDMyQkUoKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVzdGFibGlzaGVkKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW50ZXJuYWxTb2NrZXRIYW5kbGVycygpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlc3RhYmxpc2hlZCcsIHsgcmVtb3RlSG9zdCwgc29ja2V0OiB0aGlzLnNvY2tldCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBpbml0aWFsIFNvY2tzIHY1IGhhbmRzaGFrZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNlbmRTb2NrczVJbml0aWFsSGFuZHNoYWtlKCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IHNtYXJ0X2J1ZmZlcl8xLlNtYXJ0QnVmZmVyKCk7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgd2UgYWx3YXlzIHN1cHBvcnQgbm8gYXV0aC5cbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkQXV0aE1ldGhvZHMgPSBbY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Ob0F1dGhdO1xuICAgICAgICAvLyBXZSBzaG91bGQgb25seSB0ZWxsIHRoZSBwcm94eSB3ZSBzdXBwb3J0IHVzZXIvcGFzcyBhdXRoIGlmIGF1dGggaW5mbyBpcyBhY3R1YWxseSBwcm92aWRlZC5cbiAgICAgICAgLy8gTm90ZTogQXMgb2YgVG9yIHYwLjMuNS43KywgaWYgdXNlci9wYXNzIGF1dGggaXMgYW4gb3B0aW9uIGZyb20gdGhlIGNsaWVudCwgYnkgZGVmYXVsdCBpdCB3aWxsIGFsd2F5cyB0YWtlIHByaW9yaXR5LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb3h5LnVzZXJJZCB8fCB0aGlzLm9wdGlvbnMucHJveHkucGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZEF1dGhNZXRob2RzLnB1c2goY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Vc2VyUGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3VzdG9tIGF1dGggbWV0aG9kP1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb3h5LmN1c3RvbV9hdXRoX21ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWRBdXRoTWV0aG9kcy5wdXNoKHRoaXMub3B0aW9ucy5wcm94eS5jdXN0b21fYXV0aF9tZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIGhhbmRzaGFrZSBwYWNrZXRcbiAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDUpO1xuICAgICAgICBidWZmLndyaXRlVUludDgoc3VwcG9ydGVkQXV0aE1ldGhvZHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChjb25zdCBhdXRoTWV0aG9kIG9mIHN1cHBvcnRlZEF1dGhNZXRob2RzKSB7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoYXV0aE1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID1cbiAgICAgICAgICAgIGNvbnN0YW50c18xLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUy5Tb2NrczVJbml0aWFsSGFuZHNoYWtlUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuc29ja2V0LndyaXRlKGJ1ZmYudG9CdWZmZXIoKSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5TZW50SW5pdGlhbEhhbmRzaGFrZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgaW5pdGlhbCBTb2NrcyB2NSBoYW5kc2hha2UgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVJbml0aWFsU29ja3M1SGFuZHNoYWtlUmVzcG9uc2UoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KDIpO1xuICAgICAgICBpZiAoZGF0YVswXSAhPT0gMHgwNSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzNUludGlhaWxIYW5kc2hha2VTb2Nrc1ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFbMV0gPT09IGNvbnN0YW50c18xLlNPQ0tTNV9OT19BQ0NFUFRBQkxFX0FVVEgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2NrczVJbml0aWFsSGFuZHNoYWtlTm9BY2NlcHRlZEF1dGhUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHNlbGVjdGVkIFNvY2tzIHY1IGF1dGggbWV0aG9kIGlzIG5vIGF1dGgsIHNlbmQgZmluYWwgaGFuZHNoYWtlIHJlcXVlc3QuXG4gICAgICAgICAgICBpZiAoZGF0YVsxXSA9PT0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Ob0F1dGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tzNUNob3NlbkF1dGhUeXBlID0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Ob0F1dGg7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU29ja3M1Q29tbWFuZFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBzZWxlY3RlZCBTb2NrcyB2NSBhdXRoIG1ldGhvZCBpcyB1c2VyL3Bhc3N3b3JkLCBzZW5kIGF1dGggaGFuZHNoYWtlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVsxXSA9PT0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Vc2VyUGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja3M1Q2hvc2VuQXV0aFR5cGUgPSBjb25zdGFudHNfMS5Tb2NrczVBdXRoLlVzZXJQYXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFNvY2tzNVVzZXJQYXNzQXV0aGVudGljYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBzZWxlY3RlZCBTb2NrcyB2NSBhdXRoIG1ldGhvZCBpcyB0aGUgY3VzdG9tX2F1dGhfbWV0aG9kLCBzZW5kIGN1c3RvbSBoYW5kc2hha2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhWzFdID09PSB0aGlzLm9wdGlvbnMucHJveHkuY3VzdG9tX2F1dGhfbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrczVDaG9zZW5BdXRoVHlwZSA9IHRoaXMub3B0aW9ucy5wcm94eS5jdXN0b21fYXV0aF9tZXRob2Q7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU29ja3M1Q3VzdG9tQXV0aGVudGljYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2NrczVJbml0aWFsSGFuZHNoYWtlVW5rbm93bkF1dGhUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBTb2NrcyB2NSB1c2VyICYgcGFzc3dvcmQgYXV0aCBoYW5kc2hha2UuXG4gICAgICpcbiAgICAgKiBOb3RlOiBObyBhdXRoIGFuZCB1c2VyL3Bhc3MgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgc2VuZFNvY2tzNVVzZXJQYXNzQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHRoaXMub3B0aW9ucy5wcm94eS51c2VySWQgfHwgJyc7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gdGhpcy5vcHRpb25zLnByb3h5LnBhc3N3b3JkIHx8ICcnO1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IHNtYXJ0X2J1ZmZlcl8xLlNtYXJ0QnVmZmVyKCk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAxKTtcbiAgICAgICAgYnVmZi53cml0ZVVJbnQ4KEJ1ZmZlci5ieXRlTGVuZ3RoKHVzZXJJZCkpO1xuICAgICAgICBidWZmLndyaXRlU3RyaW5nKHVzZXJJZCk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50OChCdWZmZXIuYnl0ZUxlbmd0aChwYXNzd29yZCkpO1xuICAgICAgICBidWZmLndyaXRlU3RyaW5nKHBhc3N3b3JkKTtcbiAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID1cbiAgICAgICAgICAgIGNvbnN0YW50c18xLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUy5Tb2NrczVVc2VyUGFzc0F1dGhlbnRpY2F0aW9uUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuc29ja2V0LndyaXRlKGJ1ZmYudG9CdWZmZXIoKSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5TZW50QXV0aGVudGljYXRpb24pO1xuICAgIH1cbiAgICBzZW5kU29ja3M1Q3VzdG9tQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPVxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wcm94eS5jdXN0b21fYXV0aF9yZXNwb25zZV9zaXplO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUoeWllbGQgdGhpcy5vcHRpb25zLnByb3h5LmN1c3RvbV9hdXRoX3JlcXVlc3RfaGFuZGxlcigpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5TZW50QXV0aGVudGljYXRpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU29ja3M1Q3VzdG9tQXV0aEhhbmRzaGFrZVJlc3BvbnNlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLm9wdGlvbnMucHJveHkuY3VzdG9tX2F1dGhfcmVzcG9uc2VfaGFuZGxlcihkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNvY2tzNUF1dGhlbnRpY2F0aW9uTm9BdXRoSGFuZHNoYWtlUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbMV0gPT09IDB4MDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTb2NrczVBdXRoZW50aWNhdGlvblVzZXJQYXNzSGFuZHNoYWtlUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbMV0gPT09IDB4MDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIFNvY2tzIHY1IGF1dGggaGFuZHNoYWtlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgaGFuZGxlSW5pdGlhbFNvY2tzNUF1dGhlbnRpY2F0aW9uSGFuZHNoYWtlUmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuUmVjZWl2ZWRBdXRoZW50aWNhdGlvblJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxldCBhdXRoUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrczVDaG9zZW5BdXRoVHlwZSA9PT0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Ob0F1dGgpIHtcbiAgICAgICAgICAgICAgICBhdXRoUmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTb2NrczVBdXRoZW50aWNhdGlvbk5vQXV0aEhhbmRzaGFrZVJlc3BvbnNlKHRoaXMucmVjZWl2ZUJ1ZmZlci5nZXQoMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zb2NrczVDaG9zZW5BdXRoVHlwZSA9PT0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Vc2VyUGFzcykge1xuICAgICAgICAgICAgICAgIGF1dGhSZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmhhbmRsZVNvY2tzNUF1dGhlbnRpY2F0aW9uVXNlclBhc3NIYW5kc2hha2VSZXNwb25zZSh0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc29ja3M1Q2hvc2VuQXV0aFR5cGUgPT09IHRoaXMub3B0aW9ucy5wcm94eS5jdXN0b21fYXV0aF9tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBhdXRoUmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTb2NrczVDdXN0b21BdXRoSGFuZHNoYWtlUmVzcG9uc2UodGhpcy5yZWNlaXZlQnVmZmVyLmdldCh0aGlzLm9wdGlvbnMucHJveHkuY3VzdG9tX2F1dGhfcmVzcG9uc2Vfc2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdXRoUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChjb25zdGFudHNfMS5FUlJPUlMuU29ja3M1QXV0aGVudGljYXRpb25GYWlsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU29ja3M1Q29tbWFuZFJlcXVlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIFNvY2tzIHY1IGZpbmFsIGhhbmRzaGFrZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNlbmRTb2NrczVDb21tYW5kUmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlcigpO1xuICAgICAgICBidWZmLndyaXRlVUludDgoMHgwNSk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50OChjb25zdGFudHNfMS5Tb2Nrc0NvbW1hbmRbdGhpcy5vcHRpb25zLmNvbW1hbmRdKTtcbiAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDApO1xuICAgICAgICAvLyBpcHY0LCBpcHY2LCBkb21haW4/XG4gICAgICAgIGlmIChuZXQuaXNJUHY0KHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KSkge1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLklQdjQpO1xuICAgICAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcigoMCwgaGVscGVyc18xLmlwVG9CdWZmZXIpKHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV0LmlzSVB2Nih0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24uaG9zdCkpIHtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OChjb25zdGFudHNfMS5Tb2NrczVIb3N0VHlwZS5JUHY2KTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVCdWZmZXIoKDAsIGhlbHBlcnNfMS5pcFRvQnVmZmVyKSh0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24uaG9zdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLkhvc3RuYW1lKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCh0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24uaG9zdC5sZW5ndGgpO1xuICAgICAgICAgICAgYnVmZi53cml0ZVN0cmluZyh0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24uaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZi53cml0ZVVJbnQxNkJFKHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5wb3J0KTtcbiAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID1cbiAgICAgICAgICAgIGNvbnN0YW50c18xLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUy5Tb2NrczVSZXNwb25zZUhlYWRlcjtcbiAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUoYnVmZi50b0J1ZmZlcigpKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLlNlbnRGaW5hbEhhbmRzaGFrZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgU29ja3MgdjUgZmluYWwgaGFuZHNoYWtlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgaGFuZGxlU29ja3M1RmluYWxIYW5kc2hha2VSZXNwb25zZSgpIHtcbiAgICAgICAgLy8gUGVlayBhdCBhdmFpbGFibGUgZGF0YSAod2UgbmVlZCBhdCBsZWFzdCA1IGJ5dGVzIHRvIGdldCB0aGUgaG9zdG5hbWUgbGVuZ3RoKVxuICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLnJlY2VpdmVCdWZmZXIucGVlayg1KTtcbiAgICAgICAgaWYgKGhlYWRlclswXSAhPT0gMHgwNSB8fCBoZWFkZXJbMV0gIT09IGNvbnN0YW50c18xLlNvY2tzNVJlc3BvbnNlLkdyYW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoYCR7Y29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2NrczVGaW5hbEhhbmRzaGFrZVJlamVjdGVkfSAtICR7Y29uc3RhbnRzXzEuU29ja3M1UmVzcG9uc2VbaGVhZGVyWzFdXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlYWQgYWRkcmVzcyB0eXBlXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzVHlwZSA9IGhlYWRlclszXTtcbiAgICAgICAgICAgIGxldCByZW1vdGVIb3N0O1xuICAgICAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgICAgICAvLyBJUHY0XG4gICAgICAgICAgICBpZiAoYWRkcmVzc1R5cGUgPT09IGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLklQdjQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhTmVlZGVkID0gY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNVJlc3BvbnNlSVB2NDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aCA8IGRhdGFOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID0gZGF0YU5lZWRlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmID0gc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIuZnJvbUJ1ZmZlcih0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KGRhdGFOZWVkZWQpLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgICAgICBob3N0OiAoMCwgaGVscGVyc18xLmludDMyVG9JcHY0KShidWZmLnJlYWRVSW50MzJCRSgpKSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogYnVmZi5yZWFkVUludDE2QkUoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElmIGdpdmVuIGhvc3QgaXMgMC4wLjAuMCwgYXNzdW1lIHJlbW90ZSBwcm94eSBpcCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVIb3N0Lmhvc3QgPT09ICcwLjAuMC4wJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVIb3N0Lmhvc3QgPSB0aGlzLm9wdGlvbnMucHJveHkuaXBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIb3N0bmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWRkcmVzc1R5cGUgPT09IGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9zdExlbmd0aCA9IGhlYWRlcls0XTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhTmVlZGVkID0gY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNVJlc3BvbnNlSG9zdG5hbWUoaG9zdExlbmd0aCk7IC8vIGhlYWRlciArIGhvc3QgbGVuZ3RoICsgaG9zdCArIHBvcnRcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aCA8IGRhdGFOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID0gZGF0YU5lZWRlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmID0gc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIuZnJvbUJ1ZmZlcih0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KGRhdGFOZWVkZWQpLnNsaWNlKDUpKTtcbiAgICAgICAgICAgICAgICByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgICAgICBob3N0OiBidWZmLnJlYWRTdHJpbmcoaG9zdExlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHBvcnQ6IGJ1ZmYucmVhZFVJbnQxNkJFKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJUHY2XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhZGRyZXNzVHlwZSA9PT0gY29uc3RhbnRzXzEuU29ja3M1SG9zdFR5cGUuSVB2Nikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFOZWVkZWQgPSBjb25zdGFudHNfMS5TT0NLU19JTkNPTUlOR19QQUNLRVRfU0laRVMuU29ja3M1UmVzcG9uc2VJUHY2O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoIDwgZGF0YU5lZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPSBkYXRhTmVlZGVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmYgPSBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlci5mcm9tQnVmZmVyKHRoaXMucmVjZWl2ZUJ1ZmZlci5nZXQoZGF0YU5lZWRlZCkuc2xpY2UoNCkpO1xuICAgICAgICAgICAgICAgIHJlbW90ZUhvc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IGlwX2FkZHJlc3NfMS5BZGRyZXNzNi5mcm9tQnl0ZUFycmF5KEFycmF5LmZyb20oYnVmZi5yZWFkQnVmZmVyKDE2KSkpLmNhbm9uaWNhbEZvcm0oKSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogYnVmZi5yZWFkVUludDE2QkUoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBldmVyeXRoaW5nIHdlIG5lZWRcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5SZWNlaXZlZEZpbmFsUmVzcG9uc2UpO1xuICAgICAgICAgICAgLy8gSWYgdXNpbmcgQ09OTkVDVCwgdGhlIGNsaWVudCBpcyBub3cgaW4gdGhlIGVzdGFibGlzaGVkIHN0YXRlLlxuICAgICAgICAgICAgaWYgKGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZFt0aGlzLm9wdGlvbnMuY29tbWFuZF0gPT09IGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZC5jb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVzdGFibGlzaGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUludGVybmFsU29ja2V0SGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2VzdGFibGlzaGVkJywgeyByZW1vdGVIb3N0LCBzb2NrZXQ6IHRoaXMuc29ja2V0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uc3RhbnRzXzEuU29ja3NDb21tYW5kW3RoaXMub3B0aW9ucy5jb21tYW5kXSA9PT0gY29uc3RhbnRzXzEuU29ja3NDb21tYW5kLmJpbmQpIHtcbiAgICAgICAgICAgICAgICAvKiBJZiB1c2luZyBCSU5ELCB0aGUgU29ja3MgY2xpZW50IGlzIG5vdyBpbiBCb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgIFRoaXMgbWVhbnMgdGhhdCB0aGUgcmVtb3RlIHByb3h5IHNlcnZlciBpcyB3YWl0aW5nIGZvciBhIHJlbW90ZSBjb25uZWN0aW9uIHRvIHRoZSBib3VuZCBwb3J0LiAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Cb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPVxuICAgICAgICAgICAgICAgICAgICBjb25zdGFudHNfMS5TT0NLU19JTkNPTUlOR19QQUNLRVRfU0laRVMuU29ja3M1UmVzcG9uc2VIZWFkZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdib3VuZCcsIHsgcmVtb3RlSG9zdCwgc29ja2V0OiB0aGlzLnNvY2tldCB9KTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgSWYgdXNpbmcgQXNzb2NpYXRlLCB0aGUgU29ja3MgY2xpZW50IGlzIG5vdyBFc3RhYmxpc2hlZC4gQW5kIHRoZSBwcm94eSBzZXJ2ZXIgaXMgbm93IGFjY2VwdGluZyBVRFAgcGFja2V0cyBhdCB0aGVcbiAgICAgICAgICAgICAgICAgIGdpdmVuIGJvdW5kIHBvcnQuIFRoaXMgaW5pdGlhbCBTb2NrcyBUQ1AgY29ubmVjdGlvbiBtdXN0IHJlbWFpbiBvcGVuIGZvciB0aGUgVURQIHJlbGF5IHRvIGNvbnRpbnVlIHRvIHdvcmsuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZFt0aGlzLm9wdGlvbnMuY29tbWFuZF0gPT09IGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZC5hc3NvY2lhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuRXN0YWJsaXNoZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSW50ZXJuYWxTb2NrZXRIYW5kbGVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXN0YWJsaXNoZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUhvc3QsXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldDogdGhpcy5zb2NrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBTb2NrcyB2NSBpbmNvbWluZyBjb25uZWN0aW9uIHJlcXVlc3QgKEJJTkQpLlxuICAgICAqL1xuICAgIGhhbmRsZVNvY2tzNUluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlKCkge1xuICAgICAgICAvLyBQZWVrIGF0IGF2YWlsYWJsZSBkYXRhICh3ZSBuZWVkIGF0IGxlYXN0IDUgYnl0ZXMgdG8gZ2V0IHRoZSBob3N0bmFtZSBsZW5ndGgpXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMucmVjZWl2ZUJ1ZmZlci5wZWVrKDUpO1xuICAgICAgICBpZiAoaGVhZGVyWzBdICE9PSAweDA1IHx8IGhlYWRlclsxXSAhPT0gY29uc3RhbnRzXzEuU29ja3M1UmVzcG9uc2UuR3JhbnRlZCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChgJHtjb25zdGFudHNfMS5FUlJPUlMuU29ja3M1UHJveHlSZWplY3RlZEluY29taW5nQm91bmRDb25uZWN0aW9ufSAtICR7Y29uc3RhbnRzXzEuU29ja3M1UmVzcG9uc2VbaGVhZGVyWzFdXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlYWQgYWRkcmVzcyB0eXBlXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzVHlwZSA9IGhlYWRlclszXTtcbiAgICAgICAgICAgIGxldCByZW1vdGVIb3N0O1xuICAgICAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgICAgICAvLyBJUHY0XG4gICAgICAgICAgICBpZiAoYWRkcmVzc1R5cGUgPT09IGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLklQdjQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhTmVlZGVkID0gY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNVJlc3BvbnNlSVB2NDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aCA8IGRhdGFOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID0gZGF0YU5lZWRlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmID0gc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIuZnJvbUJ1ZmZlcih0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KGRhdGFOZWVkZWQpLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgICAgICBob3N0OiAoMCwgaGVscGVyc18xLmludDMyVG9JcHY0KShidWZmLnJlYWRVSW50MzJCRSgpKSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogYnVmZi5yZWFkVUludDE2QkUoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElmIGdpdmVuIGhvc3QgaXMgMC4wLjAuMCwgYXNzdW1lIHJlbW90ZSBwcm94eSBpcCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVIb3N0Lmhvc3QgPT09ICcwLjAuMC4wJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVIb3N0Lmhvc3QgPSB0aGlzLm9wdGlvbnMucHJveHkuaXBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIb3N0bmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWRkcmVzc1R5cGUgPT09IGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9zdExlbmd0aCA9IGhlYWRlcls0XTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhTmVlZGVkID0gY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNVJlc3BvbnNlSG9zdG5hbWUoaG9zdExlbmd0aCk7IC8vIGhlYWRlciArIGhvc3QgbGVuZ3RoICsgcG9ydFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoIDwgZGF0YU5lZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPSBkYXRhTmVlZGVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmYgPSBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlci5mcm9tQnVmZmVyKHRoaXMucmVjZWl2ZUJ1ZmZlci5nZXQoZGF0YU5lZWRlZCkuc2xpY2UoNSkpO1xuICAgICAgICAgICAgICAgIHJlbW90ZUhvc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IGJ1ZmYucmVhZFN0cmluZyhob3N0TGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogYnVmZi5yZWFkVUludDE2QkUoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElQdjZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFkZHJlc3NUeXBlID09PSBjb25zdGFudHNfMS5Tb2NrczVIb3N0VHlwZS5JUHY2KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YU5lZWRlZCA9IGNvbnN0YW50c18xLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUy5Tb2NrczVSZXNwb25zZUlQdjY7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGggPCBkYXRhTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFJlcXVpcmVkUGFja2V0QnVmZmVyU2l6ZSA9IGRhdGFOZWVkZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZiA9IHNtYXJ0X2J1ZmZlcl8xLlNtYXJ0QnVmZmVyLmZyb21CdWZmZXIodGhpcy5yZWNlaXZlQnVmZmVyLmdldChkYXRhTmVlZGVkKS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgcmVtb3RlSG9zdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogaXBfYWRkcmVzc18xLkFkZHJlc3M2LmZyb21CeXRlQXJyYXkoQXJyYXkuZnJvbShidWZmLnJlYWRCdWZmZXIoMTYpKSkuY2Fub25pY2FsRm9ybSgpLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiBidWZmLnJlYWRVSW50MTZCRSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuRXN0YWJsaXNoZWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbnRlcm5hbFNvY2tldEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2VzdGFibGlzaGVkJywgeyByZW1vdGVIb3N0LCBzb2NrZXQ6IHRoaXMuc29ja2V0IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzb2Nrc0NsaWVudE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja3NDbGllbnQgPSBTb2Nrc0NsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tzY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/client/socksclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/common/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/socks/build/common/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SOCKS5_NO_ACCEPTABLE_AUTH = exports.SOCKS5_CUSTOM_AUTH_END = exports.SOCKS5_CUSTOM_AUTH_START = exports.SOCKS_INCOMING_PACKET_SIZES = exports.SocksClientState = exports.Socks5Response = exports.Socks5HostType = exports.Socks5Auth = exports.Socks4Response = exports.SocksCommand = exports.ERRORS = exports.DEFAULT_TIMEOUT = void 0;\nconst DEFAULT_TIMEOUT = 30000;\nexports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;\n// prettier-ignore\nconst ERRORS = {\n    InvalidSocksCommand: 'An invalid SOCKS command was provided. Valid options are connect, bind, and associate.',\n    InvalidSocksCommandForOperation: 'An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.',\n    InvalidSocksCommandChain: 'An invalid SOCKS command was provided. Chaining currently only supports the connect command.',\n    InvalidSocksClientOptionsDestination: 'An invalid destination host was provided.',\n    InvalidSocksClientOptionsExistingSocket: 'An invalid existing socket was provided. This should be an instance of stream.Duplex.',\n    InvalidSocksClientOptionsProxy: 'Invalid SOCKS proxy details were provided.',\n    InvalidSocksClientOptionsTimeout: 'An invalid timeout value was provided. Please enter a value above 0 (in ms).',\n    InvalidSocksClientOptionsProxiesLength: 'At least two socks proxies must be provided for chaining.',\n    InvalidSocksClientOptionsCustomAuthRange: 'Custom auth must be a value between 0x80 and 0xFE.',\n    InvalidSocksClientOptionsCustomAuthOptions: 'When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.',\n    NegotiationError: 'Negotiation error',\n    SocketClosed: 'Socket closed',\n    ProxyConnectionTimedOut: 'Proxy connection timed out',\n    InternalError: 'SocksClient internal error (this should not happen)',\n    InvalidSocks4HandshakeResponse: 'Received invalid Socks4 handshake response',\n    Socks4ProxyRejectedConnection: 'Socks4 Proxy rejected connection',\n    InvalidSocks4IncomingConnectionResponse: 'Socks4 invalid incoming connection response',\n    Socks4ProxyRejectedIncomingBoundConnection: 'Socks4 Proxy rejected incoming bound connection',\n    InvalidSocks5InitialHandshakeResponse: 'Received invalid Socks5 initial handshake response',\n    InvalidSocks5IntiailHandshakeSocksVersion: 'Received invalid Socks5 initial handshake (invalid socks version)',\n    InvalidSocks5InitialHandshakeNoAcceptedAuthType: 'Received invalid Socks5 initial handshake (no accepted authentication type)',\n    InvalidSocks5InitialHandshakeUnknownAuthType: 'Received invalid Socks5 initial handshake (unknown authentication type)',\n    Socks5AuthenticationFailed: 'Socks5 Authentication failed',\n    InvalidSocks5FinalHandshake: 'Received invalid Socks5 final handshake response',\n    InvalidSocks5FinalHandshakeRejected: 'Socks5 proxy rejected connection',\n    InvalidSocks5IncomingConnectionResponse: 'Received invalid Socks5 incoming connection response',\n    Socks5ProxyRejectedIncomingBoundConnection: 'Socks5 Proxy rejected incoming bound connection',\n};\nexports.ERRORS = ERRORS;\nconst SOCKS_INCOMING_PACKET_SIZES = {\n    Socks5InitialHandshakeResponse: 2,\n    Socks5UserPassAuthenticationResponse: 2,\n    // Command response + incoming connection (bind)\n    Socks5ResponseHeader: 5, // We need at least 5 to read the hostname length, then we wait for the address+port information.\n    Socks5ResponseIPv4: 10, // 4 header + 4 ip + 2 port\n    Socks5ResponseIPv6: 22, // 4 header + 16 ip + 2 port\n    Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7, // 4 header + 1 host length + host + 2 port\n    // Command response + incoming connection (bind)\n    Socks4Response: 8, // 2 header + 2 port + 4 ip\n};\nexports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;\nvar SocksCommand;\n(function (SocksCommand) {\n    SocksCommand[SocksCommand[\"connect\"] = 1] = \"connect\";\n    SocksCommand[SocksCommand[\"bind\"] = 2] = \"bind\";\n    SocksCommand[SocksCommand[\"associate\"] = 3] = \"associate\";\n})(SocksCommand || (exports.SocksCommand = SocksCommand = {}));\nvar Socks4Response;\n(function (Socks4Response) {\n    Socks4Response[Socks4Response[\"Granted\"] = 90] = \"Granted\";\n    Socks4Response[Socks4Response[\"Failed\"] = 91] = \"Failed\";\n    Socks4Response[Socks4Response[\"Rejected\"] = 92] = \"Rejected\";\n    Socks4Response[Socks4Response[\"RejectedIdent\"] = 93] = \"RejectedIdent\";\n})(Socks4Response || (exports.Socks4Response = Socks4Response = {}));\nvar Socks5Auth;\n(function (Socks5Auth) {\n    Socks5Auth[Socks5Auth[\"NoAuth\"] = 0] = \"NoAuth\";\n    Socks5Auth[Socks5Auth[\"GSSApi\"] = 1] = \"GSSApi\";\n    Socks5Auth[Socks5Auth[\"UserPass\"] = 2] = \"UserPass\";\n})(Socks5Auth || (exports.Socks5Auth = Socks5Auth = {}));\nconst SOCKS5_CUSTOM_AUTH_START = 0x80;\nexports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;\nconst SOCKS5_CUSTOM_AUTH_END = 0xfe;\nexports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;\nconst SOCKS5_NO_ACCEPTABLE_AUTH = 0xff;\nexports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;\nvar Socks5Response;\n(function (Socks5Response) {\n    Socks5Response[Socks5Response[\"Granted\"] = 0] = \"Granted\";\n    Socks5Response[Socks5Response[\"Failure\"] = 1] = \"Failure\";\n    Socks5Response[Socks5Response[\"NotAllowed\"] = 2] = \"NotAllowed\";\n    Socks5Response[Socks5Response[\"NetworkUnreachable\"] = 3] = \"NetworkUnreachable\";\n    Socks5Response[Socks5Response[\"HostUnreachable\"] = 4] = \"HostUnreachable\";\n    Socks5Response[Socks5Response[\"ConnectionRefused\"] = 5] = \"ConnectionRefused\";\n    Socks5Response[Socks5Response[\"TTLExpired\"] = 6] = \"TTLExpired\";\n    Socks5Response[Socks5Response[\"CommandNotSupported\"] = 7] = \"CommandNotSupported\";\n    Socks5Response[Socks5Response[\"AddressNotSupported\"] = 8] = \"AddressNotSupported\";\n})(Socks5Response || (exports.Socks5Response = Socks5Response = {}));\nvar Socks5HostType;\n(function (Socks5HostType) {\n    Socks5HostType[Socks5HostType[\"IPv4\"] = 1] = \"IPv4\";\n    Socks5HostType[Socks5HostType[\"Hostname\"] = 3] = \"Hostname\";\n    Socks5HostType[Socks5HostType[\"IPv6\"] = 4] = \"IPv6\";\n})(Socks5HostType || (exports.Socks5HostType = Socks5HostType = {}));\nvar SocksClientState;\n(function (SocksClientState) {\n    SocksClientState[SocksClientState[\"Created\"] = 0] = \"Created\";\n    SocksClientState[SocksClientState[\"Connecting\"] = 1] = \"Connecting\";\n    SocksClientState[SocksClientState[\"Connected\"] = 2] = \"Connected\";\n    SocksClientState[SocksClientState[\"SentInitialHandshake\"] = 3] = \"SentInitialHandshake\";\n    SocksClientState[SocksClientState[\"ReceivedInitialHandshakeResponse\"] = 4] = \"ReceivedInitialHandshakeResponse\";\n    SocksClientState[SocksClientState[\"SentAuthentication\"] = 5] = \"SentAuthentication\";\n    SocksClientState[SocksClientState[\"ReceivedAuthenticationResponse\"] = 6] = \"ReceivedAuthenticationResponse\";\n    SocksClientState[SocksClientState[\"SentFinalHandshake\"] = 7] = \"SentFinalHandshake\";\n    SocksClientState[SocksClientState[\"ReceivedFinalResponse\"] = 8] = \"ReceivedFinalResponse\";\n    SocksClientState[SocksClientState[\"BoundWaitingForConnection\"] = 9] = \"BoundWaitingForConnection\";\n    SocksClientState[SocksClientState[\"Established\"] = 10] = \"Established\";\n    SocksClientState[SocksClientState[\"Disconnected\"] = 11] = \"Disconnected\";\n    SocksClientState[SocksClientState[\"Error\"] = 99] = \"Error\";\n})(SocksClientState || (exports.SocksClientState = SocksClientState = {}));\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRyw4QkFBOEIsR0FBRyxnQ0FBZ0MsR0FBRyxtQ0FBbUMsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsdUJBQXVCO0FBQ3hVO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQixvQkFBb0Isb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCLGtCQUFrQixrQkFBa0I7QUFDdEQ7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsd0JBQXdCLHdCQUF3QjtBQUN4RSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzMi1za2luLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL2NvbnN0YW50cy5qcz82YjJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TT0NLUzVfTk9fQUNDRVBUQUJMRV9BVVRIID0gZXhwb3J0cy5TT0NLUzVfQ1VTVE9NX0FVVEhfRU5EID0gZXhwb3J0cy5TT0NLUzVfQ1VTVE9NX0FVVEhfU1RBUlQgPSBleHBvcnRzLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUyA9IGV4cG9ydHMuU29ja3NDbGllbnRTdGF0ZSA9IGV4cG9ydHMuU29ja3M1UmVzcG9uc2UgPSBleHBvcnRzLlNvY2tzNUhvc3RUeXBlID0gZXhwb3J0cy5Tb2NrczVBdXRoID0gZXhwb3J0cy5Tb2NrczRSZXNwb25zZSA9IGV4cG9ydHMuU29ja3NDb21tYW5kID0gZXhwb3J0cy5FUlJPUlMgPSBleHBvcnRzLkRFRkFVTFRfVElNRU9VVCA9IHZvaWQgMDtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDMwMDAwO1xuZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVQgPSBERUZBVUxUX1RJTUVPVVQ7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEVSUk9SUyA9IHtcbiAgICBJbnZhbGlkU29ja3NDb21tYW5kOiAnQW4gaW52YWxpZCBTT0NLUyBjb21tYW5kIHdhcyBwcm92aWRlZC4gVmFsaWQgb3B0aW9ucyBhcmUgY29ubmVjdCwgYmluZCwgYW5kIGFzc29jaWF0ZS4nLFxuICAgIEludmFsaWRTb2Nrc0NvbW1hbmRGb3JPcGVyYXRpb246ICdBbiBpbnZhbGlkIFNPQ0tTIGNvbW1hbmQgd2FzIHByb3ZpZGVkLiBPbmx5IGEgc3Vic2V0IG9mIGNvbW1hbmRzIGFyZSBzdXBwb3J0ZWQgZm9yIHRoaXMgb3BlcmF0aW9uLicsXG4gICAgSW52YWxpZFNvY2tzQ29tbWFuZENoYWluOiAnQW4gaW52YWxpZCBTT0NLUyBjb21tYW5kIHdhcyBwcm92aWRlZC4gQ2hhaW5pbmcgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdGhlIGNvbm5lY3QgY29tbWFuZC4nLFxuICAgIEludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNEZXN0aW5hdGlvbjogJ0FuIGludmFsaWQgZGVzdGluYXRpb24gaG9zdCB3YXMgcHJvdmlkZWQuJyxcbiAgICBJbnZhbGlkU29ja3NDbGllbnRPcHRpb25zRXhpc3RpbmdTb2NrZXQ6ICdBbiBpbnZhbGlkIGV4aXN0aW5nIHNvY2tldCB3YXMgcHJvdmlkZWQuIFRoaXMgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIHN0cmVhbS5EdXBsZXguJyxcbiAgICBJbnZhbGlkU29ja3NDbGllbnRPcHRpb25zUHJveHk6ICdJbnZhbGlkIFNPQ0tTIHByb3h5IGRldGFpbHMgd2VyZSBwcm92aWRlZC4nLFxuICAgIEludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNUaW1lb3V0OiAnQW4gaW52YWxpZCB0aW1lb3V0IHZhbHVlIHdhcyBwcm92aWRlZC4gUGxlYXNlIGVudGVyIGEgdmFsdWUgYWJvdmUgMCAoaW4gbXMpLicsXG4gICAgSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc1Byb3hpZXNMZW5ndGg6ICdBdCBsZWFzdCB0d28gc29ja3MgcHJveGllcyBtdXN0IGJlIHByb3ZpZGVkIGZvciBjaGFpbmluZy4nLFxuICAgIEludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNDdXN0b21BdXRoUmFuZ2U6ICdDdXN0b20gYXV0aCBtdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAweDgwIGFuZCAweEZFLicsXG4gICAgSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0N1c3RvbUF1dGhPcHRpb25zOiAnV2hlbiBhIGN1c3RvbV9hdXRoX21ldGhvZCBpcyBwcm92aWRlZCwgY3VzdG9tX2F1dGhfcmVxdWVzdF9oYW5kbGVyLCBjdXN0b21fYXV0aF9yZXNwb25zZV9zaXplLCBhbmQgY3VzdG9tX2F1dGhfcmVzcG9uc2VfaGFuZGxlciBtdXN0IGFsc28gYmUgcHJvdmlkZWQgYW5kIHZhbGlkLicsXG4gICAgTmVnb3RpYXRpb25FcnJvcjogJ05lZ290aWF0aW9uIGVycm9yJyxcbiAgICBTb2NrZXRDbG9zZWQ6ICdTb2NrZXQgY2xvc2VkJyxcbiAgICBQcm94eUNvbm5lY3Rpb25UaW1lZE91dDogJ1Byb3h5IGNvbm5lY3Rpb24gdGltZWQgb3V0JyxcbiAgICBJbnRlcm5hbEVycm9yOiAnU29ja3NDbGllbnQgaW50ZXJuYWwgZXJyb3IgKHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4pJyxcbiAgICBJbnZhbGlkU29ja3M0SGFuZHNoYWtlUmVzcG9uc2U6ICdSZWNlaXZlZCBpbnZhbGlkIFNvY2tzNCBoYW5kc2hha2UgcmVzcG9uc2UnLFxuICAgIFNvY2tzNFByb3h5UmVqZWN0ZWRDb25uZWN0aW9uOiAnU29ja3M0IFByb3h5IHJlamVjdGVkIGNvbm5lY3Rpb24nLFxuICAgIEludmFsaWRTb2NrczRJbmNvbWluZ0Nvbm5lY3Rpb25SZXNwb25zZTogJ1NvY2tzNCBpbnZhbGlkIGluY29taW5nIGNvbm5lY3Rpb24gcmVzcG9uc2UnLFxuICAgIFNvY2tzNFByb3h5UmVqZWN0ZWRJbmNvbWluZ0JvdW5kQ29ubmVjdGlvbjogJ1NvY2tzNCBQcm94eSByZWplY3RlZCBpbmNvbWluZyBib3VuZCBjb25uZWN0aW9uJyxcbiAgICBJbnZhbGlkU29ja3M1SW5pdGlhbEhhbmRzaGFrZVJlc3BvbnNlOiAnUmVjZWl2ZWQgaW52YWxpZCBTb2NrczUgaW5pdGlhbCBoYW5kc2hha2UgcmVzcG9uc2UnLFxuICAgIEludmFsaWRTb2NrczVJbnRpYWlsSGFuZHNoYWtlU29ja3NWZXJzaW9uOiAnUmVjZWl2ZWQgaW52YWxpZCBTb2NrczUgaW5pdGlhbCBoYW5kc2hha2UgKGludmFsaWQgc29ja3MgdmVyc2lvbiknLFxuICAgIEludmFsaWRTb2NrczVJbml0aWFsSGFuZHNoYWtlTm9BY2NlcHRlZEF1dGhUeXBlOiAnUmVjZWl2ZWQgaW52YWxpZCBTb2NrczUgaW5pdGlhbCBoYW5kc2hha2UgKG5vIGFjY2VwdGVkIGF1dGhlbnRpY2F0aW9uIHR5cGUpJyxcbiAgICBJbnZhbGlkU29ja3M1SW5pdGlhbEhhbmRzaGFrZVVua25vd25BdXRoVHlwZTogJ1JlY2VpdmVkIGludmFsaWQgU29ja3M1IGluaXRpYWwgaGFuZHNoYWtlICh1bmtub3duIGF1dGhlbnRpY2F0aW9uIHR5cGUpJyxcbiAgICBTb2NrczVBdXRoZW50aWNhdGlvbkZhaWxlZDogJ1NvY2tzNSBBdXRoZW50aWNhdGlvbiBmYWlsZWQnLFxuICAgIEludmFsaWRTb2NrczVGaW5hbEhhbmRzaGFrZTogJ1JlY2VpdmVkIGludmFsaWQgU29ja3M1IGZpbmFsIGhhbmRzaGFrZSByZXNwb25zZScsXG4gICAgSW52YWxpZFNvY2tzNUZpbmFsSGFuZHNoYWtlUmVqZWN0ZWQ6ICdTb2NrczUgcHJveHkgcmVqZWN0ZWQgY29ubmVjdGlvbicsXG4gICAgSW52YWxpZFNvY2tzNUluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlOiAnUmVjZWl2ZWQgaW52YWxpZCBTb2NrczUgaW5jb21pbmcgY29ubmVjdGlvbiByZXNwb25zZScsXG4gICAgU29ja3M1UHJveHlSZWplY3RlZEluY29taW5nQm91bmRDb25uZWN0aW9uOiAnU29ja3M1IFByb3h5IHJlamVjdGVkIGluY29taW5nIGJvdW5kIGNvbm5lY3Rpb24nLFxufTtcbmV4cG9ydHMuRVJST1JTID0gRVJST1JTO1xuY29uc3QgU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTID0ge1xuICAgIFNvY2tzNUluaXRpYWxIYW5kc2hha2VSZXNwb25zZTogMixcbiAgICBTb2NrczVVc2VyUGFzc0F1dGhlbnRpY2F0aW9uUmVzcG9uc2U6IDIsXG4gICAgLy8gQ29tbWFuZCByZXNwb25zZSArIGluY29taW5nIGNvbm5lY3Rpb24gKGJpbmQpXG4gICAgU29ja3M1UmVzcG9uc2VIZWFkZXI6IDUsIC8vIFdlIG5lZWQgYXQgbGVhc3QgNSB0byByZWFkIHRoZSBob3N0bmFtZSBsZW5ndGgsIHRoZW4gd2Ugd2FpdCBmb3IgdGhlIGFkZHJlc3MrcG9ydCBpbmZvcm1hdGlvbi5cbiAgICBTb2NrczVSZXNwb25zZUlQdjQ6IDEwLCAvLyA0IGhlYWRlciArIDQgaXAgKyAyIHBvcnRcbiAgICBTb2NrczVSZXNwb25zZUlQdjY6IDIyLCAvLyA0IGhlYWRlciArIDE2IGlwICsgMiBwb3J0XG4gICAgU29ja3M1UmVzcG9uc2VIb3N0bmFtZTogKGhvc3ROYW1lTGVuZ3RoKSA9PiBob3N0TmFtZUxlbmd0aCArIDcsIC8vIDQgaGVhZGVyICsgMSBob3N0IGxlbmd0aCArIGhvc3QgKyAyIHBvcnRcbiAgICAvLyBDb21tYW5kIHJlc3BvbnNlICsgaW5jb21pbmcgY29ubmVjdGlvbiAoYmluZClcbiAgICBTb2NrczRSZXNwb25zZTogOCwgLy8gMiBoZWFkZXIgKyAyIHBvcnQgKyA0IGlwXG59O1xuZXhwb3J0cy5TT0NLU19JTkNPTUlOR19QQUNLRVRfU0laRVMgPSBTT0NLU19JTkNPTUlOR19QQUNLRVRfU0laRVM7XG52YXIgU29ja3NDb21tYW5kO1xuKGZ1bmN0aW9uIChTb2Nrc0NvbW1hbmQpIHtcbiAgICBTb2Nrc0NvbW1hbmRbU29ja3NDb21tYW5kW1wiY29ubmVjdFwiXSA9IDFdID0gXCJjb25uZWN0XCI7XG4gICAgU29ja3NDb21tYW5kW1NvY2tzQ29tbWFuZFtcImJpbmRcIl0gPSAyXSA9IFwiYmluZFwiO1xuICAgIFNvY2tzQ29tbWFuZFtTb2Nrc0NvbW1hbmRbXCJhc3NvY2lhdGVcIl0gPSAzXSA9IFwiYXNzb2NpYXRlXCI7XG59KShTb2Nrc0NvbW1hbmQgfHwgKGV4cG9ydHMuU29ja3NDb21tYW5kID0gU29ja3NDb21tYW5kID0ge30pKTtcbnZhciBTb2NrczRSZXNwb25zZTtcbihmdW5jdGlvbiAoU29ja3M0UmVzcG9uc2UpIHtcbiAgICBTb2NrczRSZXNwb25zZVtTb2NrczRSZXNwb25zZVtcIkdyYW50ZWRcIl0gPSA5MF0gPSBcIkdyYW50ZWRcIjtcbiAgICBTb2NrczRSZXNwb25zZVtTb2NrczRSZXNwb25zZVtcIkZhaWxlZFwiXSA9IDkxXSA9IFwiRmFpbGVkXCI7XG4gICAgU29ja3M0UmVzcG9uc2VbU29ja3M0UmVzcG9uc2VbXCJSZWplY3RlZFwiXSA9IDkyXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICBTb2NrczRSZXNwb25zZVtTb2NrczRSZXNwb25zZVtcIlJlamVjdGVkSWRlbnRcIl0gPSA5M10gPSBcIlJlamVjdGVkSWRlbnRcIjtcbn0pKFNvY2tzNFJlc3BvbnNlIHx8IChleHBvcnRzLlNvY2tzNFJlc3BvbnNlID0gU29ja3M0UmVzcG9uc2UgPSB7fSkpO1xudmFyIFNvY2tzNUF1dGg7XG4oZnVuY3Rpb24gKFNvY2tzNUF1dGgpIHtcbiAgICBTb2NrczVBdXRoW1NvY2tzNUF1dGhbXCJOb0F1dGhcIl0gPSAwXSA9IFwiTm9BdXRoXCI7XG4gICAgU29ja3M1QXV0aFtTb2NrczVBdXRoW1wiR1NTQXBpXCJdID0gMV0gPSBcIkdTU0FwaVwiO1xuICAgIFNvY2tzNUF1dGhbU29ja3M1QXV0aFtcIlVzZXJQYXNzXCJdID0gMl0gPSBcIlVzZXJQYXNzXCI7XG59KShTb2NrczVBdXRoIHx8IChleHBvcnRzLlNvY2tzNUF1dGggPSBTb2NrczVBdXRoID0ge30pKTtcbmNvbnN0IFNPQ0tTNV9DVVNUT01fQVVUSF9TVEFSVCA9IDB4ODA7XG5leHBvcnRzLlNPQ0tTNV9DVVNUT01fQVVUSF9TVEFSVCA9IFNPQ0tTNV9DVVNUT01fQVVUSF9TVEFSVDtcbmNvbnN0IFNPQ0tTNV9DVVNUT01fQVVUSF9FTkQgPSAweGZlO1xuZXhwb3J0cy5TT0NLUzVfQ1VTVE9NX0FVVEhfRU5EID0gU09DS1M1X0NVU1RPTV9BVVRIX0VORDtcbmNvbnN0IFNPQ0tTNV9OT19BQ0NFUFRBQkxFX0FVVEggPSAweGZmO1xuZXhwb3J0cy5TT0NLUzVfTk9fQUNDRVBUQUJMRV9BVVRIID0gU09DS1M1X05PX0FDQ0VQVEFCTEVfQVVUSDtcbnZhciBTb2NrczVSZXNwb25zZTtcbihmdW5jdGlvbiAoU29ja3M1UmVzcG9uc2UpIHtcbiAgICBTb2NrczVSZXNwb25zZVtTb2NrczVSZXNwb25zZVtcIkdyYW50ZWRcIl0gPSAwXSA9IFwiR3JhbnRlZFwiO1xuICAgIFNvY2tzNVJlc3BvbnNlW1NvY2tzNVJlc3BvbnNlW1wiRmFpbHVyZVwiXSA9IDFdID0gXCJGYWlsdXJlXCI7XG4gICAgU29ja3M1UmVzcG9uc2VbU29ja3M1UmVzcG9uc2VbXCJOb3RBbGxvd2VkXCJdID0gMl0gPSBcIk5vdEFsbG93ZWRcIjtcbiAgICBTb2NrczVSZXNwb25zZVtTb2NrczVSZXNwb25zZVtcIk5ldHdvcmtVbnJlYWNoYWJsZVwiXSA9IDNdID0gXCJOZXR3b3JrVW5yZWFjaGFibGVcIjtcbiAgICBTb2NrczVSZXNwb25zZVtTb2NrczVSZXNwb25zZVtcIkhvc3RVbnJlYWNoYWJsZVwiXSA9IDRdID0gXCJIb3N0VW5yZWFjaGFibGVcIjtcbiAgICBTb2NrczVSZXNwb25zZVtTb2NrczVSZXNwb25zZVtcIkNvbm5lY3Rpb25SZWZ1c2VkXCJdID0gNV0gPSBcIkNvbm5lY3Rpb25SZWZ1c2VkXCI7XG4gICAgU29ja3M1UmVzcG9uc2VbU29ja3M1UmVzcG9uc2VbXCJUVExFeHBpcmVkXCJdID0gNl0gPSBcIlRUTEV4cGlyZWRcIjtcbiAgICBTb2NrczVSZXNwb25zZVtTb2NrczVSZXNwb25zZVtcIkNvbW1hbmROb3RTdXBwb3J0ZWRcIl0gPSA3XSA9IFwiQ29tbWFuZE5vdFN1cHBvcnRlZFwiO1xuICAgIFNvY2tzNVJlc3BvbnNlW1NvY2tzNVJlc3BvbnNlW1wiQWRkcmVzc05vdFN1cHBvcnRlZFwiXSA9IDhdID0gXCJBZGRyZXNzTm90U3VwcG9ydGVkXCI7XG59KShTb2NrczVSZXNwb25zZSB8fCAoZXhwb3J0cy5Tb2NrczVSZXNwb25zZSA9IFNvY2tzNVJlc3BvbnNlID0ge30pKTtcbnZhciBTb2NrczVIb3N0VHlwZTtcbihmdW5jdGlvbiAoU29ja3M1SG9zdFR5cGUpIHtcbiAgICBTb2NrczVIb3N0VHlwZVtTb2NrczVIb3N0VHlwZVtcIklQdjRcIl0gPSAxXSA9IFwiSVB2NFwiO1xuICAgIFNvY2tzNUhvc3RUeXBlW1NvY2tzNUhvc3RUeXBlW1wiSG9zdG5hbWVcIl0gPSAzXSA9IFwiSG9zdG5hbWVcIjtcbiAgICBTb2NrczVIb3N0VHlwZVtTb2NrczVIb3N0VHlwZVtcIklQdjZcIl0gPSA0XSA9IFwiSVB2NlwiO1xufSkoU29ja3M1SG9zdFR5cGUgfHwgKGV4cG9ydHMuU29ja3M1SG9zdFR5cGUgPSBTb2NrczVIb3N0VHlwZSA9IHt9KSk7XG52YXIgU29ja3NDbGllbnRTdGF0ZTtcbihmdW5jdGlvbiAoU29ja3NDbGllbnRTdGF0ZSkge1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIkNyZWF0ZWRcIl0gPSAwXSA9IFwiQ3JlYXRlZFwiO1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIkNvbm5lY3RpbmdcIl0gPSAxXSA9IFwiQ29ubmVjdGluZ1wiO1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IDJdID0gXCJDb25uZWN0ZWRcIjtcbiAgICBTb2Nrc0NsaWVudFN0YXRlW1NvY2tzQ2xpZW50U3RhdGVbXCJTZW50SW5pdGlhbEhhbmRzaGFrZVwiXSA9IDNdID0gXCJTZW50SW5pdGlhbEhhbmRzaGFrZVwiO1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIlJlY2VpdmVkSW5pdGlhbEhhbmRzaGFrZVJlc3BvbnNlXCJdID0gNF0gPSBcIlJlY2VpdmVkSW5pdGlhbEhhbmRzaGFrZVJlc3BvbnNlXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiU2VudEF1dGhlbnRpY2F0aW9uXCJdID0gNV0gPSBcIlNlbnRBdXRoZW50aWNhdGlvblwiO1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIlJlY2VpdmVkQXV0aGVudGljYXRpb25SZXNwb25zZVwiXSA9IDZdID0gXCJSZWNlaXZlZEF1dGhlbnRpY2F0aW9uUmVzcG9uc2VcIjtcbiAgICBTb2Nrc0NsaWVudFN0YXRlW1NvY2tzQ2xpZW50U3RhdGVbXCJTZW50RmluYWxIYW5kc2hha2VcIl0gPSA3XSA9IFwiU2VudEZpbmFsSGFuZHNoYWtlXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiUmVjZWl2ZWRGaW5hbFJlc3BvbnNlXCJdID0gOF0gPSBcIlJlY2VpdmVkRmluYWxSZXNwb25zZVwiO1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIkJvdW5kV2FpdGluZ0ZvckNvbm5lY3Rpb25cIl0gPSA5XSA9IFwiQm91bmRXYWl0aW5nRm9yQ29ubmVjdGlvblwiO1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIkVzdGFibGlzaGVkXCJdID0gMTBdID0gXCJFc3RhYmxpc2hlZFwiO1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IDExXSA9IFwiRGlzY29ubmVjdGVkXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiRXJyb3JcIl0gPSA5OV0gPSBcIkVycm9yXCI7XG59KShTb2Nrc0NsaWVudFN0YXRlIHx8IChleHBvcnRzLlNvY2tzQ2xpZW50U3RhdGUgPSBTb2Nrc0NsaWVudFN0YXRlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/common/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/common/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/socks/build/common/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ipToBuffer = exports.int32ToIpv4 = exports.ipv4ToInt32 = exports.validateSocksClientChainOptions = exports.validateSocksClientOptions = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/socks/build/common/util.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/socks/build/common/constants.js\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst ip_address_1 = __webpack_require__(/*! ip-address */ \"(rsc)/./node_modules/ip-address/dist/ip-address.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\n/**\n * Validates the provided SocksClientOptions\n * @param options { SocksClientOptions }\n * @param acceptedCommands { string[] } A list of accepted SocksProxy commands.\n */\nfunction validateSocksClientOptions(options, acceptedCommands = ['connect', 'bind', 'associate']) {\n    // Check SOCKs command option.\n    if (!constants_1.SocksCommand[options.command]) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);\n    }\n    // Check SocksCommand for acceptable command.\n    if (acceptedCommands.indexOf(options.command) === -1) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);\n    }\n    // Check destination\n    if (!isValidSocksRemoteHost(options.destination)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);\n    }\n    // Check SOCKS proxy to use\n    if (!isValidSocksProxy(options.proxy)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);\n    }\n    // Validate custom auth (if set)\n    validateCustomProxyAuth(options.proxy, options);\n    // Check timeout\n    if (options.timeout && !isValidTimeoutValue(options.timeout)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);\n    }\n    // Check existing_socket (if provided)\n    if (options.existing_socket &&\n        !(options.existing_socket instanceof stream.Duplex)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);\n    }\n}\nexports.validateSocksClientOptions = validateSocksClientOptions;\n/**\n * Validates the SocksClientChainOptions\n * @param options { SocksClientChainOptions }\n */\nfunction validateSocksClientChainOptions(options) {\n    // Only connect is supported when chaining.\n    if (options.command !== 'connect') {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);\n    }\n    // Check destination\n    if (!isValidSocksRemoteHost(options.destination)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);\n    }\n    // Validate proxies (length)\n    if (!(options.proxies &&\n        Array.isArray(options.proxies) &&\n        options.proxies.length >= 2)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);\n    }\n    // Validate proxies\n    options.proxies.forEach((proxy) => {\n        if (!isValidSocksProxy(proxy)) {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);\n        }\n        // Validate custom auth (if set)\n        validateCustomProxyAuth(proxy, options);\n    });\n    // Check timeout\n    if (options.timeout && !isValidTimeoutValue(options.timeout)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);\n    }\n}\nexports.validateSocksClientChainOptions = validateSocksClientChainOptions;\nfunction validateCustomProxyAuth(proxy, options) {\n    if (proxy.custom_auth_method !== undefined) {\n        // Invalid auth method range\n        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START ||\n            proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);\n        }\n        // Missing custom_auth_request_handler\n        if (proxy.custom_auth_request_handler === undefined ||\n            typeof proxy.custom_auth_request_handler !== 'function') {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);\n        }\n        // Missing custom_auth_response_size\n        if (proxy.custom_auth_response_size === undefined) {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);\n        }\n        // Missing/invalid custom_auth_response_handler\n        if (proxy.custom_auth_response_handler === undefined ||\n            typeof proxy.custom_auth_response_handler !== 'function') {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);\n        }\n    }\n}\n/**\n * Validates a SocksRemoteHost\n * @param remoteHost { SocksRemoteHost }\n */\nfunction isValidSocksRemoteHost(remoteHost) {\n    return (remoteHost &&\n        typeof remoteHost.host === 'string' &&\n        Buffer.byteLength(remoteHost.host) < 256 &&\n        typeof remoteHost.port === 'number' &&\n        remoteHost.port >= 0 &&\n        remoteHost.port <= 65535);\n}\n/**\n * Validates a SocksProxy\n * @param proxy { SocksProxy }\n */\nfunction isValidSocksProxy(proxy) {\n    return (proxy &&\n        (typeof proxy.host === 'string' || typeof proxy.ipaddress === 'string') &&\n        typeof proxy.port === 'number' &&\n        proxy.port >= 0 &&\n        proxy.port <= 65535 &&\n        (proxy.type === 4 || proxy.type === 5));\n}\n/**\n * Validates a timeout value.\n * @param value { Number }\n */\nfunction isValidTimeoutValue(value) {\n    return typeof value === 'number' && value > 0;\n}\nfunction ipv4ToInt32(ip) {\n    const address = new ip_address_1.Address4(ip);\n    // Convert the IPv4 address parts to an integer\n    return address.toArray().reduce((acc, part) => (acc << 8) + part, 0) >>> 0;\n}\nexports.ipv4ToInt32 = ipv4ToInt32;\nfunction int32ToIpv4(int32) {\n    // Extract each byte (octet) from the 32-bit integer\n    const octet1 = (int32 >>> 24) & 0xff;\n    const octet2 = (int32 >>> 16) & 0xff;\n    const octet3 = (int32 >>> 8) & 0xff;\n    const octet4 = int32 & 0xff;\n    // Combine the octets into a string in IPv4 format\n    return [octet1, octet2, octet3, octet4].join('.');\n}\nexports.int32ToIpv4 = int32ToIpv4;\nfunction ipToBuffer(ip) {\n    if (net.isIPv4(ip)) {\n        // Handle IPv4 addresses\n        const address = new ip_address_1.Address4(ip);\n        return Buffer.from(address.toArray());\n    }\n    else if (net.isIPv6(ip)) {\n        // Handle IPv6 addresses\n        const address = new ip_address_1.Address6(ip);\n        return Buffer.from(address\n            .canonicalForm()\n            .split(':')\n            .map((segment) => segment.padStart(4, '0'))\n            .join(''), 'hex');\n    }\n    else {\n        throw new Error('Invalid IP address format');\n    }\n}\nexports.ipToBuffer = ipToBuffer;\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsdUNBQXVDLEdBQUcsa0NBQWtDO0FBQzdJLGVBQWUsbUJBQU8sQ0FBQywrREFBUTtBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyx5RUFBYTtBQUN6QyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsc0VBQVk7QUFDekMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MyLXNraW4tdHJhY2tlci8uL25vZGVfbW9kdWxlcy9zb2Nrcy9idWlsZC9jb21tb24vaGVscGVycy5qcz8zMWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pcFRvQnVmZmVyID0gZXhwb3J0cy5pbnQzMlRvSXB2NCA9IGV4cG9ydHMuaXB2NFRvSW50MzIgPSBleHBvcnRzLnZhbGlkYXRlU29ja3NDbGllbnRDaGFpbk9wdGlvbnMgPSBleHBvcnRzLnZhbGlkYXRlU29ja3NDbGllbnRPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3Qgc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGlwX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCJpcC1hZGRyZXNzXCIpO1xuY29uc3QgbmV0ID0gcmVxdWlyZShcIm5ldFwiKTtcbi8qKlxuICogVmFsaWRhdGVzIHRoZSBwcm92aWRlZCBTb2Nrc0NsaWVudE9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zIHsgU29ja3NDbGllbnRPcHRpb25zIH1cbiAqIEBwYXJhbSBhY2NlcHRlZENvbW1hbmRzIHsgc3RyaW5nW10gfSBBIGxpc3Qgb2YgYWNjZXB0ZWQgU29ja3NQcm94eSBjb21tYW5kcy5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTb2Nrc0NsaWVudE9wdGlvbnMob3B0aW9ucywgYWNjZXB0ZWRDb21tYW5kcyA9IFsnY29ubmVjdCcsICdiaW5kJywgJ2Fzc29jaWF0ZSddKSB7XG4gICAgLy8gQ2hlY2sgU09DS3MgY29tbWFuZCBvcHRpb24uXG4gICAgaWYgKCFjb25zdGFudHNfMS5Tb2Nrc0NvbW1hbmRbb3B0aW9ucy5jb21tYW5kXSkge1xuICAgICAgICB0aHJvdyBuZXcgdXRpbF8xLlNvY2tzQ2xpZW50RXJyb3IoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2Nrc0NvbW1hbmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBDaGVjayBTb2Nrc0NvbW1hbmQgZm9yIGFjY2VwdGFibGUgY29tbWFuZC5cbiAgICBpZiAoYWNjZXB0ZWRDb21tYW5kcy5pbmRleE9mKG9wdGlvbnMuY29tbWFuZCkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ29tbWFuZEZvck9wZXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIENoZWNrIGRlc3RpbmF0aW9uXG4gICAgaWYgKCFpc1ZhbGlkU29ja3NSZW1vdGVIb3N0KG9wdGlvbnMuZGVzdGluYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0Rlc3RpbmF0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgU09DS1MgcHJveHkgdG8gdXNlXG4gICAgaWYgKCFpc1ZhbGlkU29ja3NQcm94eShvcHRpb25zLnByb3h5KSkge1xuICAgICAgICB0aHJvdyBuZXcgdXRpbF8xLlNvY2tzQ2xpZW50RXJyb3IoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNQcm94eSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIGN1c3RvbSBhdXRoIChpZiBzZXQpXG4gICAgdmFsaWRhdGVDdXN0b21Qcm94eUF1dGgob3B0aW9ucy5wcm94eSwgb3B0aW9ucyk7XG4gICAgLy8gQ2hlY2sgdGltZW91dFxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQgJiYgIWlzVmFsaWRUaW1lb3V0VmFsdWUob3B0aW9ucy50aW1lb3V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgdXRpbF8xLlNvY2tzQ2xpZW50RXJyb3IoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNUaW1lb3V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZXhpc3Rpbmdfc29ja2V0IChpZiBwcm92aWRlZClcbiAgICBpZiAob3B0aW9ucy5leGlzdGluZ19zb2NrZXQgJiZcbiAgICAgICAgIShvcHRpb25zLmV4aXN0aW5nX3NvY2tldCBpbnN0YW5jZW9mIHN0cmVhbS5EdXBsZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0V4aXN0aW5nU29ja2V0LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU29ja3NDbGllbnRPcHRpb25zID0gdmFsaWRhdGVTb2Nrc0NsaWVudE9wdGlvbnM7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgU29ja3NDbGllbnRDaGFpbk9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zIHsgU29ja3NDbGllbnRDaGFpbk9wdGlvbnMgfVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNvY2tzQ2xpZW50Q2hhaW5PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAvLyBPbmx5IGNvbm5lY3QgaXMgc3VwcG9ydGVkIHdoZW4gY2hhaW5pbmcuXG4gICAgaWYgKG9wdGlvbnMuY29tbWFuZCAhPT0gJ2Nvbm5lY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ29tbWFuZENoYWluLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZGVzdGluYXRpb25cbiAgICBpZiAoIWlzVmFsaWRTb2Nrc1JlbW90ZUhvc3Qob3B0aW9ucy5kZXN0aW5hdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDbGllbnRPcHRpb25zRGVzdGluYXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBwcm94aWVzIChsZW5ndGgpXG4gICAgaWYgKCEob3B0aW9ucy5wcm94aWVzICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkob3B0aW9ucy5wcm94aWVzKSAmJlxuICAgICAgICBvcHRpb25zLnByb3hpZXMubGVuZ3RoID49IDIpKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc1Byb3hpZXNMZW5ndGgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBwcm94aWVzXG4gICAgb3B0aW9ucy5wcm94aWVzLmZvckVhY2goKHByb3h5KSA9PiB7XG4gICAgICAgIGlmICghaXNWYWxpZFNvY2tzUHJveHkocHJveHkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdXRpbF8xLlNvY2tzQ2xpZW50RXJyb3IoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNQcm94eSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgY3VzdG9tIGF1dGggKGlmIHNldClcbiAgICAgICAgdmFsaWRhdGVDdXN0b21Qcm94eUF1dGgocHJveHksIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIC8vIENoZWNrIHRpbWVvdXRcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0ICYmICFpc1ZhbGlkVGltZW91dFZhbHVlKG9wdGlvbnMudGltZW91dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDbGllbnRPcHRpb25zVGltZW91dCwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNvY2tzQ2xpZW50Q2hhaW5PcHRpb25zID0gdmFsaWRhdGVTb2Nrc0NsaWVudENoYWluT3B0aW9ucztcbmZ1bmN0aW9uIHZhbGlkYXRlQ3VzdG9tUHJveHlBdXRoKHByb3h5LCBvcHRpb25zKSB7XG4gICAgaWYgKHByb3h5LmN1c3RvbV9hdXRoX21ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEludmFsaWQgYXV0aCBtZXRob2QgcmFuZ2VcbiAgICAgICAgaWYgKHByb3h5LmN1c3RvbV9hdXRoX21ldGhvZCA8IGNvbnN0YW50c18xLlNPQ0tTNV9DVVNUT01fQVVUSF9TVEFSVCB8fFxuICAgICAgICAgICAgcHJveHkuY3VzdG9tX2F1dGhfbWV0aG9kID4gY29uc3RhbnRzXzEuU09DS1M1X0NVU1RPTV9BVVRIX0VORCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDbGllbnRPcHRpb25zQ3VzdG9tQXV0aFJhbmdlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNaXNzaW5nIGN1c3RvbV9hdXRoX3JlcXVlc3RfaGFuZGxlclxuICAgICAgICBpZiAocHJveHkuY3VzdG9tX2F1dGhfcmVxdWVzdF9oYW5kbGVyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBwcm94eS5jdXN0b21fYXV0aF9yZXF1ZXN0X2hhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0N1c3RvbUF1dGhPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNaXNzaW5nIGN1c3RvbV9hdXRoX3Jlc3BvbnNlX3NpemVcbiAgICAgICAgaWYgKHByb3h5LmN1c3RvbV9hdXRoX3Jlc3BvbnNlX3NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDbGllbnRPcHRpb25zQ3VzdG9tQXV0aE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1pc3NpbmcvaW52YWxpZCBjdXN0b21fYXV0aF9yZXNwb25zZV9oYW5kbGVyXG4gICAgICAgIGlmIChwcm94eS5jdXN0b21fYXV0aF9yZXNwb25zZV9oYW5kbGVyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBwcm94eS5jdXN0b21fYXV0aF9yZXNwb25zZV9oYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdXRpbF8xLlNvY2tzQ2xpZW50RXJyb3IoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNDdXN0b21BdXRoT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIFNvY2tzUmVtb3RlSG9zdFxuICogQHBhcmFtIHJlbW90ZUhvc3QgeyBTb2Nrc1JlbW90ZUhvc3QgfVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU29ja3NSZW1vdGVIb3N0KHJlbW90ZUhvc3QpIHtcbiAgICByZXR1cm4gKHJlbW90ZUhvc3QgJiZcbiAgICAgICAgdHlwZW9mIHJlbW90ZUhvc3QuaG9zdCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgocmVtb3RlSG9zdC5ob3N0KSA8IDI1NiAmJlxuICAgICAgICB0eXBlb2YgcmVtb3RlSG9zdC5wb3J0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICByZW1vdGVIb3N0LnBvcnQgPj0gMCAmJlxuICAgICAgICByZW1vdGVIb3N0LnBvcnQgPD0gNjU1MzUpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBTb2Nrc1Byb3h5XG4gKiBAcGFyYW0gcHJveHkgeyBTb2Nrc1Byb3h5IH1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNvY2tzUHJveHkocHJveHkpIHtcbiAgICByZXR1cm4gKHByb3h5ICYmXG4gICAgICAgICh0eXBlb2YgcHJveHkuaG9zdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3h5LmlwYWRkcmVzcyA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgIHR5cGVvZiBwcm94eS5wb3J0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwcm94eS5wb3J0ID49IDAgJiZcbiAgICAgICAgcHJveHkucG9ydCA8PSA2NTUzNSAmJlxuICAgICAgICAocHJveHkudHlwZSA9PT0gNCB8fCBwcm94eS50eXBlID09PSA1KSk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHRpbWVvdXQgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkVGltZW91dFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPiAwO1xufVxuZnVuY3Rpb24gaXB2NFRvSW50MzIoaXApIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbmV3IGlwX2FkZHJlc3NfMS5BZGRyZXNzNChpcCk7XG4gICAgLy8gQ29udmVydCB0aGUgSVB2NCBhZGRyZXNzIHBhcnRzIHRvIGFuIGludGVnZXJcbiAgICByZXR1cm4gYWRkcmVzcy50b0FycmF5KCkucmVkdWNlKChhY2MsIHBhcnQpID0+IChhY2MgPDwgOCkgKyBwYXJ0LCAwKSA+Pj4gMDtcbn1cbmV4cG9ydHMuaXB2NFRvSW50MzIgPSBpcHY0VG9JbnQzMjtcbmZ1bmN0aW9uIGludDMyVG9JcHY0KGludDMyKSB7XG4gICAgLy8gRXh0cmFjdCBlYWNoIGJ5dGUgKG9jdGV0KSBmcm9tIHRoZSAzMi1iaXQgaW50ZWdlclxuICAgIGNvbnN0IG9jdGV0MSA9IChpbnQzMiA+Pj4gMjQpICYgMHhmZjtcbiAgICBjb25zdCBvY3RldDIgPSAoaW50MzIgPj4+IDE2KSAmIDB4ZmY7XG4gICAgY29uc3Qgb2N0ZXQzID0gKGludDMyID4+PiA4KSAmIDB4ZmY7XG4gICAgY29uc3Qgb2N0ZXQ0ID0gaW50MzIgJiAweGZmO1xuICAgIC8vIENvbWJpbmUgdGhlIG9jdGV0cyBpbnRvIGEgc3RyaW5nIGluIElQdjQgZm9ybWF0XG4gICAgcmV0dXJuIFtvY3RldDEsIG9jdGV0Miwgb2N0ZXQzLCBvY3RldDRdLmpvaW4oJy4nKTtcbn1cbmV4cG9ydHMuaW50MzJUb0lwdjQgPSBpbnQzMlRvSXB2NDtcbmZ1bmN0aW9uIGlwVG9CdWZmZXIoaXApIHtcbiAgICBpZiAobmV0LmlzSVB2NChpcCkpIHtcbiAgICAgICAgLy8gSGFuZGxlIElQdjQgYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgaXBfYWRkcmVzc18xLkFkZHJlc3M0KGlwKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFkZHJlc3MudG9BcnJheSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV0LmlzSVB2NihpcCkpIHtcbiAgICAgICAgLy8gSGFuZGxlIElQdjYgYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgaXBfYWRkcmVzc18xLkFkZHJlc3M2KGlwKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFkZHJlc3NcbiAgICAgICAgICAgIC5jYW5vbmljYWxGb3JtKClcbiAgICAgICAgICAgIC5zcGxpdCgnOicpXG4gICAgICAgICAgICAubWFwKChzZWdtZW50KSA9PiBzZWdtZW50LnBhZFN0YXJ0KDQsICcwJykpXG4gICAgICAgICAgICAuam9pbignJyksICdoZXgnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJUCBhZGRyZXNzIGZvcm1hdCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuaXBUb0J1ZmZlciA9IGlwVG9CdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/common/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/common/receivebuffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/socks/build/common/receivebuffer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReceiveBuffer = void 0;\nclass ReceiveBuffer {\n    constructor(size = 4096) {\n        this.buffer = Buffer.allocUnsafe(size);\n        this.offset = 0;\n        this.originalSize = size;\n    }\n    get length() {\n        return this.offset;\n    }\n    append(data) {\n        if (!Buffer.isBuffer(data)) {\n            throw new Error('Attempted to append a non-buffer instance to ReceiveBuffer.');\n        }\n        if (this.offset + data.length >= this.buffer.length) {\n            const tmp = this.buffer;\n            this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));\n            tmp.copy(this.buffer);\n        }\n        data.copy(this.buffer, this.offset);\n        return (this.offset += data.length);\n    }\n    peek(length) {\n        if (length > this.offset) {\n            throw new Error('Attempted to read beyond the bounds of the managed internal data.');\n        }\n        return this.buffer.slice(0, length);\n    }\n    get(length) {\n        if (length > this.offset) {\n            throw new Error('Attempted to read beyond the bounds of the managed internal data.');\n        }\n        const value = Buffer.allocUnsafe(length);\n        this.buffer.slice(0, length).copy(value);\n        this.buffer.copyWithin(0, length, length + this.offset - length);\n        this.offset -= length;\n        return value;\n    }\n}\nexports.ReceiveBuffer = ReceiveBuffer;\n//# sourceMappingURL=receivebuffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL3JlY2VpdmVidWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jczItc2tpbi10cmFja2VyLy4vbm9kZV9tb2R1bGVzL3NvY2tzL2J1aWxkL2NvbW1vbi9yZWNlaXZlYnVmZmVyLmpzPzYxMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlY2VpdmVCdWZmZXIgPSB2b2lkIDA7XG5jbGFzcyBSZWNlaXZlQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplID0gNDA5Nikge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldDtcbiAgICB9XG4gICAgYXBwZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGFwcGVuZCBhIG5vbi1idWZmZXIgaW5zdGFuY2UgdG8gUmVjZWl2ZUJ1ZmZlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vZmZzZXQgKyBkYXRhLmxlbmd0aCA+PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHRoaXMuYnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoTWF0aC5tYXgodGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5vcmlnaW5hbFNpemUsIHRoaXMuYnVmZmVyLmxlbmd0aCArIGRhdGEubGVuZ3RoKSk7XG4gICAgICAgICAgICB0bXAuY29weSh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5jb3B5KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIHJldHVybiAodGhpcy5vZmZzZXQgKz0gZGF0YS5sZW5ndGgpO1xuICAgIH1cbiAgICBwZWVrKGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID4gdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHJlYWQgYmV5b25kIHRoZSBib3VuZHMgb2YgdGhlIG1hbmFnZWQgaW50ZXJuYWwgZGF0YS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0KGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID4gdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHJlYWQgYmV5b25kIHRoZSBib3VuZHMgb2YgdGhlIG1hbmFnZWQgaW50ZXJuYWwgZGF0YS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zbGljZSgwLCBsZW5ndGgpLmNvcHkodmFsdWUpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5jb3B5V2l0aGluKDAsIGxlbmd0aCwgbGVuZ3RoICsgdGhpcy5vZmZzZXQgLSBsZW5ndGgpO1xuICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLlJlY2VpdmVCdWZmZXIgPSBSZWNlaXZlQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjZWl2ZWJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/common/receivebuffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/common/util.js":
/*!*************************************************!*\
  !*** ./node_modules/socks/build/common/util.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shuffleArray = exports.SocksClientError = void 0;\n/**\n * Error wrapper for SocksClient\n */\nclass SocksClientError extends Error {\n    constructor(message, options) {\n        super(message);\n        this.options = options;\n    }\n}\nexports.SocksClientError = SocksClientError;\n/**\n * Shuffles a given array.\n * @param array The array to shuffle.\n */\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n}\nexports.shuffleArray = shuffleArray;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jczItc2tpbi10cmFja2VyLy4vbm9kZV9tb2R1bGVzL3NvY2tzL2J1aWxkL2NvbW1vbi91dGlsLmpzPzFjN2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNodWZmbGVBcnJheSA9IGV4cG9ydHMuU29ja3NDbGllbnRFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogRXJyb3Igd3JhcHBlciBmb3IgU29ja3NDbGllbnRcbiAqL1xuY2xhc3MgU29ja3NDbGllbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja3NDbGllbnRFcnJvciA9IFNvY2tzQ2xpZW50RXJyb3I7XG4vKipcbiAqIFNodWZmbGVzIGEgZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVBcnJheShhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgW2FycmF5W2ldLCBhcnJheVtqXV0gPSBbYXJyYXlbal0sIGFycmF5W2ldXTtcbiAgICB9XG59XG5leHBvcnRzLnNodWZmbGVBcnJheSA9IHNodWZmbGVBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/common/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/index.js":
/*!*******************************************!*\
  !*** ./node_modules/socks/build/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./client/socksclient */ \"(rsc)/./node_modules/socks/build/client/socksclient.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG9GQUFzQjtBQUMzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NzMi1za2luLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvaW5kZXguanM/NjgyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NsaWVudC9zb2Nrc2NsaWVudFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/index.js\n");

/***/ })

};
;